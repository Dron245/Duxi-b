(() => {
    var __webpack_modules__ = {
        896: (module, exports) => {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function() {
                function qa(d, l) {
                    d.prototype = db(l.prototype);
                    d.prototype.constructor = d;
                    d.base = l.prototype;
                }
                function db(d) {
                    function l() {}
                    l.prototype = d;
                    return new l;
                }
                function Ya(d, l, P) {
                    "millisecond" === P ? d.setMilliseconds(d.getMilliseconds() + 1 * l) : "second" === P ? d.setSeconds(d.getSeconds() + 1 * l) : "minute" === P ? d.setMinutes(d.getMinutes() + 1 * l) : "hour" === P ? d.setHours(d.getHours() + 1 * l) : "day" === P ? d.setDate(d.getDate() + 1 * l) : "week" === P ? d.setDate(d.getDate() + 7 * l) : "month" === P ? d.setMonth(d.getMonth() + 1 * l) : "year" === P && d.setFullYear(d.getFullYear() + 1 * l);
                    return d;
                }
                function da(d, l) {
                    var P = !1;
                    0 > d && (P = !0, d *= -1);
                    d = "" + d;
                    for (l = l ? l : 1; d.length < l; ) d = "0" + d;
                    return P ? "-" + d : d;
                }
                function Ha(d) {
                    if (!d) return d;
                    d = d.replace(/^\s\s*/, "");
                    for (var l = /\s/, P = d.length; l.test(d.charAt(--P)); ) ;
                    return d.slice(0, P + 1);
                }
                function Aa(d) {
                    d.roundRect = function(d, P, p, v, sa, D, B, t) {
                        B && (this.fillStyle = B);
                        t && (this.strokeStyle = t);
                        "undefined" === typeof sa && (sa = 5);
                        this.lineWidth = D;
                        this.beginPath();
                        this.moveTo(d + sa, P);
                        this.lineTo(d + p - sa, P);
                        this.quadraticCurveTo(d + p, P, d + p, P + sa);
                        this.lineTo(d + p, P + v - sa);
                        this.quadraticCurveTo(d + p, P + v, d + p - sa, P + v);
                        this.lineTo(d + sa, P + v);
                        this.quadraticCurveTo(d, P + v, d, P + v - sa);
                        this.lineTo(d, P + sa);
                        this.quadraticCurveTo(d, P, d + sa, P);
                        this.closePath();
                        B && this.fill();
                        t && 0 < D && this.stroke();
                    };
                }
                function Sa(d, l) {
                    return d - l;
                }
                function Y(d) {
                    var l = ((d & 16711680) >> 16).toString(16), P = ((d & 65280) >> 8).toString(16);
                    d = ((d & 255) >> 0).toString(16);
                    l = 2 > l.length ? "0" + l : l;
                    P = 2 > P.length ? "0" + P : P;
                    d = 2 > d.length ? "0" + d : d;
                    return "#" + l + P + d;
                }
                function eb(d, l) {
                    var P = this.length >>> 0, p = Number(l) || 0;
                    p = 0 > p ? Math.ceil(p) : Math.floor(p);
                    for (0 > p && (p += P); p < P; p++) if (p in this && this[p] === d) return p;
                    return -1;
                }
                function p(d) {
                    return null === d || "undefined" === typeof d;
                }
                function Ea(d) {
                    d.indexOf || (d.indexOf = eb);
                    return d;
                }
                function fb(d) {
                    if (xa.fSDec) d[ja("`eeDwdouMhrudods")](ja("e`u`@ohl`uhnoHuds`uhnoDoe"), (function() {
                        xa._fTWm && xa._fTWm(d);
                    }));
                }
                function Za(d, l, P) {
                    P = P || "normal";
                    var p = d + "_" + l + "_" + P, v = $a[p];
                    if (isNaN(v)) {
                        try {
                            if (!ta) {
                                var sa = document.body;
                                ta = document.createElement("span");
                                ta.innerHTML = "";
                                var D = document.createTextNode("Mpgyi");
                                ta.appendChild(D);
                                sa.appendChild(ta);
                            }
                            ta.style.display = "";
                            X(ta, {
                                position: "absolute",
                                left: "0px",
                                top: "-20000px",
                                padding: "0px",
                                margin: "0px",
                                border: "none",
                                whiteSpace: "pre",
                                lineHeight: "normal",
                                fontFamily: d,
                                fontSize: l + "px",
                                fontWeight: P
                            });
                            v = Math.round(ta.offsetHeight);
                            ta.style.display = "none";
                        } catch (B) {
                            v = Math.ceil(1.1 * l);
                        }
                        v = Math.max(v, l);
                        $a[p] = v;
                    }
                    return v;
                }
                function H(d, l) {
                    var p = [];
                    if (p = {
                        solid: [],
                        shortDash: [ 3, 1 ],
                        shortDot: [ 1, 1 ],
                        shortDashDot: [ 3, 1, 1, 1 ],
                        shortDashDotDot: [ 3, 1, 1, 1, 1, 1 ],
                        dot: [ 1, 2 ],
                        dash: [ 4, 2 ],
                        dashDot: [ 4, 2, 1, 2 ],
                        longDash: [ 8, 2 ],
                        longDashDot: [ 8, 2, 1, 2 ],
                        longDashDotDot: [ 8, 2, 1, 2, 1, 2 ]
                    }[d || "solid"]) for (var v = 0; v < p.length; v++) p[v] *= l; else p = [];
                    return p;
                }
                function S(d, l, P, v, ia) {
                    v = v || [];
                    ia = p(ia) ? gb ? {
                        passive: !1,
                        capture: !1
                    } : !1 : ia;
                    v.push([ d, l, P, ia ]);
                    return d.addEventListener ? (d.addEventListener(l, P, ia), P) : d.attachEvent ? (v = function(l) {
                        l = l || window.event;
                        l.preventDefault = l.preventDefault || function() {
                            l.returnValue = !1;
                        };
                        l.stopPropagation = l.stopPropagation || function() {
                            l.cancelBubble = !0;
                        };
                        P.call(d, l);
                    }, d.attachEvent("on" + l, v), v) : !1;
                }
                function hb(d) {
                    if (d._menuButton) d.exportEnabled ? (X(d._menuButton, {
                        backgroundColor: d.toolbar.itemBackgroundColor,
                        color: d.toolbar.fontColor
                    }), Ma(d._menuButton), ua(d, d._menuButton, "menu")) : ya(d._menuButton); else if (d.exportEnabled && v) {
                        var l = !1;
                        d._menuButton = document.createElement("button");
                        ua(d, d._menuButton, "menu");
                        d._toolBar.appendChild(d._menuButton);
                        S(d._menuButton, "touchstart", (function(d) {
                            l = !0;
                        }), d.allDOMEventHandlers);
                        S(d._menuButton, "click", (function() {
                            "none" !== d._dropdownMenu.style.display || d._dropDownCloseTime && 500 >= (new Date).getTime() - d._dropDownCloseTime.getTime() || (d._dropdownMenu.style.display = "block", 
                            d._menuButton.blur(), d._dropdownMenu.focus());
                        }), d.allDOMEventHandlers, !0);
                        S(d._menuButton, "mousemove", (function() {
                            l || (X(d._menuButton, {
                                backgroundColor: d.toolbar.itemBackgroundColorOnHover,
                                color: d.toolbar.fontColorOnHover
                            }), 0 >= navigator.userAgent.search("MSIE") && X(d._menuButton.childNodes[0], {
                                WebkitFilter: "invert(100%)",
                                filter: "invert(100%)"
                            }));
                        }), d.allDOMEventHandlers, !0);
                        S(d._menuButton, "mouseout", (function() {
                            l || (X(d._menuButton, {
                                backgroundColor: d.toolbar.itemBackgroundColor,
                                color: d.toolbar.fontColor
                            }), 0 >= navigator.userAgent.search("MSIE") && X(d._menuButton.childNodes[0], {
                                WebkitFilter: "invert(0%)",
                                filter: "invert(0%)"
                            }));
                        }), d.allDOMEventHandlers, !0);
                    }
                    if (d.exportEnabled && d._dropdownMenu) {
                        X(d._dropdownMenu, {
                            backgroundColor: d.toolbar.itemBackgroundColor,
                            color: d.toolbar.fontColor
                        });
                        for (var p = d._dropdownMenu.childNodes, Z = [ d._cultureInfo.printText, d._cultureInfo.saveJPGText, d._cultureInfo.savePNGText ], ia = 0; ia < p.length; ia++) X(p[ia], {
                            backgroundColor: d.toolbar.itemBackgroundColor,
                            color: d.toolbar.fontColor
                        }), p[ia].innerHTML = Z[ia];
                    } else !d._dropdownMenu && d.exportEnabled && v && (l = !1, d._dropdownMenu = document.createElement("div"), 
                    d._dropdownMenu.setAttribute("tabindex", -1), p = -1 !== d.theme.indexOf("dark") ? "black" : "#888888", 
                    X(d._dropdownMenu, {
                        position: "absolute",
                        zIndex: 1,
                        userSelect: "none",
                        MozUserSeelct: "none",
                        WebkitUserSelect: "none",
                        msUserSelect: "none",
                        cursor: "pointer",
                        right: "0px",
                        top: "25px",
                        minWidth: "120px",
                        outline: 0,
                        fontSize: "14px",
                        fontFamily: "Arial, Helvetica, sans-serif",
                        padding: "5px 0px 5px 0px",
                        textAlign: "left",
                        lineHeight: "10px",
                        backgroundColor: d.toolbar.itemBackgroundColor,
                        boxShadow: "2px 2px 10px" + p
                    }), d._dropdownMenu.style.display = "none", d._toolBar.appendChild(d._dropdownMenu), 
                    S(d._dropdownMenu, "blur", (function() {
                        ya(d._dropdownMenu);
                        d._dropDownCloseTime = new Date;
                    }), d.allDOMEventHandlers, !0), p = document.createElement("div"), X(p, {
                        padding: "12px 8px 12px 8px"
                    }), p.innerHTML = d._cultureInfo.printText, p.style.backgroundColor = d.toolbar.itemBackgroundColor, 
                    p.style.color = d.toolbar.fontColor, d._dropdownMenu.appendChild(p), S(p, "touchstart", (function(d) {
                        l = !0;
                    }), d.allDOMEventHandlers), S(p, "mousemove", (function() {
                        l || (this.style.backgroundColor = d.toolbar.itemBackgroundColorOnHover, this.style.color = d.toolbar.fontColorOnHover);
                    }), d.allDOMEventHandlers, !0), S(p, "mouseout", (function() {
                        l || (this.style.backgroundColor = d.toolbar.itemBackgroundColor, this.style.color = d.toolbar.fontColor);
                    }), d.allDOMEventHandlers, !0), S(p, "click", (function() {
                        d.print();
                        ya(d._dropdownMenu);
                    }), d.allDOMEventHandlers, !0), p = document.createElement("div"), X(p, {
                        padding: "12px 8px 12px 8px"
                    }), p.innerHTML = d._cultureInfo.saveJPGText, p.style.backgroundColor = d.toolbar.itemBackgroundColor, 
                    p.style.color = d.toolbar.fontColor, d._dropdownMenu.appendChild(p), S(p, "touchstart", (function(d) {
                        l = !0;
                    }), d.allDOMEventHandlers), S(p, "mousemove", (function() {
                        l || (this.style.backgroundColor = d.toolbar.itemBackgroundColorOnHover, this.style.color = d.toolbar.fontColorOnHover);
                    }), d.allDOMEventHandlers, !0), S(p, "mouseout", (function() {
                        l || (this.style.backgroundColor = d.toolbar.itemBackgroundColor, this.style.color = d.toolbar.fontColor);
                    }), d.allDOMEventHandlers, !0), S(p, "click", (function() {
                        d.exportChart({
                            format: "jpeg",
                            fileName: d.exportFileName
                        });
                        ya(d._dropdownMenu);
                    }), d.allDOMEventHandlers, !0), p = document.createElement("div"), X(p, {
                        padding: "12px 8px 12px 8px"
                    }), p.innerHTML = d._cultureInfo.savePNGText, p.style.backgroundColor = d.toolbar.itemBackgroundColor, 
                    p.style.color = d.toolbar.fontColor, d._dropdownMenu.appendChild(p), S(p, "touchstart", (function(d) {
                        l = !0;
                    }), d.allDOMEventHandlers), S(p, "mousemove", (function() {
                        l || (this.style.backgroundColor = d.toolbar.itemBackgroundColorOnHover, this.style.color = d.toolbar.fontColorOnHover);
                    }), d.allDOMEventHandlers, !0), S(p, "mouseout", (function() {
                        l || (this.style.backgroundColor = d.toolbar.itemBackgroundColor, this.style.color = d.toolbar.fontColor);
                    }), d.allDOMEventHandlers, !0), S(p, "click", (function() {
                        d.exportChart({
                            format: "png",
                            fileName: d.exportFileName
                        });
                        ya(d._dropdownMenu);
                    }), d.allDOMEventHandlers, !0));
                }
                function ab(d, l, p) {
                    d *= ma;
                    l *= ma;
                    d = p.getImageData(d, l, 2, 2).data;
                    l = !0;
                    for (p = 0; 4 > p; p++) if (d[p] !== d[p + 4] | d[p] !== d[p + 8] | d[p] !== d[p + 12]) {
                        l = !1;
                        break;
                    }
                    return l ? d[0] << 16 | d[1] << 8 | d[2] : 0;
                }
                function oa(d, l, p) {
                    return d in l ? l[d] : p[d];
                }
                function Na(d, l, P, Z) {
                    v && bb ? (Z = !p(Z) && Z ? d.getContext("2d", {
                        willReadFrequently: !0
                    }) : d.getContext("2d"), Oa = Z.webkitBackingStorePixelRatio || Z.mozBackingStorePixelRatio || Z.msBackingStorePixelRatio || Z.oBackingStorePixelRatio || Z.backingStorePixelRatio || 1, 
                    ma = Ta / Oa, d.width = l * ma, d.height = P * ma, Ta !== Oa && (d.style.width = l + "px", 
                    d.style.height = P + "px", Z.scale(ma, ma))) : (d.width = l, d.height = P);
                }
                function ib(d) {
                    if (!jb) {
                        var l = !1, p = !1;
                        "undefined" === typeof ra.Chart.creditHref ? (d.creditHref = ja("iuuqr;..b`ow`rkr/bnl."), 
                        d.creditText = ja("B`ow`rKR/bnl")) : (l = d.updateOption("creditText"), p = d.updateOption("creditHref"));
                        if (d.creditHref && d.creditText) {
                            d._creditLink || (d._creditLink = document.createElement("a"), d._creditLink.setAttribute("class", "canvasjs-chart-credit"), 
                            d._creditLink.setAttribute("title", "JavaScript Charts"), X(d._creditLink, {
                                outline: "none",
                                margin: "0px",
                                position: "absolute",
                                right: "2px",
                                top: d.height - 14 + "px",
                                color: "dimgrey",
                                textDecoration: "none",
                                fontSize: "11px",
                                fontFamily: "Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"
                            }), d._creditLink.setAttribute("tabIndex", -1), d._creditLink.setAttribute("target", "_blank"));
                            if (0 === d.renderCount || l || p) d._creditLink.setAttribute("href", d.creditHref), 
                            d._creditLink.innerHTML = d.creditText;
                            d._creditLink && d.creditHref && d.creditText ? (d._creditLink.parentElement || d._canvasJSContainer.appendChild(d._creditLink), 
                            d._creditLink.style.top = d.height - 14 + "px") : d._creditLink.parentElement && d._canvasJSContainer.removeChild(d._creditLink);
                        }
                    }
                }
                function wa(d, l, p) {
                    Ia && (this.canvasCount |= 0, window.console.log(++this.canvasCount));
                    var Z = document.createElement("canvas");
                    Z.setAttribute("class", "canvasjs-chart-canvas");
                    Na(Z, d, l, p);
                    v || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(Z);
                    return Z;
                }
                function X(d, l) {
                    for (var p in l) d.style[p] = l[p];
                }
                function ua(d, l, p) {
                    l.getAttribute("state") || (l.style.backgroundColor = d.toolbar.itemBackgroundColor, 
                    l.style.color = d.toolbar.fontColor, l.style.border = "none", X(l, {
                        WebkitUserSelect: "none",
                        MozUserSelect: "none",
                        msUserSelect: "none",
                        userSelect: "none"
                    }));
                    l.getAttribute("state") !== p && (l.setAttribute("state", p), l.setAttribute("type", "button"), 
                    X(l, {
                        padding: "5px 12px",
                        cursor: "pointer",
                        float: "left",
                        width: "40px",
                        height: "25px",
                        outline: "0px",
                        verticalAlign: "baseline",
                        lineHeight: "0"
                    }), l.innerHTML = "<img src='" + kb[p].image + "' alt='" + d._cultureInfo[p + "Text"] + "' />", 
                    X(l.childNodes[0], {
                        height: "95%",
                        pointerEvents: "none"
                    }));
                    l.setAttribute("title", d._cultureInfo[p + "Text"]);
                }
                function Ma() {
                    for (var d = null, l = 0; l < arguments.length; l++) d = arguments[l], d.style && (d.style.display = "inline");
                }
                function ya() {
                    for (var d = null, l = 0; l < arguments.length; l++) (d = arguments[l]) && d.style && (d.style.display = "none");
                }
                function Ua(d, l, p, v, ia) {
                    if (null === d || "undefined" === typeof d) return "undefined" === typeof p ? l : p;
                    d = parseFloat(d.toString()) * (0 <= d.toString().indexOf("%") ? l / 100 : 1);
                    "undefined" !== typeof v && (d = Math.min(v, d), "undefined" !== typeof ia && (d = Math.max(ia, d)));
                    return !isNaN(d) && d <= l && 0 <= d ? d : "undefined" === typeof p ? l : p;
                }
                function K(d, l, v, Z, ia) {
                    this._defaultsKey = d;
                    this._themeOptionsKey = l;
                    this._index = Z;
                    this.parent = ia;
                    this._eventListeners = [];
                    d = {};
                    this.theme && p(this.parent) && p(l) && p(Z) ? d = p(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[l] && (null === Z ? d = this.parent.themeOptions[l] : 0 < this.parent.themeOptions[l].length && (Z = Math.min(this.parent.themeOptions[l].length - 1, Z), 
                    d = this.parent.themeOptions[l][Z]));
                    this.themeOptions = d;
                    this.options = v ? v : {
                        _isPlaceholder: !0
                    };
                    this.setOptions(this.options, d);
                }
                function Fa(d, l, p, v, ia) {
                    "undefined" === typeof ia && (ia = 0);
                    this._padding = ia;
                    this._x1 = d;
                    this._y1 = l;
                    this._x2 = p;
                    this._y2 = v;
                    this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
                }
                function ka(d, l) {
                    ka.base.constructor.call(this, "TextBlock", null, l, null, null);
                    this.ctx = d;
                    this._isDirty = !0;
                    this._wrappedText = null;
                    this._initialize();
                }
                function Va(d, l) {
                    Va.base.constructor.call(this, "Toolbar", "toolbar", l, null, d);
                    this.chart = d;
                    this.canvas = d.canvas;
                    this.ctx = this.chart.ctx;
                    this.optionsName = "toolbar";
                }
                function Ba(d, l) {
                    Ba.base.constructor.call(this, "Title", "title", l, null, d);
                    this.chart = d;
                    this.canvas = d.canvas;
                    this.ctx = this.chart.ctx;
                    this.optionsName = "title";
                    if (p(this.options.margin) && d.options.subtitles) for (var v = d.options.subtitles, Z = 0; Z < v.length; Z++) if ((p(v[Z].horizontalAlign) && "center" === this.horizontalAlign || v[Z].horizontalAlign === this.horizontalAlign) && (p(v[Z].verticalAlign) && "top" === this.verticalAlign || v[Z].verticalAlign === this.verticalAlign) && !v[Z].dockInsidePlotArea === !this.dockInsidePlotArea) {
                        this.margin = 0;
                        break;
                    }
                    "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
                    this.height = this.width = null;
                    this.bounds = {
                        x1: null,
                        y1: null,
                        x2: null,
                        y2: null
                    };
                }
                function Ja(d, l, p) {
                    Ja.base.constructor.call(this, "Subtitle", "subtitles", l, p, d);
                    this.chart = d;
                    this.canvas = d.canvas;
                    this.ctx = this.chart.ctx;
                    this.optionsName = "subtitles";
                    this.isOptionsInArray = !0;
                    "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
                    this.height = this.width = null;
                    this.bounds = {
                        x1: null,
                        y1: null,
                        x2: null,
                        y2: null
                    };
                }
                function Wa() {
                    this.pool = [];
                }
                function Ka(d) {
                    var l;
                    d && La[d] && (l = La[d]);
                    Ka.base.constructor.call(this, "CultureInfo", null, l, null, null);
                }
                var I, ca, Q, V, $, Ia = !1, xa = {}, v = !!document.createElement("canvas").getContext, ra = {
                    Chart: {
                        width: 500,
                        height: 400,
                        zoomEnabled: !1,
                        zoomType: "x",
                        backgroundColor: "white",
                        theme: "light1",
                        animationEnabled: !1,
                        animationDuration: 1200,
                        dataPointWidth: null,
                        dataPointMinWidth: null,
                        dataPointMaxWidth: null,
                        colorSet: "colorSet1",
                        culture: "en",
                        creditText: "CanvasJS",
                        interactivityEnabled: !0,
                        exportEnabled: !1,
                        exportFileName: "Chart",
                        rangeChanging: null,
                        rangeChanged: null,
                        publicProperties: {
                            title: "readWrite",
                            subtitles: "readWrite",
                            toolbar: "readWrite",
                            toolTip: "readWrite",
                            legend: "readWrite",
                            axisX: "readWrite",
                            axisY: "readWrite",
                            axisX2: "readWrite",
                            axisY2: "readWrite",
                            data: "readWrite",
                            options: "readWrite",
                            bounds: "readOnly",
                            container: "readOnly",
                            selectedColorSet: "readOnly"
                        }
                    },
                    Title: {
                        padding: 0,
                        text: null,
                        verticalAlign: "top",
                        horizontalAlign: "center",
                        fontSize: 20,
                        fontFamily: "Calibri",
                        fontWeight: "normal",
                        fontColor: "black",
                        fontStyle: "normal",
                        borderThickness: 0,
                        borderColor: "black",
                        cornerRadius: 0,
                        backgroundColor: v ? "transparent" : null,
                        margin: 5,
                        wrap: !0,
                        maxWidth: null,
                        dockInsidePlotArea: !1,
                        publicProperties: {
                            options: "readWrite",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    Subtitle: {
                        padding: 0,
                        text: null,
                        verticalAlign: "top",
                        horizontalAlign: "center",
                        fontSize: 14,
                        fontFamily: "Calibri",
                        fontWeight: "normal",
                        fontColor: "black",
                        fontStyle: "normal",
                        borderThickness: 0,
                        borderColor: "black",
                        cornerRadius: 0,
                        backgroundColor: null,
                        margin: 2,
                        wrap: !0,
                        maxWidth: null,
                        dockInsidePlotArea: !1,
                        publicProperties: {
                            options: "readWrite",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    Toolbar: {
                        itemBackgroundColor: "white",
                        itemBackgroundColorOnHover: "#2196f3",
                        buttonBorderColor: "#2196f3",
                        buttonBorderThickness: 1,
                        fontColor: "black",
                        fontColorOnHover: "white",
                        publicProperties: {
                            options: "readWrite",
                            chart: "readOnly"
                        }
                    },
                    Legend: {
                        name: null,
                        verticalAlign: "center",
                        horizontalAlign: "right",
                        fontSize: 14,
                        fontFamily: "calibri",
                        fontWeight: "normal",
                        fontColor: "black",
                        fontStyle: "normal",
                        cursor: null,
                        itemmouseover: null,
                        itemmouseout: null,
                        itemmousemove: null,
                        itemclick: null,
                        dockInsidePlotArea: !1,
                        reversed: !1,
                        backgroundColor: v ? "transparent" : null,
                        borderColor: v ? "transparent" : null,
                        borderThickness: 0,
                        cornerRadius: 0,
                        maxWidth: null,
                        maxHeight: null,
                        markerMargin: null,
                        itemMaxWidth: null,
                        itemWidth: null,
                        itemWrap: !0,
                        itemTextFormatter: null,
                        publicProperties: {
                            options: "readWrite",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    ToolTip: {
                        enabled: !0,
                        shared: !1,
                        animationEnabled: !0,
                        content: null,
                        contentFormatter: null,
                        reversed: !1,
                        backgroundColor: v ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
                        borderColor: null,
                        borderThickness: 2,
                        cornerRadius: 5,
                        fontSize: 14,
                        fontColor: "black",
                        fontFamily: "Calibri, Arial, Georgia, serif;",
                        fontWeight: "normal",
                        fontStyle: "italic",
                        updated: null,
                        hidden: null,
                        publicProperties: {
                            options: "readWrite",
                            chart: "readOnly"
                        }
                    },
                    Axis: {
                        minimum: null,
                        maximum: null,
                        viewportMinimum: null,
                        viewportMaximum: null,
                        interval: null,
                        intervalType: null,
                        reversed: !1,
                        logarithmic: !1,
                        logarithmBase: 10,
                        title: null,
                        titleFontColor: "black",
                        titleFontSize: 20,
                        titleFontFamily: "arial",
                        titleFontWeight: "normal",
                        titleFontStyle: "normal",
                        titleWrap: !0,
                        titleMaxWidth: null,
                        titleBackgroundColor: v ? "transparent" : null,
                        titleBorderColor: v ? "transparent" : null,
                        titleBorderThickness: 0,
                        titleCornerRadius: 0,
                        labelAngle: 0,
                        labelFontFamily: "arial",
                        labelFontColor: "black",
                        labelFontSize: 12,
                        labelFontWeight: "normal",
                        labelFontStyle: "normal",
                        labelAutoFit: !0,
                        labelWrap: !0,
                        labelMaxWidth: null,
                        labelFormatter: null,
                        labelBackgroundColor: v ? "transparent" : null,
                        labelBorderColor: v ? "transparent" : null,
                        labelBorderThickness: 0,
                        labelCornerRadius: 0,
                        labelPlacement: "outside",
                        labelTextAlign: "left",
                        prefix: "",
                        suffix: "",
                        includeZero: !1,
                        tickLength: 5,
                        tickColor: "black",
                        tickThickness: 1,
                        tickPlacement: "outside",
                        lineColor: "black",
                        lineThickness: 1,
                        lineDashType: "solid",
                        gridColor: "#A0A0A0",
                        gridThickness: 0,
                        gridDashType: "solid",
                        interlacedColor: v ? "transparent" : null,
                        valueFormatString: null,
                        margin: 2,
                        publicProperties: {
                            options: "readWrite",
                            stripLines: "readWrite",
                            scaleBreaks: "readWrite",
                            crosshair: "readWrite",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    StripLine: {
                        value: null,
                        startValue: null,
                        endValue: null,
                        color: "orange",
                        opacity: null,
                        thickness: 2,
                        lineDashType: "solid",
                        label: "",
                        labelPlacement: "inside",
                        labelAlign: "far",
                        labelWrap: !0,
                        labelMaxWidth: null,
                        labelBackgroundColor: null,
                        labelBorderColor: v ? "transparent" : null,
                        labelBorderThickness: 0,
                        labelCornerRadius: 0,
                        labelFontFamily: "arial",
                        labelFontColor: "orange",
                        labelFontSize: 12,
                        labelFontWeight: "normal",
                        labelFontStyle: "normal",
                        labelFormatter: null,
                        showOnTop: !1,
                        publicProperties: {
                            options: "readWrite",
                            axis: "readOnly",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    ScaleBreaks: {
                        autoCalculate: !1,
                        collapsibleThreshold: "25%",
                        maxNumberOfAutoBreaks: 2,
                        spacing: 8,
                        type: "straight",
                        color: "#FFFFFF",
                        fillOpacity: .9,
                        lineThickness: 2,
                        lineColor: "#E16E6E",
                        lineDashType: "solid",
                        publicProperties: {
                            options: "readWrite",
                            customBreaks: "readWrite",
                            axis: "readOnly",
                            autoBreaks: "readOnly",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    Break: {
                        startValue: null,
                        endValue: null,
                        spacing: 8,
                        type: "straight",
                        color: "#FFFFFF",
                        fillOpacity: .9,
                        lineThickness: 2,
                        lineColor: "#E16E6E",
                        lineDashType: "solid",
                        publicProperties: {
                            options: "readWrite",
                            scaleBreaks: "readOnly",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    Crosshair: {
                        enabled: !1,
                        snapToDataPoint: !1,
                        color: "grey",
                        opacity: null,
                        thickness: 2,
                        lineDashType: "solid",
                        label: "",
                        labelWrap: !0,
                        labelMaxWidth: null,
                        labelBackgroundColor: v ? "grey" : null,
                        labelBorderColor: v ? "grey" : null,
                        labelBorderThickness: 0,
                        labelCornerRadius: 0,
                        labelFontFamily: v ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                        labelFontSize: 12,
                        labelFontColor: "#fff",
                        labelFontWeight: "normal",
                        labelFontStyle: "normal",
                        labelFormatter: null,
                        valueFormatString: null,
                        updated: null,
                        hidden: null,
                        publicProperties: {
                            options: "readWrite",
                            axis: "readOnly",
                            bounds: "readOnly",
                            chart: "readOnly"
                        }
                    },
                    DataSeries: {
                        name: null,
                        dataPoints: null,
                        label: "",
                        bevelEnabled: !1,
                        highlightEnabled: !0,
                        cursor: "default",
                        indexLabel: "",
                        indexLabelPlacement: "auto",
                        indexLabelOrientation: "horizontal",
                        indexLabelTextAlign: "left",
                        indexLabelFontColor: "black",
                        indexLabelFontSize: 12,
                        indexLabelFontStyle: "normal",
                        indexLabelFontFamily: "Arial",
                        indexLabelFontWeight: "normal",
                        indexLabelBackgroundColor: null,
                        indexLabelLineColor: "gray",
                        indexLabelLineThickness: 1,
                        indexLabelLineDashType: "solid",
                        indexLabelMaxWidth: null,
                        indexLabelWrap: !0,
                        indexLabelFormatter: null,
                        lineThickness: 2,
                        lineDashType: "solid",
                        connectNullData: !1,
                        nullDataLineDashType: "dash",
                        color: null,
                        lineColor: null,
                        risingColor: "white",
                        fallingColor: "red",
                        fillOpacity: null,
                        startAngle: 0,
                        radius: null,
                        innerRadius: null,
                        neckHeight: null,
                        neckWidth: null,
                        reversed: !1,
                        valueRepresents: null,
                        linkedDataSeriesIndex: null,
                        whiskerThickness: 2,
                        whiskerDashType: "solid",
                        whiskerColor: null,
                        whiskerLength: null,
                        stemThickness: 2,
                        stemColor: null,
                        stemDashType: "solid",
                        upperBoxColor: "white",
                        lowerBoxColor: "white",
                        type: "column",
                        xValueType: "number",
                        axisXType: "primary",
                        axisYType: "primary",
                        axisXIndex: 0,
                        axisYIndex: 0,
                        xValueFormatString: null,
                        yValueFormatString: null,
                        zValueFormatString: null,
                        percentFormatString: null,
                        showInLegend: null,
                        legendMarkerType: null,
                        legendMarkerColor: null,
                        legendText: null,
                        legendMarkerBorderColor: v ? "transparent" : null,
                        legendMarkerBorderThickness: 0,
                        markerType: "circle",
                        markerColor: null,
                        markerSize: null,
                        markerBorderColor: v ? "transparent" : null,
                        markerBorderThickness: 0,
                        mouseover: null,
                        mouseout: null,
                        mousemove: null,
                        click: null,
                        toolTipContent: null,
                        visible: !0,
                        publicProperties: {
                            options: "readWrite",
                            axisX: "readWrite",
                            axisY: "readWrite",
                            chart: "readOnly"
                        }
                    },
                    TextBlock: {
                        x: 0,
                        y: 0,
                        width: null,
                        height: null,
                        maxWidth: null,
                        maxHeight: null,
                        padding: 0,
                        angle: 0,
                        text: "",
                        horizontalAlign: "center",
                        textAlign: "left",
                        fontSize: 12,
                        fontFamily: "calibri",
                        fontWeight: "normal",
                        fontColor: "black",
                        fontStyle: "normal",
                        borderThickness: 0,
                        borderColor: "black",
                        cornerRadius: 0,
                        backgroundColor: null,
                        textBaseline: "top"
                    },
                    CultureInfo: {
                        decimalSeparator: ".",
                        digitGroupSeparator: ",",
                        zoomText: "Zoom",
                        panText: "Pan",
                        resetText: "Reset",
                        menuText: "More Options",
                        saveJPGText: "Save as JPEG",
                        savePNGText: "Save as PNG",
                        printText: "Print",
                        days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                        shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
                        months: "January February March April May June July August September October November December".split(" "),
                        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
                    }
                }, La = {
                    en: {}
                }, B = v ? "Trebuchet MS, Helvetica, sans-serif" : "Arial", Ga = v ? "Impact, Charcoal, sans-serif" : "Arial", Ca = {
                    colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "),
                    colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "),
                    colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")
                };
                ca = "#333333";
                Q = "#000000";
                I = "#666666";
                $ = V = "#000000";
                var ea = 20, t = 14, Xa = {
                    colorSet: "colorSet1",
                    backgroundColor: "#FFFFFF",
                    title: {
                        fontFamily: Ga,
                        fontSize: 32,
                        fontColor: ca,
                        fontWeight: "normal",
                        verticalAlign: "top",
                        margin: 5
                    },
                    subtitles: [ {
                        fontFamily: Ga,
                        fontSize: t,
                        fontColor: ca,
                        fontWeight: "normal",
                        verticalAlign: "top",
                        margin: 5
                    } ],
                    data: [ {
                        indexLabelFontFamily: B,
                        indexLabelFontSize: t,
                        indexLabelFontColor: ca,
                        indexLabelFontWeight: "normal",
                        indexLabelLineThickness: 1
                    } ],
                    axisX: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: ca,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 0,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    axisX2: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: ca,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 0,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    axisY: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: ca,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 1,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    axisY2: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: ca,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 1,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    legend: {
                        fontFamily: B,
                        fontSize: 14,
                        fontColor: ca,
                        fontWeight: "bold",
                        verticalAlign: "bottom",
                        horizontalAlign: "center"
                    },
                    toolTip: {
                        fontFamily: B,
                        fontSize: 14,
                        fontStyle: "normal",
                        cornerRadius: 0,
                        borderThickness: 1
                    },
                    toolbar: {
                        itemBackgroundColor: "white",
                        itemBackgroundColorOnHover: "#2196f3",
                        buttonBorderColor: "#2196f3",
                        buttonBorderThickness: 1,
                        fontColor: "black",
                        fontColorOnHover: "white"
                    }
                };
                Q = ca = "#F5F5F5";
                I = "#FFFFFF";
                V = "#40BAF1";
                $ = "#F5F5F5";
                ea = 20, t = 14;
                var cb = {
                    colorSet: "colorSet2",
                    title: {
                        fontFamily: B,
                        fontSize: 33,
                        fontColor: "#3A3A3A",
                        fontWeight: "bold",
                        verticalAlign: "top",
                        margin: 5
                    },
                    subtitles: [ {
                        fontFamily: B,
                        fontSize: t,
                        fontColor: "#3A3A3A",
                        fontWeight: "normal",
                        verticalAlign: "top",
                        margin: 5
                    } ],
                    data: [ {
                        indexLabelFontFamily: B,
                        indexLabelFontSize: t,
                        indexLabelFontColor: "#666666",
                        indexLabelFontWeight: "normal",
                        indexLabelLineThickness: 1
                    } ],
                    axisX: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: "#666666",
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: "#666666",
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: "#BBBBBB",
                        tickThickness: 1,
                        tickColor: "#BBBBBB",
                        gridThickness: 1,
                        gridColor: "#BBBBBB",
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FFA500",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FFA500",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: "black",
                            color: "black",
                            thickness: 1,
                            lineDashType: "dot"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    axisX2: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: "#666666",
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: "#666666",
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: "#BBBBBB",
                        tickColor: "#BBBBBB",
                        tickThickness: 1,
                        gridThickness: 1,
                        gridColor: "#BBBBBB",
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FFA500",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FFA500",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: "black",
                            color: "black",
                            thickness: 1,
                            lineDashType: "dot"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    axisY: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: "#666666",
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: "#666666",
                        labelFontWeight: "normal",
                        lineThickness: 0,
                        lineColor: "#BBBBBB",
                        tickColor: "#BBBBBB",
                        tickThickness: 1,
                        gridThickness: 1,
                        gridColor: "#BBBBBB",
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FFA500",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FFA500",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: "black",
                            color: "black",
                            thickness: 1,
                            lineDashType: "dot"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    axisY2: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: "#666666",
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: "#666666",
                        labelFontWeight: "normal",
                        lineThickness: 0,
                        lineColor: "#BBBBBB",
                        tickColor: "#BBBBBB",
                        tickThickness: 1,
                        gridThickness: 1,
                        gridColor: "#BBBBBB",
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FFA500",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FFA500",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#EEEEEE",
                            labelFontWeight: "normal",
                            labelBackgroundColor: "black",
                            color: "black",
                            thickness: 1,
                            lineDashType: "dot"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#BBBBBB",
                            lineThickness: 1,
                            lineDashType: "solid"
                        }
                    } ],
                    legend: {
                        fontFamily: B,
                        fontSize: 14,
                        fontColor: "#3A3A3A",
                        fontWeight: "bold",
                        verticalAlign: "bottom",
                        horizontalAlign: "center"
                    },
                    toolTip: {
                        fontFamily: B,
                        fontSize: 14,
                        fontStyle: "normal",
                        cornerRadius: 0,
                        borderThickness: 1
                    },
                    toolbar: {
                        itemBackgroundColor: "white",
                        itemBackgroundColorOnHover: "#2196f3",
                        buttonBorderColor: "#2196f3",
                        buttonBorderThickness: 1,
                        fontColor: "black",
                        fontColorOnHover: "white"
                    }
                };
                Q = ca = "#F5F5F5";
                I = "#FFFFFF";
                V = "#40BAF1";
                $ = "#F5F5F5";
                ea = 20;
                t = 14;
                Ga = {
                    colorSet: "colorSet12",
                    backgroundColor: "#2A2A2A",
                    title: {
                        fontFamily: Ga,
                        fontSize: 32,
                        fontColor: ca,
                        fontWeight: "normal",
                        verticalAlign: "top",
                        margin: 5
                    },
                    subtitles: [ {
                        fontFamily: Ga,
                        fontSize: t,
                        fontColor: ca,
                        fontWeight: "normal",
                        verticalAlign: "top",
                        margin: 5
                    } ],
                    toolbar: {
                        itemBackgroundColor: "#666666",
                        itemBackgroundColorOnHover: "#FF7372",
                        buttonBorderColor: "#FF7372",
                        buttonBorderThickness: 1,
                        fontColor: "#F5F5F5",
                        fontColorOnHover: "#F5F5F5"
                    },
                    data: [ {
                        indexLabelFontFamily: B,
                        indexLabelFontSize: t,
                        indexLabelFontColor: Q,
                        indexLabelFontWeight: "normal",
                        indexLabelLineThickness: 1
                    } ],
                    axisX: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: Q,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 0,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#000000",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#777777",
                            lineThickness: 1,
                            lineDashType: "solid",
                            color: "#111111"
                        }
                    } ],
                    axisX2: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: Q,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 0,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#000000",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#777777",
                            lineThickness: 1,
                            lineDashType: "solid",
                            color: "#111111"
                        }
                    } ],
                    axisY: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: Q,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 1,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#000000",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#777777",
                            lineThickness: 1,
                            lineDashType: "solid",
                            color: "#111111"
                        }
                    } ],
                    axisY2: [ {
                        titleFontFamily: B,
                        titleFontSize: ea,
                        titleFontColor: Q,
                        titleFontWeight: "normal",
                        labelFontFamily: B,
                        labelFontSize: t,
                        labelFontColor: Q,
                        labelFontWeight: "normal",
                        lineThickness: 1,
                        lineColor: I,
                        tickThickness: 1,
                        tickColor: I,
                        gridThickness: 1,
                        gridColor: I,
                        stripLines: [ {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#FF7300",
                            labelFontWeight: "normal",
                            labelBackgroundColor: null,
                            color: "#FF7300",
                            thickness: 1
                        } ],
                        crosshair: {
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: "#000000",
                            labelFontWeight: "normal",
                            labelBackgroundColor: $,
                            color: V,
                            thickness: 1,
                            lineDashType: "dash"
                        },
                        scaleBreaks: {
                            type: "zigzag",
                            spacing: "2%",
                            lineColor: "#777777",
                            lineThickness: 1,
                            lineDashType: "solid",
                            color: "#111111"
                        }
                    } ],
                    legend: {
                        fontFamily: B,
                        fontSize: 14,
                        fontColor: ca,
                        fontWeight: "bold",
                        verticalAlign: "bottom",
                        horizontalAlign: "center"
                    },
                    toolTip: {
                        fontFamily: B,
                        fontSize: 14,
                        fontStyle: "normal",
                        cornerRadius: 0,
                        borderThickness: 1,
                        fontColor: Q,
                        backgroundColor: "rgba(0, 0, 0, .7)"
                    }
                };
                I = "#FFFFFF";
                Q = ca = "#FAFAFA";
                V = "#40BAF1";
                $ = "#F5F5F5";
                ea = 20, t = 14;
                var Pa = {
                    light1: Xa,
                    light2: cb,
                    dark1: Ga,
                    dark2: {
                        colorSet: "colorSet2",
                        backgroundColor: "#32373A",
                        title: {
                            fontFamily: B,
                            fontSize: 32,
                            fontColor: ca,
                            fontWeight: "normal",
                            verticalAlign: "top",
                            margin: 5
                        },
                        subtitles: [ {
                            fontFamily: B,
                            fontSize: t,
                            fontColor: ca,
                            fontWeight: "normal",
                            verticalAlign: "top",
                            margin: 5
                        } ],
                        toolbar: {
                            itemBackgroundColor: "#666666",
                            itemBackgroundColorOnHover: "#FF7372",
                            buttonBorderColor: "#FF7372",
                            buttonBorderThickness: 1,
                            fontColor: "#F5F5F5",
                            fontColorOnHover: "#F5F5F5"
                        },
                        data: [ {
                            indexLabelFontFamily: B,
                            indexLabelFontSize: t,
                            indexLabelFontColor: Q,
                            indexLabelFontWeight: "normal",
                            indexLabelLineThickness: 1
                        } ],
                        axisX: [ {
                            titleFontFamily: B,
                            titleFontSize: ea,
                            titleFontColor: Q,
                            titleFontWeight: "normal",
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: Q,
                            labelFontWeight: "normal",
                            lineThickness: 1,
                            lineColor: I,
                            tickThickness: 1,
                            tickColor: I,
                            gridThickness: 0,
                            gridColor: I,
                            stripLines: [ {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#FF7300",
                                labelFontWeight: "normal",
                                labelBackgroundColor: null,
                                color: "#FF7300",
                                thickness: 1
                            } ],
                            crosshair: {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#000000",
                                labelFontWeight: "normal",
                                labelBackgroundColor: $,
                                color: V,
                                thickness: 1,
                                lineDashType: "dash"
                            },
                            scaleBreaks: {
                                type: "zigzag",
                                spacing: "2%",
                                lineColor: "#777777",
                                lineThickness: 1,
                                lineDashType: "solid",
                                color: "#111111"
                            }
                        } ],
                        axisX2: [ {
                            titleFontFamily: B,
                            titleFontSize: ea,
                            titleFontColor: Q,
                            titleFontWeight: "normal",
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: Q,
                            labelFontWeight: "normal",
                            lineThickness: 1,
                            lineColor: I,
                            tickThickness: 1,
                            tickColor: I,
                            gridThickness: 0,
                            gridColor: I,
                            stripLines: [ {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#FF7300",
                                labelFontWeight: "normal",
                                labelBackgroundColor: null,
                                color: "#FF7300",
                                thickness: 1
                            } ],
                            crosshair: {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#000000",
                                labelFontWeight: "normal",
                                labelBackgroundColor: $,
                                color: V,
                                thickness: 1,
                                lineDashType: "dash"
                            },
                            scaleBreaks: {
                                type: "zigzag",
                                spacing: "2%",
                                lineColor: "#777777",
                                lineThickness: 1,
                                lineDashType: "solid",
                                color: "#111111"
                            }
                        } ],
                        axisY: [ {
                            titleFontFamily: B,
                            titleFontSize: ea,
                            titleFontColor: Q,
                            titleFontWeight: "normal",
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: Q,
                            labelFontWeight: "normal",
                            lineThickness: 0,
                            lineColor: I,
                            tickThickness: 1,
                            tickColor: I,
                            gridThickness: 1,
                            gridColor: I,
                            stripLines: [ {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#FF7300",
                                labelFontWeight: "normal",
                                labelBackgroundColor: null,
                                color: "#FF7300",
                                thickness: 1
                            } ],
                            crosshair: {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#000000",
                                labelFontWeight: "normal",
                                labelBackgroundColor: $,
                                color: V,
                                thickness: 1,
                                lineDashType: "dash"
                            },
                            scaleBreaks: {
                                type: "zigzag",
                                spacing: "2%",
                                lineColor: "#777777",
                                lineThickness: 1,
                                lineDashType: "solid",
                                color: "#111111"
                            }
                        } ],
                        axisY2: [ {
                            titleFontFamily: B,
                            titleFontSize: ea,
                            titleFontColor: Q,
                            titleFontWeight: "normal",
                            labelFontFamily: B,
                            labelFontSize: t,
                            labelFontColor: Q,
                            labelFontWeight: "normal",
                            lineThickness: 0,
                            lineColor: I,
                            tickThickness: 1,
                            tickColor: I,
                            gridThickness: 1,
                            gridColor: I,
                            stripLines: [ {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#FF7300",
                                labelFontWeight: "normal",
                                labelBackgroundColor: null,
                                color: "#FF7300",
                                thickness: 1
                            } ],
                            crosshair: {
                                labelFontFamily: B,
                                labelFontSize: t,
                                labelFontColor: "#000000",
                                labelFontWeight: "normal",
                                labelBackgroundColor: $,
                                color: V,
                                thickness: 1,
                                lineDashType: "dash"
                            },
                            scaleBreaks: {
                                type: "zigzag",
                                spacing: "2%",
                                lineColor: "#777777",
                                lineThickness: 1,
                                lineDashType: "solid",
                                color: "#111111"
                            }
                        } ],
                        legend: {
                            fontFamily: B,
                            fontSize: 14,
                            fontColor: ca,
                            fontWeight: "bold",
                            verticalAlign: "bottom",
                            horizontalAlign: "center"
                        },
                        toolTip: {
                            fontFamily: B,
                            fontSize: 14,
                            fontStyle: "normal",
                            cornerRadius: 0,
                            borderThickness: 1,
                            fontColor: Q,
                            backgroundColor: "rgba(0, 0, 0, .7)"
                        }
                    },
                    theme1: Xa,
                    theme2: cb,
                    theme3: Xa
                }, U = {
                    numberDuration: 1,
                    yearDuration: 314496e5,
                    monthDuration: 2592e6,
                    weekDuration: 6048e5,
                    dayDuration: 864e5,
                    hourDuration: 36e5,
                    minuteDuration: 6e4,
                    secondDuration: 1e3,
                    millisecondDuration: 1,
                    dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
                };
                (function() {
                    xa.fSDec = function(d) {
                        for (var l = "", p = 0; p < d.length; p++) l += String.fromCharCode(Math.ceil(d.length / 57 / 5) ^ d.charCodeAt(p));
                        return l;
                    };
                    delete ra[xa.fSDec("Bi`su")][xa.fSDec("bsdehuIsdg")];
                    xa.pro = {
                        sCH: ra[xa.fSDec("Bi`su")][xa.fSDec("bsdehuIsdg")]
                    };
                })();
                var gb = function() {
                    var d = !1;
                    try {
                        var l = Object.defineProperty && Object.defineProperty({}, "passive", {
                            get: function() {
                                d = !0;
                                return !1;
                            }
                        });
                        window.addEventListener && (window.addEventListener("test", null, l), window.removeEventListener("test", null, l));
                    } catch (p) {
                        d = !1;
                    }
                    return d;
                }(), $a = {}, ta = null, lb = function() {
                    this.ctx.clearRect(0, 0, this.width, this.height);
                    this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height));
                }, za = function(d) {
                    d.width = 1;
                    d.height = 1;
                    d.getContext("2d") && d.getContext("2d").clearRect(0, 0, 1, 1);
                }, mb = function(d, l, p) {
                    l = Math.min(this.width, this.height);
                    return Math.max("theme4" === this.theme ? 0 : 300 <= l ? 12 : 11, Math.round(l * (d / 400)));
                }, Da = function() {
                    var d = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, l = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), p = "Sun Mon Tue Wed Thu Fri Sat".split(" "), v = "January February March April May June July August September October November December".split(" "), ia = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), B = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, D = /[^-+\dA-Z]/g;
                    return function(t, H, O) {
                        var I = O ? O.days : l, Y = O ? O.months : v, S = O ? O.shortDays : p, U = O ? O.shortMonths : ia;
                        O = "";
                        var X = !1;
                        t = t && t.getTime ? t : t ? new Date(t) : new Date;
                        if (isNaN(t)) throw SyntaxError("invalid date");
                        "UTC:" === H.slice(0, 4) && (H = H.slice(4), X = !0);
                        O = X ? "getUTC" : "get";
                        var K = t[O + "Date"](), N = t[O + "Day"](), W = t[O + "Month"](), a = t[O + "FullYear"](), e = t[O + "Hours"](), c = t[O + "Minutes"](), b = t[O + "Seconds"](), f = t[O + "Milliseconds"](), h = X ? 0 : t.getTimezoneOffset();
                        return O = H.replace(d, (function(r) {
                            switch (r) {
                              case "D":
                                return K;

                              case "DD":
                                return da(K, 2);

                              case "DDD":
                                return S[N];

                              case "DDDD":
                                return I[N];

                              case "M":
                                return W + 1;

                              case "MM":
                                return da(W + 1, 2);

                              case "MMM":
                                return U[W];

                              case "MMMM":
                                return Y[W];

                              case "Y":
                                return parseInt(String(a).slice(-2));

                              case "YY":
                                return da(String(a).slice(-2), 2);

                              case "YYY":
                                return da(String(a).slice(-3), 3);

                              case "YYYY":
                                return da(a, 4);

                              case "h":
                                return e % 12 || 12;

                              case "hh":
                                return da(e % 12 || 12, 2);

                              case "H":
                                return e;

                              case "HH":
                                return da(e, 2);

                              case "m":
                                return c;

                              case "mm":
                                return da(c, 2);

                              case "s":
                                return b;

                              case "ss":
                                return da(b, 2);

                              case "f":
                                return da(String(f), 3).slice(0, 1);

                              case "ff":
                                return da(String(f), 3).slice(0, 2);

                              case "fff":
                                return da(String(f), 3).slice(0, 3);

                              case "t":
                                return 12 > e ? "a" : "p";

                              case "tt":
                                return 12 > e ? "am" : "pm";

                              case "T":
                                return 12 > e ? "A" : "P";

                              case "TT":
                                return 12 > e ? "AM" : "PM";

                              case "K":
                                return X ? "UTC" : (String(t).match(B) || [ "" ]).pop().replace(D, "");

                              case "z":
                                return (0 < h ? "-" : "+") + Math.floor(Math.abs(h) / 60);

                              case "zz":
                                return (0 < h ? "-" : "+") + da(Math.floor(Math.abs(h) / 60), 2);

                              case "zzz":
                                return (0 < h ? "-" : "+") + da(Math.floor(Math.abs(h) / 60), 2) + da(Math.abs(h) % 60, 2);

                              default:
                                return r.slice(1, r.length - 1);
                            }
                        }));
                    };
                }(), nb = function(d) {
                    var l = 0 > d;
                    if (1 > Math.abs(d)) {
                        var p = parseInt(d.toString().split("e-")[1]);
                        p && (d = (l ? -1 * d : d) * Math.pow(10, p - 1), d = "0." + Array(p).join("0") + d.toString().substring(2), 
                        d = l ? "-" + d : d);
                    } else p = parseInt(d.toString().split("+")[1]), 20 < p && (p -= 20, d /= Math.pow(10, p), 
                    d = d.toString() + Array(p + 1).join("0"));
                    return String(d);
                }, fa = function(d, l, p) {
                    if (null === d) return "";
                    if (!isFinite(d)) return d;
                    d = Number(d);
                    var v = 0 > d ? !0 : !1;
                    v && (d *= -1);
                    var B = p ? p.decimalSeparator : ".", t = p ? p.digitGroupSeparator : ",", D = "";
                    l = String(l);
                    D = 1;
                    var H = p = "", I = -1, O = [], Y = [], S = 0, U = 0, X = 0, K = !1, Q = 0;
                    H = l.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
                    l = null;
                    for (var N = 0; H && N < H.length; N++) if (l = H[N], "." === l && 0 > I) I = N; else {
                        if ("%" === l) D *= 100; else if ("‰" === l) {
                            D *= 1e3;
                            continue;
                        } else if ("," === l[0] && "." === l[l.length - 1]) {
                            D /= Math.pow(1e3, l.length - 1);
                            I = N + l.length - 1;
                            continue;
                        } else "E" !== l[0] && "e" !== l[0] || "0" !== l[l.length - 1] || (K = !0);
                        0 > I ? (O.push(l), "#" === l || "0" === l ? S++ : "," === l && X++) : (Y.push(l), 
                        "#" !== l && "0" !== l || U++);
                    }
                    K && (l = Math.floor(d), H = -Math.floor(Math.log(d) / Math.LN10 + 1), Q = 0 === d ? 0 : 0 === l ? -(S + H) : nb(l).length - S, 
                    D /= Math.pow(10, Q));
                    0 > I && (I = N);
                    D = (d * D).toFixed(U);
                    l = D.split(".");
                    D = (l[0] + "").split("");
                    d = (l[1] + "").split("");
                    D && "0" === D[0] && D.shift();
                    for (K = H = N = U = I = 0; 0 < O.length; ) if (l = O.pop(), "#" === l || "0" === l) if (I++, 
                    I === S) {
                        var W = D;
                        D = [];
                        if ("0" === l) for (l = S - U - (W ? W.length : 0); 0 < l; ) W.unshift("0"), l--;
                        for (;0 < W.length; ) p = W.pop() + p, K++, 0 === K % H && N === X && 0 < W.length && (p = t + p);
                    } else 0 < D.length ? (p = D.pop() + p, U++, K++) : "0" === l && (p = "0" + p, U++, 
                    K++), 0 === K % H && N === X && 0 < D.length && (p = t + p); else "E" !== l[0] && "e" !== l[0] || "0" !== l[l.length - 1] || !/[eE][+-]*[0]+/.test(l) ? "," === l ? (N++, 
                    H = K, K = 0, 0 < D.length && (p = t + p)) : p = 1 < l.length && ('"' === l[0] && '"' === l[l.length - 1] || "'" === l[0] && "'" === l[l.length - 1]) ? l.slice(1, l.length - 1) + p : l + p : (l = 0 > Q ? l.replace("+", "").replace("-", "") : l.replace("-", ""), 
                    p += l.replace(/[0]+/, (function(a) {
                        return da(Q, a.length);
                    })));
                    t = "";
                    for (O = !1; 0 < Y.length; ) l = Y.shift(), "#" === l || "0" === l ? 0 < d.length && 0 !== Number(d.join("")) ? (t += d.shift(), 
                    O = !0) : "0" === l && (t += "0", O = !0) : 1 < l.length && ('"' === l[0] && '"' === l[l.length - 1] || "'" === l[0] && "'" === l[l.length - 1]) ? t += l.slice(1, l.length - 1) : "E" !== l[0] && "e" !== l[0] || "0" !== l[l.length - 1] || !/[eE][+-]*[0]+/.test(l) ? t += l : (l = 0 > Q ? l.replace("+", "").replace("-", "") : l.replace("-", ""), 
                    t += l.replace(/[0]+/, (function(a) {
                        return da(Q, a.length);
                    })));
                    p += (O ? B : "") + t;
                    return v ? "-" + p : p;
                }, Qa = function(d) {
                    var l = 0, p = 0;
                    d = d || window.event;
                    d.offsetX || 0 === d.offsetX ? (l = d.offsetX, p = d.offsetY) : d.layerX || 0 == d.layerX ? (l = d.layerX, 
                    p = d.layerY) : (l = d.pageX - d.target.offsetLeft, p = d.pageY - d.target.offsetTop);
                    return {
                        x: l,
                        y: p
                    };
                }, bb = !0, Ta = window.devicePixelRatio || 1, Oa = 1, ma = bb ? Ta / Oa : 1, aa = function(d, l, p, v, t, B, D, H, I, O, Y, U, S) {
                    "undefined" === typeof S && (S = 1);
                    D = D || 0;
                    H = H || "black";
                    var K = 15 < v - l && 15 < t - p ? 8 : .35 * Math.min(v - l, t - p);
                    d.beginPath();
                    d.moveTo(l, p);
                    d.save();
                    d.fillStyle = B;
                    d.globalAlpha = S;
                    d.fillRect(l, p, v - l, t - p);
                    d.globalAlpha = 1;
                    0 < D && (S = 0 === D % 2 ? 0 : .5, d.beginPath(), d.lineWidth = D, d.strokeStyle = H, 
                    d.moveTo(l, p), d.rect(l - S, p - S, v - l + 2 * S, t - p + 2 * S), d.stroke());
                    d.restore();
                    !0 === I && (d.save(), d.beginPath(), d.moveTo(l, p), d.lineTo(l + K, p + K), d.lineTo(v - K, p + K), 
                    d.lineTo(v, p), d.closePath(), D = d.createLinearGradient((v + l) / 2, p + K, (v + l) / 2, p), 
                    D.addColorStop(0, B), D.addColorStop(1, "rgba(255, 255, 255, .4)"), d.fillStyle = D, 
                    d.fill(), d.restore());
                    !0 === O && (d.save(), d.beginPath(), d.moveTo(l, t), d.lineTo(l + K, t - K), d.lineTo(v - K, t - K), 
                    d.lineTo(v, t), d.closePath(), D = d.createLinearGradient((v + l) / 2, t - K, (v + l) / 2, t), 
                    D.addColorStop(0, B), D.addColorStop(1, "rgba(255, 255, 255, .4)"), d.fillStyle = D, 
                    d.fill(), d.restore());
                    !0 === Y && (d.save(), d.beginPath(), d.moveTo(l, p), d.lineTo(l + K, p + K), d.lineTo(l + K, t - K), 
                    d.lineTo(l, t), d.closePath(), D = d.createLinearGradient(l + K, (t + p) / 2, l, (t + p) / 2), 
                    D.addColorStop(0, B), D.addColorStop(1, "rgba(255, 255, 255, 0.1)"), d.fillStyle = D, 
                    d.fill(), d.restore());
                    !0 === U && (d.save(), d.beginPath(), d.moveTo(v, p), d.lineTo(v - K, p + K), d.lineTo(v - K, t - K), 
                    d.lineTo(v, t), D = d.createLinearGradient(v - K, (t + p) / 2, v, (t + p) / 2), 
                    D.addColorStop(0, B), D.addColorStop(1, "rgba(255, 255, 255, 0.1)"), d.fillStyle = D, 
                    D.addColorStop(0, B), D.addColorStop(1, "rgba(255, 255, 255, 0.1)"), d.fillStyle = D, 
                    d.fill(), d.closePath(), d.restore());
                }, ja = function(d) {
                    for (var p = "", v = 0; v < d.length; v++) p += String.fromCharCode(Math.ceil(d.length / 57 / 5) ^ d.charCodeAt(v));
                    return p;
                }, jb = window && window[ja("mnb`uhno")] && window[ja("mnb`uhno")].href && window[ja("mnb`uhno")].href.indexOf && (-1 !== window[ja("mnb`uhno")].href.indexOf(ja("b`ow`rkr/bnl")) || -1 !== window[ja("mnb`uhno")].href.indexOf(ja("gdonqhy/bnl")) || -1 !== window[ja("mnb`uhno")].href.indexOf(ja("gheemd"))) && -1 === window[ja("mnb`uhno")].href.indexOf(ja("gheemd")), kb = {
                    reset: {
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg=="
                    },
                    pan: {
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC"
                    },
                    zoom: {
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII="
                    },
                    menu: {
                        image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC"
                    }
                };
                K.prototype.setOptions = function(d, p) {
                    if (ra[this._defaultsKey]) {
                        var t, v = ra[this._defaultsKey];
                        for (t in v) "publicProperties" !== t && v.hasOwnProperty(t) && (this[t] = d && t in d ? d[t] : p && t in p ? p[t] : v[t]);
                    } else Ia && window.console && console.log("defaults not set");
                };
                K.prototype.get = function(d) {
                    var p = ra[this._defaultsKey];
                    if ("options" === d) return this.options && this.options._isPlaceholder ? null : this.options;
                    if (p.hasOwnProperty(d) || p.publicProperties && p.publicProperties.hasOwnProperty(d)) return this[d];
                    window.console && window.console.log('Property "' + d + "\" doesn't exist. Please check for typo.");
                };
                K.prototype.set = function(d, p, v) {
                    v = "undefined" === typeof v ? !0 : v;
                    var t = ra[this._defaultsKey];
                    if ("options" === d) this.createUserOptions(p); else if (t.hasOwnProperty(d) || t.publicProperties && t.publicProperties.hasOwnProperty(d) && "readWrite" === t.publicProperties[d]) this.options._isPlaceholder && this.createUserOptions(), 
                    this.options[d] = p; else {
                        window.console && (t.publicProperties && t.publicProperties.hasOwnProperty(d) && "readOnly" === t.publicProperties[d] ? window.console.log('Property "' + d + '" is read-only.') : window.console.log('Property "' + d + "\" doesn't exist. Please check for typo."));
                        return;
                    }
                    v && (this.stockChart || this.chart || this).render();
                };
                K.prototype.addTo = function(d, p, v, t) {
                    t = "undefined" === typeof t ? !0 : t;
                    var B = ra[this._defaultsKey];
                    B.hasOwnProperty(d) || B.publicProperties && B.publicProperties.hasOwnProperty(d) && "readWrite" === B.publicProperties[d] ? (this.options._isPlaceholder && this.createUserOptions(), 
                    "undefined" === typeof this.options[d] && (this.options[d] = []), d = this.options[d], 
                    v = "undefined" === typeof v || null === v ? d.length : v, d.splice(v, 0, p), t && (this.stockChart || this.chart || this).render()) : window.console && (B.publicProperties && B.publicProperties.hasOwnProperty(d) && "readOnly" === B.publicProperties[d] ? window.console.log('Property "' + d + '" is read-only.') : window.console.log('Property "' + d + "\" doesn't exist. Please check for typo."));
                };
                K.prototype.createUserOptions = function(d) {
                    if ("undefined" !== typeof d || this.options._isPlaceholder) if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), 
                    this.isOptionsInArray) {
                        this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);
                        var p = this.parent.options[this.optionsName], v = p.length;
                        this.options._isPlaceholder || (Ea(p), v = p.indexOf(this.options));
                        this.options = "undefined" === typeof d ? {} : d;
                        p[v] = this.options;
                    } else this.options = "undefined" === typeof d ? {} : d, d = this.parent.options, 
                    this.optionsName ? p = this.optionsName : (p = this._defaultsKey) && 0 !== p.length ? (v = p.charAt(0).toLowerCase(), 
                    1 < p.length && (v = v.concat(p.slice(1))), p = v) : p = void 0, d[p] = this.options;
                };
                K.prototype.remove = function(d) {
                    d = "undefined" === typeof d ? !0 : d;
                    if (this.isOptionsInArray) {
                        var p = this.parent.options[this.optionsName];
                        Ea(p);
                        var v = p.indexOf(this.options);
                        0 <= v && p.splice(v, 1);
                    } else delete this.parent.options[this.optionsName];
                    d && (this.stockChart || this.chart || this).render();
                };
                K.prototype.updateOption = function(d) {
                    !ra[this._defaultsKey] && Ia && window.console && console.log("defaults not set");
                    var l = ra[this._defaultsKey], v = {}, t = this[d], B = this._themeOptionsKey, H = this._index;
                    this.theme && p(this.parent) && p(B) && p(H) ? v = p(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && this.parent.themeOptions && (this.options.theme && Pa[this.options.theme] ? v = Pa[this.options.theme] : this.parent.themeOptions[B] && (null === H ? v = this.parent.themeOptions[B] : 0 < this.parent.themeOptions[B].length && (v = Math.min(this.parent.themeOptions[B].length - 1, H), 
                    v = this.parent.themeOptions[B][v])));
                    this.themeOptions = v;
                    d in l && (t = d in this.options ? this.options[d] : v && d in v ? v[d] : l[d]);
                    if (t === this[d]) return !1;
                    this[d] = t;
                    return !0;
                };
                K.prototype.trackChanges = function(d) {
                    if (!this.sessionVariables) throw "Session Variable Store not set";
                    this.sessionVariables[d] = this.options[d];
                };
                K.prototype.isBeingTracked = function(d) {
                    this.options._oldOptions || (this.options._oldOptions = {});
                    return this.options._oldOptions[d] ? !0 : !1;
                };
                K.prototype.hasOptionChanged = function(d) {
                    if (!this.sessionVariables) throw "Session Variable Store not set";
                    return this.sessionVariables[d] !== this.options[d];
                };
                K.prototype.addEventListener = function(d, p, v) {
                    d && p && (this._eventListeners[d] = this._eventListeners[d] || [], this._eventListeners[d].push({
                        context: v || this,
                        eventHandler: p
                    }));
                };
                K.prototype.removeEventListener = function(d, p) {
                    if (d && p && this._eventListeners[d]) for (var v = this._eventListeners[d], t = 0; t < v.length; t++) if (v[t].eventHandler === p) {
                        v[t].splice(t, 1);
                        break;
                    }
                };
                K.prototype.removeAllEventListeners = function() {
                    this._eventListeners = [];
                };
                K.prototype.dispatchEvent = function(d, p, v) {
                    if (d && this._eventListeners[d]) {
                        p = p || {};
                        for (var t = this._eventListeners[d], B = 0; B < t.length; B++) t[B].eventHandler.call(t[B].context, p);
                    }
                    "function" === typeof this[d] && this[d].call(v || this.chart, p);
                };
                Fa.prototype.registerSpace = function(d, p) {
                    "top" === d ? this._topOccupied += p.height : "bottom" === d ? this._bottomOccupied += p.height : "left" === d ? this._leftOccupied += p.width : "right" === d && (this._rightOccupied += p.width);
                };
                Fa.prototype.unRegisterSpace = function(d, p) {
                    "top" === d ? this._topOccupied -= p.height : "bottom" === d ? this._bottomOccupied -= p.height : "left" === d ? this._leftOccupied -= p.width : "right" === d && (this._rightOccupied -= p.width);
                };
                Fa.prototype.getFreeSpace = function() {
                    return {
                        x1: this._x1 + this._leftOccupied,
                        y1: this._y1 + this._topOccupied,
                        x2: this._x2 - this._rightOccupied,
                        y2: this._y2 - this._bottomOccupied,
                        width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied,
                        height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied
                    };
                };
                Fa.prototype.reset = function() {
                    this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding;
                };
                qa(ka, K);
                ka.prototype._initialize = function() {
                    p(this.padding) || "object" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = p(this.padding.top) ? 0 : Number(this.padding.top) | 0, 
                    this.rightPadding = p(this.padding.right) ? 0 : Number(this.padding.right) | 0, 
                    this.bottomPadding = p(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, 
                    this.leftPadding = p(this.padding.left) ? 0 : Number(this.padding.left) | 0);
                };
                ka.prototype.render = function(d) {
                    if (0 !== this.fontSize) {
                        d && this.ctx.save();
                        var p = this.ctx.font;
                        this.ctx.textBaseline = this.textBaseline;
                        var v = 0;
                        this._isDirty && this.measureText(this.ctx);
                        this.ctx.translate(this.x, this.y + v);
                        "middle" === this.textBaseline && (v = -this._lineHeight / 2);
                        this.ctx.font = this._getFontString();
                        this.ctx.rotate(Math.PI / 180 * this.angle);
                        var t = 0, B = this.topPadding, H = null;
                        this.ctx.roundRect || Aa(this.ctx);
                        (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, v, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
                        this.ctx.fillStyle = this.fontColor;
                        for (v = 0; v < this._wrappedText.lines.length; v++) {
                            H = this._wrappedText.lines[v];
                            if ("right" === this.horizontalAlign || "right" === this.textAlign) t = this.width - H.width - this.rightPadding; else if ("left" === this.horizontalAlign || "left" === this.textAlign) t = this.leftPadding; else if ("center" === this.horizontalAlign || "center" === this.textAlign) t = (this.width - (this.leftPadding + this.rightPadding)) / 2 - H.width / 2 + this.leftPadding;
                            this.ctx.fillText(H.text, t, B);
                            B += H.height;
                        }
                        this.ctx.font = p;
                        d && this.ctx.restore();
                    }
                };
                ka.prototype.setText = function(d) {
                    this.text = d;
                    this._isDirty = !0;
                    this._wrappedText = null;
                };
                ka.prototype.measureText = function() {
                    this._lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);
                    if (null === this.maxWidth) throw "Please set maxWidth and height for TextBlock";
                    this._wrapText(this.ctx);
                    this._isDirty = !1;
                    return {
                        width: this.width,
                        height: this.height
                    };
                };
                ka.prototype._getLineWithWidth = function(d, p, v) {
                    d = String(d);
                    if (!d) return {
                        text: "",
                        width: 0
                    };
                    var t = v = 0, B = d.length - 1, H = 1 / 0;
                    for (this.ctx.font = this._getFontString(); t <= B; ) {
                        H = Math.floor((t + B) / 2);
                        var D = d.substr(0, H + 1);
                        v = this.ctx.measureText(D).width;
                        if (v < p) t = H + 1; else if (v > p) B = H - 1; else break;
                    }
                    v > p && 1 < D.length && (D = D.substr(0, D.length - 1), v = this.ctx.measureText(D).width);
                    p = !0;
                    if (D.length === d.length || " " === d[D.length]) p = !1;
                    p && (d = D.split(" "), 1 < d.length && d.pop(), D = d.join(" "), v = this.ctx.measureText(D).width);
                    return {
                        text: D,
                        width: v
                    };
                };
                ka.prototype._wrapText = function() {
                    var d = new String(Ha(String(this.text))), p = [], v = this.ctx.font, t = 0, B = 0;
                    this.ctx.font = this._getFontString();
                    if (0 === this.frontSize) B = t = 0; else for (;0 < d.length; ) {
                        var H = this.maxHeight - (this.topPadding + this.bottomPadding), D = this._getLineWithWidth(d, this.maxWidth - (this.leftPadding + this.rightPadding), !1);
                        D.height = this._lineHeight;
                        p.push(D);
                        var K = B;
                        B = Math.max(B, D.width), t = t + D.height, d = Ha(d.slice(D.text.length, d.length));
                        H && t > H && (D = p.pop(), t -= D.height, B = K);
                    }
                    this._wrappedText = {
                        lines: p,
                        width: B,
                        height: t
                    };
                    this.width = B + (this.leftPadding + this.rightPadding);
                    this.height = t + (this.topPadding + this.bottomPadding);
                    this.ctx.font = v;
                };
                ka.prototype._getFontString = function() {
                    var d;
                    d = this.fontStyle ? this.fontStyle + " " : "";
                    d += this.fontWeight ? this.fontWeight + " " : "";
                    d += this.fontSize ? this.fontSize + "px " : "";
                    var p = this.fontFamily ? this.fontFamily + "" : "";
                    !v && p && (p = p.split(",")[0], "'" !== p[0] && '"' !== p[0] && (p = "'" + p + "'"));
                    return d += p;
                };
                qa(Va, K);
                qa(Ba, K);
                Ba.prototype.setLayout = function() {
                    if (this.text) {
                        var K, I, d = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, l = d.layoutManager.getFreeSpace(), v = l.x1, t = l.y1, B = 0, H = 0, D = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 40 : 0;
                        "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = l.width - 4 - D * ("center" === this.horizontalAlign ? 2 : 1)), 
                        H = .5 * l.height - this.margin - 2, B = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = l.height - 4), 
                        H = .5 * l.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = l.width - 4), 
                        H = .5 * l.height - 4));
                        var O;
                        p(this.padding) || "number" !== typeof this.padding ? p(this.padding) || "object" !== typeof this.padding || (O = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, 
                        O += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0) : O = 2 * this.padding;
                        this.wrap || (H = Math.min(H, 1.5 * this.fontSize + O));
                        H = new ka(this.ctx, {
                            fontSize: this.fontSize,
                            fontFamily: this.fontFamily,
                            fontColor: this.fontColor,
                            fontStyle: this.fontStyle,
                            fontWeight: this.fontWeight,
                            horizontalAlign: this.horizontalAlign,
                            textAlign: this.horizontalAlign,
                            verticalAlign: this.verticalAlign,
                            borderColor: this.borderColor,
                            borderThickness: this.borderThickness,
                            backgroundColor: this.backgroundColor,
                            maxWidth: this.maxWidth,
                            maxHeight: H,
                            cornerRadius: this.cornerRadius,
                            text: this.text,
                            padding: this.padding,
                            textBaseline: "middle"
                        });
                        O = H.measureText();
                        "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (t = l.y1 + 2 + this.fontSize / 2 + 4, 
                        I = "top") : "bottom" === this.verticalAlign && (t = l.y2 - 2 - O.height + this.fontSize / 2 + 4, 
                        I = "bottom"), "left" === this.horizontalAlign ? v = l.x1 + 2 : "center" === this.horizontalAlign ? v = l.x1 + l.width / 2 - O.width / 2 : "right" === this.horizontalAlign && (v = l.x2 - 2 - O.width - D), 
                        K = this.horizontalAlign, this.width = O.width, this.height = O.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (v = l.x1 + 2 + (this.fontSize / 2 + 4), 
                        t = l.y2 - 2 - (this.maxWidth / 2 - O.width / 2), B = -90, I = "left", this.width = O.height, 
                        this.height = O.width) : "right" === this.horizontalAlign ? (v = l.x2 - 2 - (this.fontSize / 2 + 4), 
                        t = l.y1 + 2 + (this.maxWidth / 2 - O.width / 2), B = 90, I = "right", this.width = O.height, 
                        this.height = O.width) : "center" === this.horizontalAlign && (t = d.y1 + (d.height / 2 - O.height / 2) + this.fontSize / 2 + 4, 
                        v = d.x1 + (d.width / 2 - O.width / 2), I = "center", this.width = O.width, this.height = O.height), 
                        K = "center");
                        H.x = v;
                        H.y = t;
                        H.angle = B;
                        H.horizontalAlign = K;
                        this._textBlock = H;
                        d.layoutManager.registerSpace(I, {
                            width: this.width + ("left" === I || "right" === I ? this.margin + 2 : 0),
                            height: this.height + ("top" === I || "bottom" === I ? this.margin + 2 : 0)
                        });
                        this.bounds = {
                            x1: v,
                            y1: t,
                            x2: v + this.width,
                            y2: t + this.height
                        };
                        this.ctx.textBaseline = "top";
                    }
                };
                Ba.prototype.render = function() {
                    this._textBlock && this._textBlock.render(!0);
                };
                qa(Ja, K);
                Ja.prototype.setLayout = Ba.prototype.setLayout;
                Ja.prototype.render = Ba.prototype.render;
                Wa.prototype.get = function(d, p) {
                    var v = null;
                    0 < this.pool.length ? (v = this.pool.pop(), Na(v, d, p)) : v = wa(d, p);
                    return v;
                };
                Wa.prototype.release = function(d) {
                    this.pool.push(d);
                };
                qa(Ka, K);
                var Ra = {
                    addTheme: function(d, p) {
                        Pa[d] = p;
                    },
                    addColorSet: function(d, p) {
                        Ca[d] = p;
                    },
                    addCultureInfo: function(d, p) {
                        La[d] = p;
                    },
                    formatNumber: function(d, p, v) {
                        v = v || "en";
                        if (La[v]) return fa(d, p || "#,##0.##", new Ka(v));
                        throw "Unknown Culture Name";
                    },
                    formatDate: function(d, p, v) {
                        v = v || "en";
                        if (La[v]) return Da(d, p || "DD MMM YYYY", new Ka(v));
                        throw "Unknown Culture Name";
                    }
                };
                true && "undefined" !== typeof module.exports ? module.exports = Ra : true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], 
                __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return Ra;
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
                B = Ra.Chart = function() {
                    function d(a, e) {
                        return a.x - e.x;
                    }
                    function l(a, e, c) {
                        e = e || {};
                        p(c) ? (this.predefinedThemes = Pa, this.optionsName = this.parent = this.index = null) : (this.parent = c.parent, 
                        this.index = c.index, this.predefinedThemes = c.predefinedThemes, this.optionsName = c.optionsName, 
                        this.stockChart = c.stockChart, this.panel = a, this.isOptionsInArray = c.isOptionsInArray);
                        this.theme = p(e.theme) || p(this.predefinedThemes[e.theme]) ? "light1" : e.theme;
                        l.base.constructor.call(this, "Chart", this.optionsName, e, this.index, this.parent);
                        var b = this;
                        this._containerId = a;
                        this._objectsInitialized = !1;
                        this.overlaidCanvasCtx = this.ctx = null;
                        this._indexLabels = [];
                        this._panTimerId = 0;
                        this._lastTouchEventType = "";
                        this._lastTouchData = null;
                        this.isAnimating = !1;
                        this.renderCount = 0;
                        this.disableToolTip = this.animatedRender = !1;
                        this.canvasPool = new Wa;
                        this.allDOMEventHandlers = [];
                        this.panEnabled = !1;
                        this._defaultCursor = "default";
                        this.plotArea = {
                            canvas: null,
                            ctx: null,
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 0,
                            width: 0,
                            height: 0
                        };
                        this._dataInRenderedOrder = [];
                        (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this.container.innerHTML = "", 
                        e = a = 0, a = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, 
                        e = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height, 
                        this.width = a, this.height = e, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, 
                        this.selectedColorSet = "undefined" !== typeof Ca[this.colorSet] ? Ca[this.colorSet] : Ca.colorSet1, 
                        this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), 
                        this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", 
                        this._canvasJSContainer.style.cursor = "auto", this._canvasJSContainer.style.direction = "ltr", 
                        v || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), 
                        this.canvas = wa(a, e), this._preRenderCanvas = wa(a, e), this.canvas.style.position = "absolute", 
                        this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", 
                        this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", 
                        this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), 
                        this.ctx.textBaseline = "top", Aa(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), 
                        this._preRenderCtx.textBaseline = "top", Aa(this._preRenderCtx), v ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = wa(a, e), 
                        this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), 
                        this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), 
                        this.overlaidCanvas = wa(a, e), this.overlaidCanvas.style.position = "absolute", 
                        this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", 
                        this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", 
                        this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), 
                        this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", 
                        Aa(this.overlaidCanvasCtx)), this._eventManager = new $(this), this.windowResizeHandler = S(window, "resize", (function() {
                            b._updateSize() && b.render();
                        }), this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), 
                        X(this._toolBar, {
                            position: "absolute",
                            right: "1px",
                            top: "1px"
                        }), this._canvasJSContainer.appendChild(this._toolBar), this.bounds = {
                            x1: 0,
                            y1: 0,
                            x2: this.width,
                            y2: this.height
                        }, S(this.overlaidCanvas, "click", (function(a) {
                            b._mouseEventHandler(a);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, "mousemove", (function(a) {
                            b._mouseEventHandler(a);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, "mouseup", (function(a) {
                            b._mouseEventHandler(a);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, "mousedown", (function(a) {
                            b._mouseEventHandler(a);
                            ya(b._dropdownMenu);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, "mouseout", (function(a) {
                            b._mouseEventHandler(a);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", (function(a) {
                            b._touchEventHandler(a);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", (function(a) {
                            b._touchEventHandler(a);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", (function(a) {
                            b._touchEventHandler(a);
                        }), this.allDOMEventHandlers), S(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", (function(a) {
                            b._touchEventHandler(a);
                        }), this.allDOMEventHandlers), this.toolTip = new V(this, this.options.toolTip), 
                        this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], 
                        this.sessionVariables = {
                            axisX: [],
                            axisX2: [],
                            axisY: [],
                            axisY2: []
                        })) : window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found');
                    }
                    function t(a, e) {
                        for (var b, c = [], f = 0; f < a.length; f++) if (0 == f) c.push(a[0]); else {
                            var h, r, x;
                            x = f - 1;
                            h = 0 === x ? 0 : x - 1;
                            r = x === a.length - 1 ? x : x + 1;
                            b = Math.abs((a[r].x - a[h].x) / (0 === a[r].x - a[x].x ? .01 : a[r].x - a[x].x)) * (e - 1) / 2 + 1;
                            var J = (a[r].x - a[h].x) / b;
                            b = (a[r].y - a[h].y) / b;
                            c[c.length] = a[x].x > a[h].x && 0 < J || a[x].x < a[h].x && 0 > J ? {
                                x: a[x].x + J / 3,
                                y: a[x].y + b / 3
                            } : {
                                x: a[x].x,
                                y: a[x].y + (1 === c.length ? 0 : b / 9)
                            };
                            x = f;
                            h = 0 === x ? 0 : x - 1;
                            r = x === a.length - 1 ? x : x + 1;
                            b = Math.abs((a[r].x - a[h].x) / (0 === a[x].x - a[h].x ? .01 : a[x].x - a[h].x)) * (e - 1) / 2 + 1;
                            J = (a[r].x - a[h].x) / b;
                            b = (a[r].y - a[h].y) / b;
                            c[c.length] = a[x].x > a[h].x && 0 < J || a[x].x < a[h].x && 0 > J ? {
                                x: a[x].x - J / 3,
                                y: a[x].y - b / 3
                            } : {
                                x: a[x].x,
                                y: a[x].y - b / 9
                            };
                            c[c.length] = a[f];
                        }
                        return c;
                    }
                    function B(a, e, c, b, f, h, r, x, J, k) {
                        var m = 0;
                        k ? (r.color = h, x.color = h) : k = 1;
                        m = J ? Math.abs(f - c) : Math.abs(b - e);
                        m = 0 < r.trimLength ? Math.abs(m * r.trimLength / 100) : Math.abs(m - r.length);
                        J ? (c += m / 2, f -= m / 2) : (e += m / 2, b -= m / 2);
                        m = 1 === Math.round(r.thickness) % 2 ? .5 : 0;
                        var q = 1 === Math.round(x.thickness) % 2 ? .5 : 0;
                        a.save();
                        a.globalAlpha = k;
                        a.strokeStyle = x.color || h;
                        a.lineWidth = x.thickness || 2;
                        a.setLineDash && a.setLineDash(H(x.dashType, x.thickness));
                        a.beginPath();
                        J && 0 < x.thickness ? (a.moveTo(b - r.thickness / 2, Math.round((c + f) / 2) - q), 
                        a.lineTo(e + r.thickness / 2, Math.round((c + f) / 2) - q)) : 0 < x.thickness && (a.moveTo(Math.round((e + b) / 2) - q, c + r.thickness / 2), 
                        a.lineTo(Math.round((e + b) / 2) - q, f - r.thickness / 2));
                        a.stroke();
                        a.strokeStyle = r.color || h;
                        a.lineWidth = r.thickness || 2;
                        a.setLineDash && a.setLineDash(H(r.dashType, r.thickness));
                        a.beginPath();
                        J && 0 < r.thickness ? (a.moveTo(b - m, c), a.lineTo(b - m, f), a.moveTo(e + m, c), 
                        a.lineTo(e + m, f)) : 0 < r.thickness && (a.moveTo(e, c + m), a.lineTo(b, c + m), 
                        a.moveTo(e, f - m), a.lineTo(b, f - m));
                        a.stroke();
                        a.restore();
                    }
                    function I(a, e) {
                        I.base.constructor.call(this, "Legend", "legend", e, null, a);
                        this.chart = a;
                        this.canvas = a.canvas;
                        this.ctx = this.chart.ctx;
                        this.ghostCtx = this.chart._eventManager.ghostCtx;
                        this.items = [];
                        this.optionsName = "legend";
                        this.height = this.width = 0;
                        this.orientation = null;
                        this.dataSeries = [];
                        this.bounds = {
                            x1: null,
                            y1: null,
                            x2: null,
                            y2: null
                        };
                        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
                        this.lineHeight = Za(this.fontFamily, this.fontSize, this.fontWeight);
                        this.horizontalSpacing = this.fontSize;
                    }
                    function Q(a, e, c, b) {
                        Q.base.constructor.call(this, "DataSeries", "data", e, c, a);
                        this.chart = a;
                        this.canvas = a.canvas;
                        this._ctx = a.canvas.ctx;
                        this.index = c;
                        this.noDataPointsInPlotArea = 0;
                        this.id = b;
                        this.chart._eventManager.objectMap[b] = {
                            id: b,
                            objectType: "dataSeries",
                            dataSeriesIndex: c
                        };
                        a = e.dataPoints ? e.dataPoints.length : 0;
                        this.dataPointEOs = [];
                        for (e = 0; e < a; e++) this.dataPointEOs[e] = {};
                        this.dataPointIds = [];
                        this.plotUnit = [];
                        this.axisY = this.axisX = null;
                        this.optionsName = "data";
                        this.isOptionsInArray = !0;
                        null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = .7 : this.fillOpacity = 1);
                        this.axisPlacement = this.getDefaultAxisPlacement();
                        "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize));
                    }
                    function D(a, e, c, b, f, h) {
                        D.base.constructor.call(this, "Axis", e, c, b, a);
                        this.chart = a;
                        this.canvas = a.canvas;
                        this.ctx = a.ctx;
                        this.intervalStartPosition = this.maxHeight = this.maxWidth = 0;
                        this.labels = [];
                        this.dataSeries = [];
                        this._stripLineLabels = this._ticks = this._labels = null;
                        this.dataInfo = {
                            min: 1 / 0,
                            max: -1 / 0,
                            viewPortMin: 1 / 0,
                            viewPortMax: -1 / 0,
                            minDiff: 1 / 0
                        };
                        this.isOptionsInArray = !0;
                        "axisX" === f ? ("left" === h || "bottom" === h ? (this.optionsName = "axisX", p(this.chart.sessionVariables.axisX[b]) && (this.chart.sessionVariables.axisX[b] = {}), 
                        this.sessionVariables = this.chart.sessionVariables.axisX[b]) : (this.optionsName = "axisX2", 
                        p(this.chart.sessionVariables.axisX2[b]) && (this.chart.sessionVariables.axisX2[b] = {}), 
                        this.sessionVariables = this.chart.sessionVariables.axisX2[b]), this.options.interval || (this.intervalType = null)) : "left" === h || "bottom" === h ? (this.optionsName = "axisY", 
                        p(this.chart.sessionVariables.axisY[b]) && (this.chart.sessionVariables.axisY[b] = {}), 
                        this.sessionVariables = this.chart.sessionVariables.axisY[b]) : (this.optionsName = "axisY2", 
                        p(this.chart.sessionVariables.axisY2[b]) && (this.chart.sessionVariables.axisY2[b] = {}), 
                        this.sessionVariables = this.chart.sessionVariables.axisY2[b]);
                        "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));
                        "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));
                        this.type = f;
                        "axisX" !== f || c && "undefined" !== typeof c.gridThickness || (this.gridThickness = 0);
                        this._position = h;
                        this.lineCoordinates = {
                            x1: null,
                            y1: null,
                            x2: null,
                            y2: null,
                            width: null
                        };
                        this.labelAngle = (this.labelAngle % 360 + 360) % 360;
                        90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);
                        this.options.scaleBreaks && (this.scaleBreaks = new ea(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));
                        this.stripLines = [];
                        if (this.options.stripLines && 0 < this.options.stripLines.length) for (a = 0; a < this.options.stripLines.length; a++) this.stripLines.push(new O(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));
                        this.options.crosshair && (this.crosshair = new da(this.chart, this.options.crosshair, this));
                        this._titleTextBlock = null;
                        this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, 
                        this.sessionVariables.viewportMinimum = null);
                        this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;
                        this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, 
                        this.sessionVariables.viewportMaximum = null);
                        this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;
                        null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
                        null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
                        this.trackChanges("viewportMinimum");
                        this.trackChanges("viewportMaximum");
                    }
                    function ea(a, e, c, b) {
                        ea.base.constructor.call(this, "ScaleBreaks", "scaleBreaks", e, null, b);
                        this.id = c;
                        this.chart = a;
                        this.ctx = this.chart.ctx;
                        this.axis = b;
                        this.optionsName = "scaleBreaks";
                        this.isOptionsInArray = !1;
                        this._appliedBreaks = [];
                        this.customBreaks = [];
                        this.autoBreaks = [];
                        "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8);
                        this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));
                        if (this.options.customBreaks && 0 < this.options.customBreaks.length) {
                            for (a = 0; a < this.options.customBreaks.length; a++) this.customBreaks.push(new ca(this.chart, "customBreaks", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), 
                            "number" === typeof this.customBreaks[a].startValue && "number" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue && this._appliedBreaks.push(this.customBreaks[a]);
                            this._appliedBreaks.sort((function(a, b) {
                                return a.startValue - b.startValue;
                            }));
                            for (a = 0; a < this._appliedBreaks.length - 1; a++) this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), 
                            window.console && window.console.log("CanvasJS Error: Breaks " + a + " and " + (a + 1) + " are overlapping."), 
                            this._appliedBreaks.splice(a, 2), a--);
                        }
                    }
                    function ca(a, e, c, b, f, h) {
                        ca.base.constructor.call(this, "Break", e, c, b, h);
                        this.id = f;
                        this.chart = a;
                        this.ctx = this.chart.ctx;
                        this.scaleBreaks = h;
                        this.optionsName = e;
                        this.isOptionsInArray = !0;
                        this.type = c.type ? this.type : h.type;
                        this.fillOpacity = p(c.fillOpacity) ? h.fillOpacity : this.fillOpacity;
                        this.lineThickness = p(c.lineThickness) ? h.lineThickness : this.lineThickness;
                        this.color = c.color ? this.color : h.color;
                        this.lineColor = c.lineColor ? this.lineColor : h.lineColor;
                        this.lineDashType = c.lineDashType ? this.lineDashType : h.lineDashType;
                        !p(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());
                        !p(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());
                        "number" === typeof this.startValue && "number" === typeof this.endValue && this.endValue < this.startValue && (a = this.startValue, 
                        this.startValue = this.endValue, this.endValue = a);
                        this.spacing = "undefined" === typeof c.spacing ? h.spacing : c.spacing;
                        "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), 
                        this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = h.spacing);
                        this.size = h.parent.logarithmic ? 1 : 0;
                    }
                    function O(a, e, c, b, f) {
                        O.base.constructor.call(this, "StripLine", "stripLines", e, c, f);
                        this.id = b;
                        this.chart = a;
                        this.ctx = this.chart.ctx;
                        this.label = this.label;
                        this.axis = f;
                        this.optionsName = "stripLines";
                        this.isOptionsInArray = !0;
                        this._thicknessType = "pixel";
                        null !== this.startValue && null !== this.endValue && (this.value = f.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, 
                        this._thicknessType = null);
                    }
                    function da(a, e, c) {
                        da.base.constructor.call(this, "Crosshair", "crosshair", e, null, c);
                        this.chart = a;
                        this.ctx = this.chart.ctx;
                        this.axis = c;
                        this.optionsName = "crosshair";
                        this._thicknessType = "pixel";
                    }
                    function V(a, e) {
                        V.base.constructor.call(this, "ToolTip", "toolTip", e, null, a);
                        this.chart = a;
                        this.canvas = a.canvas;
                        this.ctx = this.chart.ctx;
                        this.currentDataPointIndex = this.currentSeriesIndex = -1;
                        this._prevY = this._prevX = NaN;
                        this.containerTransitionDuration = .1;
                        this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);
                        this.optionsName = "toolTip";
                        this._initialize();
                    }
                    function $(a) {
                        this.chart = a;
                        this.lastObjectId = 0;
                        this.objectMap = [];
                        this.rectangularRegionEventSubscriptions = [];
                        this.previousDataPointEventObject = null;
                        this.ghostCanvas = wa(this.chart.width, this.chart.height, !0);
                        this.ghostCtx = this.ghostCanvas.getContext("2d");
                        this.mouseoveredObjectMaps = [];
                    }
                    function ja(a) {
                        this.chart = a;
                        this.ctx = this.chart.plotArea.ctx;
                        this.animations = [];
                        this.animationRequestId = null;
                    }
                    qa(l, K);
                    l.prototype.destroy = function() {
                        var a = this.allDOMEventHandlers;
                        this._animator && this._animator.cancelAllAnimations();
                        this._panTimerId && clearTimeout(this._panTimerId);
                        for (var e = 0; e < a.length; e++) {
                            var c = a[e][0], b = a[e][1], f = a[e][2], h = a[e][3];
                            h = h || !1;
                            c.removeEventListener ? c.removeEventListener(b, f, h) : c.detachEvent && c.detachEvent("on" + b, f);
                        }
                        this.allDOMEventHandlers = [];
                        for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes(); ) this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
                        for (;this.container && this.container.hasChildNodes(); ) this.container.removeChild(this.container.lastChild);
                        for (;this._dropdownMenu && this._dropdownMenu.hasChildNodes(); ) this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
                        this.container = this._canvasJSContainer = null;
                        this.toolTip.container = null;
                        this.canvas && za(this.canvas);
                        this.overlaidCanvas && za(this.overlaidCanvas);
                        this._preRenderCanvas && za(this._preRenderCanvas);
                        this._breaksCanvas && za(this._breaksCanvas);
                        this._eventManager && this._eventManager.ghostCanvas && za(this._eventManager.ghostCanvas);
                        this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = null;
                    };
                    l.prototype._updateOptions = function() {
                        var a = this;
                        this.updateOption("width");
                        this.updateOption("height");
                        this.updateOption("dataPointWidth");
                        this.updateOption("dataPointMinWidth");
                        this.updateOption("dataPointMaxWidth");
                        this.updateOption("interactivityEnabled");
                        this.updateOption("theme");
                        this.updateOption("colorSet") && (this.selectedColorSet = "undefined" !== typeof Ca[this.colorSet] ? Ca[this.colorSet] : Ca.colorSet1);
                        this.updateOption("backgroundColor");
                        this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)");
                        this.updateOption("culture");
                        this._cultureInfo = new Ka(this.options.culture);
                        this.updateOption("animationEnabled");
                        this.animationEnabled = this.animationEnabled && v;
                        this.updateOption("animationDuration");
                        this.updateOption("rangeChanging");
                        this.updateOption("rangeChanged");
                        this.updateOption("exportEnabled");
                        this.updateOption("exportFileName");
                        this.updateOption("zoomType");
                        this.toolbar = new Va(this, this.options.toolbar);
                        if (this.options.zoomEnabled || this.panEnabled) {
                            if (this._zoomButton) X(this._zoomButton, {
                                borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor,
                                backgroundColor: a.toolbar.itemBackgroundColor,
                                color: a.toolbar.fontColor
                            }), ua(this, this._zoomButton, "zoom"); else {
                                var e = !1;
                                ya(this._zoomButton = document.createElement("button"));
                                ua(this, this._zoomButton, "pan");
                                this._toolBar.appendChild(this._zoomButton);
                                this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor;
                                S(this._zoomButton, "touchstart", (function(a) {
                                    e = !0;
                                }), this.allDOMEventHandlers);
                                S(this._zoomButton, "click", (function() {
                                    a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, ua(a, a._zoomButton, "zoom")) : (a.zoomEnabled = !0, 
                                    a.panEnabled = !1, ua(a, a._zoomButton, "pan"));
                                    a.render();
                                }), this.allDOMEventHandlers);
                                S(this._zoomButton, "mousemove", (function() {
                                    e ? e = !1 : (X(a._zoomButton, {
                                        backgroundColor: a.toolbar.itemBackgroundColorOnHover,
                                        color: a.toolbar.fontColorOnHover,
                                        transition: "0.4s",
                                        WebkitTransition: "0.4s"
                                    }), 0 >= navigator.userAgent.search("MSIE") && X(a._zoomButton.childNodes[0], {
                                        WebkitFilter: "invert(100%)",
                                        filter: "invert(100%)"
                                    }));
                                }), this.allDOMEventHandlers);
                                S(this._zoomButton, "mouseout", (function() {
                                    e || (X(a._zoomButton, {
                                        backgroundColor: a.toolbar.itemBackgroundColor,
                                        color: a.toolbar.fontColor,
                                        transition: "0.4s",
                                        WebkitTransition: "0.4s"
                                    }), 0 >= navigator.userAgent.search("MSIE") && X(a._zoomButton.childNodes[0], {
                                        WebkitFilter: "invert(0%)",
                                        filter: "invert(0%)"
                                    }));
                                }), this.allDOMEventHandlers);
                            }
                            this._resetButton ? (X(this._resetButton, {
                                borderRight: this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor,
                                backgroundColor: a.toolbar.itemBackgroundColor,
                                color: a.toolbar.fontColor
                            }), this._resetButton.title = this._cultureInfo.resetText) : (e = !1, ya(this._resetButton = document.createElement("button")), 
                            ua(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor, 
                            this._toolBar.appendChild(this._resetButton), S(this._resetButton, "touchstart", (function(a) {
                                e = !0;
                            }), this.allDOMEventHandlers), S(this._resetButton, "click", (function() {
                                a.toolTip.hide();
                                a.toolTip && a.toolTip.enabled && a.toolTip.dispatchEvent("hidden", {
                                    chart: a,
                                    toolTip: a.toolTip
                                }, a.toolTip);
                                a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, ua(a, a._zoomButton, "pan"), 
                                a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, 
                                a.panEnabled = !1);
                                if (a.sessionVariables.axisX) for (var b = 0; b < a.sessionVariables.axisX.length; b++) a.sessionVariables.axisX[b].newViewportMinimum = null, 
                                a.sessionVariables.axisX[b].newViewportMaximum = null;
                                if (a.sessionVariables.axisX2) for (b = 0; b < a.sessionVariables.axisX2.length; b++) a.sessionVariables.axisX2[b].newViewportMinimum = null, 
                                a.sessionVariables.axisX2[b].newViewportMaximum = null;
                                if (a.sessionVariables.axisY) for (b = 0; b < a.sessionVariables.axisY.length; b++) a.sessionVariables.axisY[b].newViewportMinimum = null, 
                                a.sessionVariables.axisY[b].newViewportMaximum = null;
                                if (a.sessionVariables.axisY2) for (b = 0; b < a.sessionVariables.axisY2.length; b++) a.sessionVariables.axisY2[b].newViewportMinimum = null, 
                                a.sessionVariables.axisY2[b].newViewportMaximum = null;
                                a.resetOverlayedCanvas();
                                0 >= navigator.userAgent.search("MSIE") && X(a._resetButton.childNodes[0], {
                                    WebkitFilter: "invert(0%)",
                                    filter: "invert(0%)"
                                });
                                ya(a._zoomButton, a._resetButton);
                                a.stockChart && (a.stockChart._rangeEventParameter = {
                                    stockChart: a.stockChart,
                                    source: "chart",
                                    index: a.stockChart.charts.indexOf(a),
                                    minimum: null,
                                    maximum: null
                                });
                                a._dispatchRangeEvent("rangeChanging", "reset");
                                a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanging", a.stockChart.dispatchEvent("rangeChanging", a.stockChart._rangeEventParameter, a.stockChart));
                                a.render();
                                a.syncCharts && a.syncCharts(null, null);
                                a._dispatchRangeEvent("rangeChanged", "reset");
                                a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanged", a.stockChart.dispatchEvent("rangeChanged", a.stockChart._rangeEventParameter, a.stockChart));
                            }), this.allDOMEventHandlers), S(this._resetButton, "mousemove", (function() {
                                e || (X(a._resetButton, {
                                    backgroundColor: a.toolbar.itemBackgroundColorOnHover,
                                    color: a.toolbar.fontColorOnHover,
                                    transition: "0.4s",
                                    WebkitTransition: "0.4s"
                                }), 0 >= navigator.userAgent.search("MSIE") && X(a._resetButton.childNodes[0], {
                                    WebkitFilter: "invert(100%)",
                                    filter: "invert(100%)"
                                }));
                            }), this.allDOMEventHandlers), S(this._resetButton, "mouseout", (function() {
                                e || (X(a._resetButton, {
                                    backgroundColor: a.toolbar.itemBackgroundColor,
                                    color: a.toolbar.fontColor,
                                    transition: "0.4s",
                                    WebkitTransition: "0.4s"
                                }), 0 >= navigator.userAgent.search("MSIE") && X(a._resetButton.childNodes[0], {
                                    WebkitFilter: "invert(0%)",
                                    filter: "invert(0%)"
                                }));
                            }), this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor);
                            this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = !0, 
                            this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), Ma(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, 
                            this.panEnabled = !1));
                        } else this.panEnabled = this.zoomEnabled = !1;
                        hb(this);
                        "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? ua(a, a._zoomButton, "zoom") : ua(a, a._zoomButton, "pan"), 
                        a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && ua(a, a._resetButton, "reset"));
                        this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);
                        for (var c in this.toolTip.options) this.toolTip.options.hasOwnProperty(c) && this.toolTip.updateOption(c);
                    };
                    l.prototype._updateSize = function() {
                        var a;
                        a = [ this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas ];
                        var e = 0, c = 0;
                        this.options.width ? e = this.width : this.width = e = 0 < this.container.clientWidth ? this.container.clientWidth : this.width;
                        this.options.height ? c = this.height : this.height = c = 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
                        if (this.canvas.width !== e * ma || this.canvas.height !== c * ma) {
                            for (var b = 0; b < a.length; b++) Na(a[b], e, c);
                            this.bounds = {
                                x1: 0,
                                y1: 0,
                                x2: this.width,
                                y2: this.height,
                                width: this.width,
                                height: this.height
                            };
                            a = !0;
                        } else a = !1;
                        return a;
                    };
                    l.prototype._initialize = function() {
                        this.isNavigator = p(this.parent) || p(this.parent._defaultsKey) || "Navigator" !== this.parent._defaultsKey ? !1 : !0;
                        this._animator ? this._animator.cancelAllAnimations() : this._animator = new ja(this);
                        this.removeAllEventListeners();
                        this.disableToolTip = !1;
                        this._axes = [];
                        this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;
                        this._updateOptions();
                        this.animatedRender = v && this.animationEnabled && 0 === this.renderCount;
                        this._updateSize();
                        this.clearCanvas();
                        this.ctx.beginPath();
                        this.axisX = [];
                        this.axisX2 = [];
                        this.axisY = [];
                        this.axisY2 = [];
                        this._indexLabels = [];
                        this._dataInRenderedOrder = [];
                        this._events = [];
                        this._eventManager && this._eventManager.reset();
                        this.plotInfo = {
                            axisPlacement: null,
                            plotTypes: []
                        };
                        this.layoutManager = new Fa(0, 0, this.width, this.height, this.isNavigator ? 0 : 2);
                        this.plotArea.layoutManager && this.plotArea.layoutManager.reset();
                        this.data = [];
                        this.title = null;
                        this.subtitles = [];
                        var a = 0, e = null;
                        if (this.options.data) {
                            for (var c = 0; c < this.options.data.length; c++) if (a++, !this.options.data[c].type || 0 <= l._supportedChartTypes.indexOf(this.options.data[c].type)) {
                                var b = new Q(this, this.options.data[c], a - 1, ++this._eventManager.lastObjectId);
                                if (!p(b) && b.dataPoints) for (var f = 0; f < b.dataPoints.length; f++) if (b.dataPoints[f].x && b.dataPoints[f].x.getTime) {
                                    b.xValueType = "dateTime";
                                    break;
                                }
                                "error" === b.type && (b.linkedDataSeriesIndex = p(this.options.data[c].linkedDataSeriesIndex) ? c - 1 : this.options.data[c].linkedDataSeriesIndex, 
                                0 > b.linkedDataSeriesIndex || b.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof b.linkedDataSeriesIndex || "error" === this.options.data[b.linkedDataSeriesIndex].type) && (b.linkedDataSeriesIndex = null);
                                null === b.name && (b.name = "DataSeries " + a);
                                null === b.color ? 1 < this.options.data.length ? (b._colorSet = [ this.selectedColorSet[b.index % this.selectedColorSet.length] ], 
                                b.color = this.selectedColorSet[b.index % this.selectedColorSet.length]) : b._colorSet = "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "candlestick" === b.type || "ohlc" === b.type || "waterfall" === b.type || "boxAndWhisker" === b.type ? [ this.selectedColorSet[0] ] : this.selectedColorSet : b._colorSet = [ b.color ];
                                null === b.markerSize && (("line" === b.type || "stepLine" === b.type || "spline" === b.type || 0 <= b.type.toLowerCase().indexOf("area")) && b.dataPoints && b.dataPoints.length < this.width / 16 || "scatter" === b.type) && (b.markerSize = 8);
                                "bubble" !== b.type && "scatter" !== b.type || !b.dataPoints || (b.dataPoints.some ? b.dataPoints.some((function(a) {
                                    return a.x;
                                })) && b.dataPoints.sort(d) : b.dataPoints.sort(d));
                                this.data.push(b);
                                var h;
                                f = b.axisPlacement, e = e || f;
                                "normal" === f ? "xySwapped" === this.plotInfo.axisPlacement ? h = 'You cannot combine "' + b.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? h = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === f ? "normal" === this.plotInfo.axisPlacement ? h = 'You cannot combine "' + b.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? h = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === f ? "normal" === this.plotInfo.axisPlacement ? h = 'You cannot combine "' + b.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? h = 'You cannot combine "' + b.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === f && "none" === this.plotInfo.axisPlacement && (h = 'You cannot combine "' + b.type + '" with pie chart');
                                if (h && window.console) {
                                    window.console.log(h);
                                    return;
                                }
                            }
                            for (c = 0; c < this.data.length; c++) {
                                if ("none" == e && "error" === this.data[c].type && window.console) {
                                    window.console.log('You cannot combine "' + b.type + '" with error chart');
                                    return;
                                }
                                "error" === this.data[c].type && (this.data[c].axisPlacement = this.plotInfo.axisPlacement = e || "normal", 
                                this.data[c]._linkedSeries = null === this.data[c].linkedDataSeriesIndex ? null : this.data[this.data[c].linkedDataSeriesIndex]);
                            }
                        }
                        this._objectsInitialized = !0;
                        this._plotAreaElements = [];
                    };
                    l._supportedChartTypes = Ea("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));
                    l.prototype.setLayout = function() {
                        for (var a = this._plotAreaElements, e = 0; e < this.data.length; e++) if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
                            if (!this.data[e].axisYType || "primary" === this.data[e].axisYType) if (this.options.axisY && 0 < this.options.axisY.length) {
                                if (!this.axisY.length) for (var c = 0; c < this.options.axisY.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[c] = new D(this, "axisY", this.options.axisY[c], c, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[c] = new D(this, "axisY", this.options.axisY[c], c, "axisY", "bottom"));
                                this.data[e].axisY = this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0];
                                this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]);
                            } else this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new D(this, "axisY", this.options.axisY, 0, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new D(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), 
                            this.data[e].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[e]);
                            if ("secondary" === this.data[e].axisYType) if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                                if (!this.axisY2.length) for (c = 0; c < this.options.axisY2.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[c] = new D(this, "axisY2", this.options.axisY2[c], c, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[c] = new D(this, "axisY2", this.options.axisY2[c], c, "axisY", "top"));
                                this.data[e].axisY = this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0];
                                this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e]);
                            } else this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new D(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new D(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), 
                            this.data[e].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[e]);
                            if (!this.data[e].axisXType || "primary" === this.data[e].axisXType) if (this.options.axisX && 0 < this.options.axisX.length) {
                                if (!this.axisX.length) for (c = 0; c < this.options.axisX.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[c] = new D(this, "axisX", this.options.axisX[c], c, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[c] = new D(this, "axisX", this.options.axisX[c], c, "axisX", "left"));
                                this.data[e].axisX = this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0];
                                this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]);
                            } else this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new D(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new D(this, "axisX", this.options.axisX, 0, "axisX", "left"))), 
                            this.data[e].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[e]);
                            if ("secondary" === this.data[e].axisXType) if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                                if (!this.axisX2.length) for (c = 0; c < this.options.axisX2.length; c++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[c] = new D(this, "axisX2", this.options.axisX2[c], c, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[c] = new D(this, "axisX2", this.options.axisX2[c], c, "axisX", "right"));
                                this.data[e].axisX = this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0];
                                this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e]);
                            } else this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new D(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new D(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), 
                            this.data[e].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[e]);
                        }
                        if (this.axisY) {
                            for (c = 1; c < this.axisY.length; c++) "undefined" === typeof this.axisY[c].options.gridThickness && (this.axisY[c].gridThickness = 0);
                            for (c = 0; c < this.axisY.length - 1; c++) "undefined" === typeof this.axisY[c].options.margin && (this.axisY[c].margin = 10);
                        }
                        if (this.axisY2) {
                            for (c = 1; c < this.axisY2.length; c++) "undefined" === typeof this.axisY2[c].options.gridThickness && (this.axisY2[c].gridThickness = 0);
                            for (c = 0; c < this.axisY2.length - 1; c++) "undefined" === typeof this.axisY2[c].options.margin && (this.axisY2[c].margin = 10);
                        }
                        this.axisY && 0 < this.axisY.length && this.axisY2 && 0 < this.axisY2.length && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));
                        if (this.axisX) for (c = 0; c < this.axisX.length; c++) "undefined" === typeof this.axisX[c].options.gridThickness && (this.axisX[c].gridThickness = 0);
                        if (this.axisX2) for (c = 0; c < this.axisX2.length; c++) "undefined" === typeof this.axisX2[c].options.gridThickness && (this.axisX2[c].gridThickness = 0);
                        this.axisX && 0 < this.axisX.length && this.axisX2 && 0 < this.axisX2.length && (0 < this.axisX[0].gridThickness && "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));
                        c = !1;
                        if (0 < this._axes.length && this.options.zoomEnabled && (this.zoomEnabled || this.panEnabled)) for (e = 0; e < this._axes.length; e++) if (!p(this._axes[e].viewportMinimum) || !p(this._axes[e].viewportMaximum)) {
                            c = !0;
                            break;
                        }
                        c ? (Ma(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, 
                        this._zoomButton.style.borderRight = this.toolbar.buttonBorderThickness + "px solid " + this.toolbar.buttonBorderColor, 
                        this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.buttonBorderThickness : 0) + "px solid " + this.toolbar.buttonBorderColor) : (ya(this._zoomButton, this._resetButton), 
                        this._toolBar.style.border = this.toolbar.buttonBorderThickness + "px solid transparent", 
                        this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1));
                        fb(this);
                        this._processData();
                        this.options.title && (this.title = new Ba(this, this.options.title), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout());
                        if (this.options.subtitles) for (e = 0; e < this.options.subtitles.length; e++) c = new Ja(this, this.options.subtitles[e], e), 
                        this.subtitles.push(c), c.dockInsidePlotArea ? a.push(c) : c.setLayout();
                        this.legend = new I(this, this.options.legend);
                        for (e = 0; e < this.data.length; e++) (this.data[e].showInLegend || "pie" === this.data[e].type || "doughnut" === this.data[e].type || "funnel" === this.data[e].type || "pyramid" === this.data[e].type) && this.legend.dataSeries.push(this.data[e]);
                        this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout();
                        for (e = 0; e < this._axes.length; e++) if (this._axes[e].scaleBreaks && this._axes[e].scaleBreaks._appliedBreaks.length) {
                            v ? (this._breaksCanvas = wa(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, 
                            this._breaksCanvasCtx = this.ctx);
                            break;
                        }
                        this._preRenderCanvas = wa(this.width, this.height);
                        this._preRenderCtx = this._preRenderCanvas.getContext("2d");
                        "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || D.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
                    };
                    l.prototype.renderElements = function() {
                        if (this.height) {
                            var a = this._plotAreaElements;
                            this.title && !this.title.dockInsidePlotArea && this.title.render();
                            for (var e = 0; e < this.subtitles.length; e++) this.subtitles[e].dockInsidePlotArea || this.subtitles[e].render();
                            this.legend.dockInsidePlotArea || this.legend.render();
                            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) D.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement); else if ("none" === this.plotInfo.axisPlacement) this.preparePlotArea(); else return;
                            for (e = 0; e < a.length; e++) a[e].setLayout(), a[e].render();
                            var c = [];
                            if (this.animatedRender) {
                                var b = wa(this.width, this.height);
                                b.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height);
                            }
                            ib(this);
                            var f;
                            a = this.ctx.miterLimit;
                            this.ctx.miterLimit = 3;
                            v && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), 
                            this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            this._preRenderCtx.clearRect(0, 0, this.width, this.height));
                            for (e = 0; e < this.plotInfo.plotTypes.length; e++) for (var h = this.plotInfo.plotTypes[e], r = 0; r < h.plotUnits.length; r++) {
                                var x = h.plotUnits[r], J = null;
                                x.targetCanvas && za(x.targetCanvas);
                                x.targetCanvas = null;
                                this.animatedRender && (x.targetCanvas = wa(this.width, this.height), x.targetCanvasCtx = x.targetCanvas.getContext("2d"), 
                                f = x.targetCanvasCtx.miterLimit, x.targetCanvasCtx.miterLimit = 3);
                                "line" === x.type ? J = this.renderLine(x) : "stepLine" === x.type ? J = this.renderStepLine(x) : "spline" === x.type ? J = this.renderSpline(x) : "column" === x.type ? J = this.renderColumn(x) : "bar" === x.type ? J = this.renderBar(x) : "area" === x.type ? J = this.renderArea(x) : "stepArea" === x.type ? J = this.renderStepArea(x) : "splineArea" === x.type ? J = this.renderSplineArea(x) : "stackedColumn" === x.type ? J = this.renderStackedColumn(x) : "stackedColumn100" === x.type ? J = this.renderStackedColumn100(x) : "stackedBar" === x.type ? J = this.renderStackedBar(x) : "stackedBar100" === x.type ? J = this.renderStackedBar100(x) : "stackedArea" === x.type ? J = this.renderStackedArea(x) : "stackedArea100" === x.type ? J = this.renderStackedArea100(x) : "bubble" === x.type ? J = J = this.renderBubble(x) : "scatter" === x.type ? J = this.renderScatter(x) : "pie" === x.type ? this.renderPie(x) : "doughnut" === x.type ? this.renderPie(x) : "funnel" === x.type ? J = this.renderFunnel(x) : "pyramid" === x.type ? J = this.renderFunnel(x) : "candlestick" === x.type ? J = this.renderCandlestick(x) : "ohlc" === x.type ? J = this.renderCandlestick(x) : "rangeColumn" === x.type ? J = this.renderRangeColumn(x) : "error" === x.type ? J = this.renderError(x) : "rangeBar" === x.type ? J = this.renderRangeBar(x) : "rangeArea" === x.type ? J = this.renderRangeArea(x) : "rangeSplineArea" === x.type ? J = this.renderRangeSplineArea(x) : "waterfall" === x.type ? J = this.renderWaterfall(x) : "boxAndWhisker" === x.type && (J = this.renderBoxAndWhisker(x));
                                for (var k = 0; k < x.dataSeriesIndexes.length; k++) this._dataInRenderedOrder.push(this.data[x.dataSeriesIndexes[k]]);
                                this.animatedRender && (x.targetCanvasCtx.miterLimit = f, J && c.push(J));
                            }
                            this.ctx.miterLimit = a;
                            this.animatedRender && this._breaksCanvasCtx && c.push({
                                source: this._breaksCanvasCtx,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0,
                                startTimePercent: .7
                            });
                            this.animatedRender && 0 < this._indexLabels.length && (f = wa(this.width, this.height).getContext("2d"), 
                            Aa(f), c.push(this.renderIndexLabels(f)));
                            var m = this;
                            if (0 < c.length) m.disableToolTip = !0, m._animator.animate(200, m.animationDuration, (function(a) {
                                m.ctx.clearRect(0, 0, m.width, m.height);
                                m.ctx.drawImage(b, 0, 0, Math.floor(m.width * ma), Math.floor(m.height * ma), 0, 0, m.width, m.height);
                                for (var f = 0; f < c.length; f++) J = c[f], 1 > a && "undefined" !== typeof J.startTimePercent ? a >= J.startTimePercent && J.animationCallback(J.easingFunction(a - J.startTimePercent, 0, 1, 1 - J.startTimePercent), J) : J.animationCallback(J.easingFunction(a, 0, 1, 1), J);
                                m.dispatchEvent("dataAnimationIterationEnd", {
                                    chart: m
                                });
                            }), (function() {
                                c = [];
                                for (var a = 0; a < m.plotInfo.plotTypes.length; a++) for (var f = m.plotInfo.plotTypes[a], g = 0; g < f.plotUnits.length; g++) {
                                    var e = f.plotUnits[g];
                                    e.targetCanvas && za(e.targetCanvas);
                                    e.targetCanvas = null;
                                }
                                b = null;
                                m.disableToolTip = !1;
                                m.dispatchEvent("dataAnimationEnd", {
                                    chart: m
                                });
                            })); else {
                                if (m._breaksCanvas) if (v) m.plotArea.ctx.drawImage(m._breaksCanvas, 0, 0, this.width, this.height); else for (k = 0; k < m._axes.length; k++) m._axes[k].createMask();
                                0 < m._indexLabels.length && m.renderIndexLabels();
                                m.dispatchEvent("dataAnimationIterationEnd", {
                                    chart: m
                                });
                                m.dispatchEvent("dataAnimationEnd", {
                                    chart: m
                                });
                            }
                            this.attachPlotAreaEventHandlers();
                            this.zoomEnabled || this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display || ya(this._zoomButton, this._resetButton);
                            this.toolTip._updateToolTip();
                            this.renderCount++;
                            Ia && (m = this, setTimeout((function() {
                                var a = document.getElementById("ghostCanvasCopy");
                                a && (Na(a, m.width, m.height), a.getContext("2d").drawImage(m._eventManager.ghostCanvas, 0, 0));
                            }), 2e3));
                            this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);
                            for (k = 0; k < this._axes.length; k++) this._axes[k].maskCanvas && (delete this._axes[k].maskCanvas, 
                            delete this._axes[k].maskCtx);
                        }
                    };
                    l.prototype.render = function(a) {
                        a && (this.options = a);
                        this._initialize();
                        this.setLayout();
                        this.renderElements();
                        this._preRenderCanvas && za(this._preRenderCanvas);
                    };
                    l.prototype.attachPlotAreaEventHandlers = function() {
                        this.attachEvent({
                            context: this,
                            chart: this,
                            mousedown: this._plotAreaMouseDown,
                            mouseup: this._plotAreaMouseUp,
                            mousemove: this._plotAreaMouseMove,
                            cursor: this.panEnabled ? "move" : "default",
                            capture: !0,
                            bounds: this.plotArea
                        });
                    };
                    l.prototype.categoriseDataSeries = function() {
                        for (var a = "", e = 0; e < this.data.length; e++) if (a = this.data[e], a.dataPoints && 0 !== a.dataPoints.length && a.visible && 0 <= l._supportedChartTypes.indexOf(a.type)) {
                            for (var c = null, b = !1, f = null, h = !1, r = 0; r < this.plotInfo.plotTypes.length; r++) if (this.plotInfo.plotTypes[r].type === a.type) {
                                b = !0;
                                c = this.plotInfo.plotTypes[r];
                                break;
                            }
                            b || (c = {
                                type: a.type,
                                totalDataSeries: 0,
                                plotUnits: []
                            }, this.plotInfo.plotTypes.push(c));
                            for (r = 0; r < c.plotUnits.length; r++) if (c.plotUnits[r].axisYType === a.axisYType && c.plotUnits[r].axisXType === a.axisXType && c.plotUnits[r].axisYIndex === a.axisYIndex && c.plotUnits[r].axisXIndex === a.axisXIndex) {
                                h = !0;
                                f = c.plotUnits[r];
                                break;
                            }
                            h || (f = {
                                type: a.type,
                                previousDataSeriesCount: 0,
                                index: c.plotUnits.length,
                                plotType: c,
                                axisXType: a.axisXType,
                                axisYType: a.axisYType,
                                axisYIndex: a.axisYIndex,
                                axisXIndex: a.axisXIndex,
                                axisY: "primary" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0],
                                axisX: "primary" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0],
                                dataSeriesIndexes: [],
                                yTotals: [],
                                yAbsTotals: []
                            }, c.plotUnits.push(f));
                            c.totalDataSeries++;
                            f.dataSeriesIndexes.push(e);
                            a.plotUnit = f;
                        }
                        for (e = 0; e < this.plotInfo.plotTypes.length; e++) for (c = this.plotInfo.plotTypes[e], 
                        r = a = 0; r < c.plotUnits.length; r++) c.plotUnits[r].previousDataSeriesCount = a, 
                        a += c.plotUnits[r].dataSeriesIndexes.length;
                    };
                    l.prototype.assignIdToDataPoints = function() {
                        for (var a = 0; a < this.data.length; a++) {
                            var e = this.data[a];
                            if (e.dataPoints) for (var c = e.dataPoints.length, b = 0; b < c; b++) e.dataPointIds[b] = ++this._eventManager.lastObjectId;
                        }
                    };
                    l.prototype._processData = function() {
                        this.assignIdToDataPoints();
                        this.categoriseDataSeries();
                        for (var a = 0; a < this.plotInfo.plotTypes.length; a++) for (var e = this.plotInfo.plotTypes[a], c = 0; c < e.plotUnits.length; c++) {
                            var b = e.plotUnits[c];
                            "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type ? this._processMultiseriesPlotUnit(b) : "stackedColumn" === b.type || "stackedBar" === b.type || "stackedArea" === b.type ? this._processStackedPlotUnit(b) : "stackedColumn100" === b.type || "stackedBar100" === b.type || "stackedArea100" === b.type ? this._processStacked100PlotUnit(b) : "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? this._processMultiYPlotUnit(b) : "waterfall" === b.type && this._processSpecificPlotUnit(b);
                        }
                        this.calculateAutoBreaks();
                    };
                    l.prototype._processMultiseriesPlotUnit = function(a) {
                        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var b, f, e = a.axisY.dataInfo, c = a.axisX.dataInfo, h = !1, r = 0; r < a.dataSeriesIndexes.length; r++) {
                            var q, x = this.data[a.dataSeriesIndexes[r]], J = 0, k = !1, m = !1;
                            if ("normal" === x.axisPlacement || "xySwapped" === x.axisPlacement) var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -1 / 0, g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : 1 / 0;
                            if (x.dataPoints[J].x && x.dataPoints[J].x.getTime || "dateTime" === x.xValueType) h = !0;
                            for (J = 0; J < x.dataPoints.length; J++) {
                                "undefined" === typeof x.dataPoints[J].x && (x.dataPoints[J].x = J + (a.axisX.logarithmic ? 1 : 0));
                                x.dataPoints[J].x.getTime ? (h = !0, b = x.dataPoints[J].x.getTime()) : b = x.dataPoints[J].x;
                                f = x.dataPoints[J].y;
                                b < c.min && (c.min = b);
                                b > c.max && (c.max = b);
                                f < e.min && "number" === typeof f && (e.min = f);
                                f > e.max && "number" === typeof f && (e.max = f);
                                if (0 < J) {
                                    if (a.axisX.logarithmic) {
                                        var d = b / x.dataPoints[J - 1].x;
                                        1 > d && (d = 1 / d);
                                        c.minDiff > d && 1 !== d && (c.minDiff = d);
                                    } else d = b - x.dataPoints[J - 1].x, 0 > d && (d *= -1), c.minDiff > d && 0 !== d && (c.minDiff = d);
                                    null !== f && null !== x.dataPoints[J - 1].y && (a.axisY.logarithmic ? (d = f / x.dataPoints[J - 1].y, 
                                    1 > d && (d = 1 / d), e.minDiff > d && 1 !== d && (e.minDiff = d)) : (d = f - x.dataPoints[J - 1].y, 
                                    0 > d && (d *= -1), e.minDiff > d && 0 !== d && (e.minDiff = d)));
                                }
                                if (b < n && !k) null !== f && (q = b); else {
                                    if (!k && (k = !0, 0 < J)) {
                                        J -= 2;
                                        continue;
                                    }
                                    if (b > g && !m) m = !0; else if (b > g && m) continue;
                                    x.dataPoints[J].label && (a.axisX.labels[b] = x.dataPoints[J].label);
                                    b < c.viewPortMin && (c.viewPortMin = b);
                                    b > c.viewPortMax && (c.viewPortMax = b);
                                    null === f ? c.viewPortMin === b && q < b && (c.viewPortMin = q) : (f < e.viewPortMin && "number" === typeof f && (e.viewPortMin = f), 
                                    f > e.viewPortMax && "number" === typeof f && (e.viewPortMax = f));
                                }
                            }
                            x.axisX.valueType = x.xValueType = h ? "dateTime" : "number";
                        }
                    };
                    l.prototype._processStackedPlotUnit = function(a) {
                        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
                            for (var b, f, e = a.axisY.dataInfo, c = a.axisX.dataInfo, h = !1, r = [], x = [], J = 1 / 0, k = -1 / 0, m = {}, q = 0; q < a.dataSeriesIndexes.length; q++) {
                                var y, n = this.data[a.dataSeriesIndexes[q]], g = 0, d = !1, w = !1;
                                if ("normal" === n.axisPlacement || "xySwapped" === n.axisPlacement) var s = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -1 / 0, z = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : 1 / 0;
                                if (n.dataPoints[g].x && n.dataPoints[g].x.getTime || "dateTime" === n.xValueType) h = !0;
                                for (g = 0; g < n.dataPoints.length; g++) {
                                    "undefined" === typeof n.dataPoints[g].x && (n.dataPoints[g].x = g + (a.axisX.logarithmic ? 1 : 0));
                                    n.dataPoints[g].x.getTime ? (h = !0, b = n.dataPoints[g].x.getTime()) : b = n.dataPoints[g].x;
                                    f = p(n.dataPoints[g].y) ? 0 : n.dataPoints[g].y;
                                    b < c.min && (c.min = b);
                                    b > c.max && (c.max = b);
                                    if (0 < g) {
                                        if (a.axisX.logarithmic) {
                                            var u = b / n.dataPoints[g - 1].x;
                                            1 > u && (u = 1 / u);
                                            c.minDiff > u && 1 !== u && (c.minDiff = u);
                                        } else u = b - n.dataPoints[g - 1].x, 0 > u && (u *= -1), c.minDiff > u && 0 !== u && (c.minDiff = u);
                                        null !== f && null !== n.dataPoints[g - 1].y && (a.axisY.logarithmic ? 0 < f && (u = f / n.dataPoints[g - 1].y, 
                                        1 > u && (u = 1 / u), e.minDiff > u && 1 !== u && (e.minDiff = u)) : (u = f - n.dataPoints[g - 1].y, 
                                        0 > u && (u *= -1), e.minDiff > u && 0 !== u && (e.minDiff = u)));
                                    }
                                    if (b < s && !d) null !== n.dataPoints[g].y && (y = b); else {
                                        if (!d && (d = !0, 0 < g)) {
                                            g -= 2;
                                            continue;
                                        }
                                        if (b > z && !w) w = !0; else if (b > z && w) continue;
                                        n.dataPoints[g].label && (a.axisX.labels[b] = n.dataPoints[g].label);
                                        b < c.viewPortMin && (c.viewPortMin = b);
                                        b > c.viewPortMax && (c.viewPortMax = b);
                                        null === n.dataPoints[g].y ? c.viewPortMin === b && y < b && (c.viewPortMin = y) : (m[b] = (m[b] || 0) + n.dataPoints[g].y, 
                                        n.dataPointEOs[g].cumulativeY = m[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + f, 
                                        a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(f), 0 <= f ? r[b] ? r[b] += f : (r[b] = f, 
                                        J = Math.min(f, J)) : x[b] ? x[b] += f : (x[b] = f, k = Math.max(f, k)));
                                    }
                                }
                                a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks && (e.dataPointYPositiveSums ? (e.dataPointYPositiveSums.push.apply(e.dataPointYPositiveSums, r), 
                                e.dataPointYNegativeSums.push.apply(e.dataPointYPositiveSums, x)) : (e.dataPointYPositiveSums = r, 
                                e.dataPointYNegativeSums = x));
                                n.axisX.valueType = n.xValueType = h ? "dateTime" : "number";
                            }
                            for (g in r) r.hasOwnProperty(g) && !isNaN(g) && (a = r[g], a < e.min && (e.min = Math.min(a, J)), 
                            a > e.max && (e.max = a), g < c.viewPortMin || g > c.viewPortMax || (a < e.viewPortMin && (e.viewPortMin = Math.min(a, J)), 
                            a > e.viewPortMax && (e.viewPortMax = a)));
                            for (g in x) x.hasOwnProperty(g) && !isNaN(g) && (a = x[g], a < e.min && (e.min = a), 
                            a > e.max && (e.max = Math.max(a, k)), g < c.viewPortMin || g > c.viewPortMax || (a < e.viewPortMin && (e.viewPortMin = a), 
                            a > e.viewPortMax && (e.viewPortMax = Math.max(a, k))));
                        }
                    };
                    l.prototype._processStacked100PlotUnit = function(a) {
                        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
                            for (var b, f, e = a.axisY.dataInfo, c = a.axisX.dataInfo, h = !1, r = !1, x = !1, J = {}, k = [], m = 0; m < a.dataSeriesIndexes.length; m++) {
                                var w, q = this.data[a.dataSeriesIndexes[m]], n = 0, g = !1, d = !1;
                                if ("normal" === q.axisPlacement || "xySwapped" === q.axisPlacement) var y = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : -1 / 0, s = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : 1 / 0;
                                if (q.dataPoints[n].x && q.dataPoints[n].x.getTime || "dateTime" === q.xValueType) h = !0;
                                for (n = 0; n < q.dataPoints.length; n++) {
                                    "undefined" === typeof q.dataPoints[n].x && (q.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0));
                                    q.dataPoints[n].x.getTime ? (h = !0, b = q.dataPoints[n].x.getTime()) : b = q.dataPoints[n].x;
                                    f = p(q.dataPoints[n].y) ? null : q.dataPoints[n].y;
                                    b < c.min && (c.min = b);
                                    b > c.max && (c.max = b);
                                    if (0 < n) {
                                        if (a.axisX.logarithmic) {
                                            var z = b / q.dataPoints[n - 1].x;
                                            1 > z && (z = 1 / z);
                                            c.minDiff > z && 1 !== z && (c.minDiff = z);
                                        } else z = b - q.dataPoints[n - 1].x, 0 > z && (z *= -1), c.minDiff > z && 0 !== z && (c.minDiff = z);
                                        p(f) || null === q.dataPoints[n - 1].y || (a.axisY.logarithmic ? 0 < f && (z = f / q.dataPoints[n - 1].y, 
                                        1 > z && (z = 1 / z), e.minDiff > z && 1 !== z && (e.minDiff = z)) : (z = f - q.dataPoints[n - 1].y, 
                                        0 > z && (z *= -1), e.minDiff > z && 0 !== z && (e.minDiff = z)));
                                    }
                                    if (b < y && !g) null !== f && (w = b); else {
                                        if (!g && (g = !0, 0 < n)) {
                                            n -= 2;
                                            continue;
                                        }
                                        if (b > s && !d) d = !0; else if (b > s && d) continue;
                                        q.dataPoints[n].label && (a.axisX.labels[b] = q.dataPoints[n].label);
                                        b < c.viewPortMin && (c.viewPortMin = b);
                                        b > c.viewPortMax && (c.viewPortMax = b);
                                        null === f ? c.viewPortMin === b && w < b && (c.viewPortMin = w) : (J[b] = (J[b] || 0) + q.dataPoints[n].y, 
                                        q.dataPointEOs[n].cumulativeY = J[b], a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + f, 
                                        a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(f), 0 <= f ? r = !0 : 0 > f && (x = !0), 
                                        k[b] = k[b] ? k[b] + Math.abs(f) : Math.abs(f));
                                    }
                                }
                                q.axisX.valueType = q.xValueType = h ? "dateTime" : "number";
                            }
                            a.axisY.logarithmic ? (e.max = p(e.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -.05) : Math.max(e.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -.05)), 
                            e.min = p(e.viewPortMin) ? 1 : Math.min(e.viewPortMin, 1)) : r && !x ? (e.max = p(e.viewPortMax) ? 99 : Math.max(e.viewPortMax, 99), 
                            e.min = p(e.viewPortMin) ? 1 : Math.min(e.viewPortMin, 1)) : r && x ? (e.max = p(e.viewPortMax) ? 99 : Math.max(e.viewPortMax, 99), 
                            e.min = p(e.viewPortMin) ? -99 : Math.min(e.viewPortMin, -99)) : !r && x && (e.max = p(e.viewPortMax) ? -1 : Math.max(e.viewPortMax, -1), 
                            e.min = p(e.viewPortMin) ? -99 : Math.min(e.viewPortMin, -99));
                            e.viewPortMin = e.min;
                            e.viewPortMax = e.max;
                            a.dataPointYSums = k;
                        }
                    };
                    l.prototype._processMultiYPlotUnit = function(a) {
                        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var b, f, h, r, e = a.axisY.dataInfo, c = a.axisX.dataInfo, x = !1, J = 0; J < a.dataSeriesIndexes.length; J++) {
                            var g, d, p, k = this.data[a.dataSeriesIndexes[J]], m = 0, q = !1, n = !1;
                            if ("normal" === k.axisPlacement || "xySwapped" === k.axisPlacement) var y = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -1 / 0, s = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : 1 / 0;
                            if (k.dataPoints[m].x && k.dataPoints[m].x.getTime || "dateTime" === k.xValueType) x = !0;
                            for (m = 0; m < k.dataPoints.length; m++) {
                                "undefined" === typeof k.dataPoints[m].x && (k.dataPoints[m].x = m + (a.axisX.logarithmic ? 1 : 0));
                                k.dataPoints[m].x.getTime ? (x = !0, b = k.dataPoints[m].x.getTime()) : b = k.dataPoints[m].x;
                                if ((f = k.dataPoints[m].y) && f.length) {
                                    h = Math.min.apply(null, f);
                                    r = Math.max.apply(null, f);
                                    d = !0;
                                    for (var z = 0; z < f.length; z++) null === f.k && (d = !1);
                                    d && (q || (p = g), g = b);
                                }
                                b < c.min && (c.min = b);
                                b > c.max && (c.max = b);
                                h < e.min && (e.min = h);
                                r > e.max && (e.max = r);
                                0 < m && (a.axisX.logarithmic ? (d = b / k.dataPoints[m - 1].x, 1 > d && (d = 1 / d), 
                                c.minDiff > d && 1 !== d && (c.minDiff = d)) : (d = b - k.dataPoints[m - 1].x, 0 > d && (d *= -1), 
                                c.minDiff > d && 0 !== d && (c.minDiff = d)), f && null !== f[0] && k.dataPoints[m - 1].y && null !== k.dataPoints[m - 1].y[0] && (a.axisY.logarithmic ? (d = f[0] / k.dataPoints[m - 1].y[0], 
                                1 > d && (d = 1 / d), e.minDiff > d && 1 !== d && (e.minDiff = d)) : (d = f[0] - k.dataPoints[m - 1].y[0], 
                                0 > d && (d *= -1), e.minDiff > d && 0 !== d && (e.minDiff = d))));
                                if (!(b < y) || q) {
                                    if (!q && (q = !0, 0 < m)) {
                                        m -= 2;
                                        g = p;
                                        continue;
                                    }
                                    if (b > s && !n) n = !0; else if (b > s && n) continue;
                                    k.dataPoints[m].label && (a.axisX.labels[b] = k.dataPoints[m].label);
                                    b < c.viewPortMin && (c.viewPortMin = b);
                                    b > c.viewPortMax && (c.viewPortMax = b);
                                    if (c.viewPortMin === b && f) for (z = 0; z < f.length; z++) if (null === f[z] && g < b) {
                                        c.viewPortMin = g;
                                        break;
                                    }
                                    null === f ? c.viewPortMin === b && g < b && (c.viewPortMin = g) : (h < e.viewPortMin && (e.viewPortMin = h), 
                                    r > e.viewPortMax && (e.viewPortMax = r));
                                }
                            }
                            k.axisX.valueType = k.xValueType = x ? "dateTime" : "number";
                        }
                    };
                    l.prototype._processSpecificPlotUnit = function(a) {
                        if ("waterfall" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var b, f, e = a.axisY.dataInfo, c = a.axisX.dataInfo, h = !1, r = 0; r < a.dataSeriesIndexes.length; r++) {
                            var x = this.data[a.dataSeriesIndexes[r]], d = 0, k = !1, m = !1, q = b = 0;
                            if ("normal" === x.axisPlacement || "xySwapped" === x.axisPlacement) var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : a.axisX.options && a.axisX.options.viewportMinimum ? a.axisX.options.viewportMinimum : a.axisX.options && a.axisX.options.minimum ? a.axisX.options.minimum : a.axisX.logarithmic ? 0 : -1 / 0, g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : a.axisX.options && a.axisX.options.viewportMaximum ? a.axisX.options.viewportMaximum : a.axisX.options && a.axisX.options.maximum ? a.axisX.options.maximum : 1 / 0;
                            if (x.dataPoints[d].x && x.dataPoints[d].x.getTime || "dateTime" === x.xValueType) h = !0;
                            for (d = 0; d < x.dataPoints.length; d++) "undefined" !== typeof x.dataPoints[d].isCumulativeSum && !0 === x.dataPoints[d].isCumulativeSum ? (x.dataPointEOs[d].cumulativeSumYStartValue = 0, 
                            x.dataPointEOs[d].cumulativeSum = 0 === d ? 0 : x.dataPointEOs[d - 1].cumulativeSum, 
                            x.dataPoints[d].y = 0 === d ? 0 : x.dataPointEOs[d - 1].cumulativeSum) : "undefined" !== typeof x.dataPoints[d].isIntermediateSum && !0 === x.dataPoints[d].isIntermediateSum ? (x.dataPointEOs[d].cumulativeSumYStartValue = q, 
                            x.dataPointEOs[d].cumulativeSum = 0 === d ? 0 : x.dataPointEOs[d - 1].cumulativeSum, 
                            x.dataPoints[d].y = 0 === d ? 0 : b, q = 0 === d ? 0 : x.dataPointEOs[d - 1].cumulativeSum, 
                            b = 0) : (f = "number" !== typeof x.dataPoints[d].y ? 0 : x.dataPoints[d].y, x.dataPointEOs[d].cumulativeSumYStartValue = 0 === d ? 0 : x.dataPointEOs[d - 1].cumulativeSum, 
                            x.dataPointEOs[d].cumulativeSum = 0 === d ? f : x.dataPointEOs[d - 1].cumulativeSum + f, 
                            b += f);
                            for (d = 0; d < x.dataPoints.length; d++) if ("undefined" === typeof x.dataPoints[d].x && (x.dataPoints[d].x = d + (a.axisX.logarithmic ? 1 : 0)), 
                            x.dataPoints[d].x.getTime ? (h = !0, b = x.dataPoints[d].x.getTime()) : b = x.dataPoints[d].x, 
                            f = x.dataPoints[d].y, b < c.min && (c.min = b), b > c.max && (c.max = b), x.dataPointEOs[d].cumulativeSum < e.min && (e.min = x.dataPointEOs[d].cumulativeSum), 
                            x.dataPointEOs[d].cumulativeSum > e.max && (e.max = x.dataPointEOs[d].cumulativeSum), 
                            0 < d && (a.axisX.logarithmic ? (q = b / x.dataPoints[d - 1].x, 1 > q && (q = 1 / q), 
                            c.minDiff > q && 1 !== q && (c.minDiff = q)) : (q = b - x.dataPoints[d - 1].x, 0 > q && (q *= -1), 
                            c.minDiff > q && 0 !== q && (c.minDiff = q)), null !== f && null !== x.dataPoints[d - 1].y && (a.axisY.logarithmic ? (f = x.dataPointEOs[d].cumulativeSum / x.dataPointEOs[d - 1].cumulativeSum, 
                            1 > f && (f = 1 / f), e.minDiff > f && 1 !== f && (e.minDiff = f)) : (f = x.dataPointEOs[d].cumulativeSum - x.dataPointEOs[d - 1].cumulativeSum, 
                            0 > f && (f *= -1), e.minDiff > f && 0 !== f && (e.minDiff = f)))), !(b < n) || k) {
                                if (!k && (k = !0, 0 < d)) {
                                    d -= 2;
                                    continue;
                                }
                                if (b > g && !m) m = !0; else if (b > g && m) continue;
                                x.dataPoints[d].label && (a.axisX.labels[b] = x.dataPoints[d].label);
                                b < c.viewPortMin && (c.viewPortMin = b);
                                b > c.viewPortMax && (c.viewPortMax = b);
                                0 < d && (x.dataPointEOs[d - 1].cumulativeSum < e.viewPortMin && (e.viewPortMin = x.dataPointEOs[d - 1].cumulativeSum), 
                                x.dataPointEOs[d - 1].cumulativeSum > e.viewPortMax && (e.viewPortMax = x.dataPointEOs[d - 1].cumulativeSum));
                                x.dataPointEOs[d].cumulativeSum < e.viewPortMin && (e.viewPortMin = x.dataPointEOs[d].cumulativeSum);
                                x.dataPointEOs[d].cumulativeSum > e.viewPortMax && (e.viewPortMax = x.dataPointEOs[d].cumulativeSum);
                            }
                            x.axisX.valueType = x.xValueType = h ? "dateTime" : "number";
                        }
                    };
                    l.prototype.calculateAutoBreaks = function() {
                        function a(a, b, c, f) {
                            if (f) return c = Math.pow(Math.min(c * a / b, b / a), .2), 1 >= c && (c = Math.pow(1 > a ? 1 / a : Math.min(b / a, a), .25)), 
                            {
                                startValue: a * c,
                                endValue: b / c
                            };
                            c = .2 * Math.min(c - b + a, b - a);
                            0 >= c && (c = .25 * Math.min(b - a, Math.abs(a)));
                            return {
                                startValue: a + c,
                                endValue: b - c
                            };
                        }
                        function e(a) {
                            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
                                var b = a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks, c = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks;
                                if (b || c) for (var h, n, g = a.axisY.dataInfo, e = a.axisX.dataInfo, r = e.min, k = e.max, m = g.min, q = g.max, x = (e = e._dataRanges, 
                                g = g._dataRanges, 0), d = 0; d < a.dataSeriesIndexes.length; d++) {
                                    var J = f.data[a.dataSeriesIndexes[d]];
                                    if (!(4 > J.dataPoints.length)) for (x = 0; x < J.dataPoints.length; x++) if (b && (n = (k + 1 - r) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, 
                                    h = J.dataPoints[x].x.getTime ? J.dataPoints[x].x.getTime() : J.dataPoints[x].x, 
                                    n = Math.floor((h - r) / n), h < e[n].min && (e[n].min = h), h > e[n].max && (e[n].max = h)), 
                                    c) {
                                        var v = (q + 1 - m) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                                        if ((h = "waterfall" === a.type ? J.dataPointEOs[x].cumulativeSum : J.dataPoints[x].y) && h.length) for (var l = 0; l < h.length; l++) n = Math.floor((h[l] - m) / v), 
                                        h[l] < g[n].min && (g[n].min = h[l]), h[l] > g[n].max && (g[n].max = h[l]); else p(h) || (n = Math.floor((h - m) / v), 
                                        h < g[n].min && (g[n].min = h), h > g[n].max && (g[n].max = h));
                                    }
                                }
                            }
                        }
                        function c(a) {
                            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks) for (var h, b = a.axisX.dataInfo, c = b.min, g = b.max, e = b._dataRanges, r = 0, k = 0; k < a.dataSeriesIndexes.length; k++) {
                                var m = f.data[a.dataSeriesIndexes[k]];
                                if (!(4 > m.dataPoints.length)) for (r = 0; r < m.dataPoints.length; r++) h = (g + 1 - c) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, 
                                b = m.dataPoints[r].x.getTime ? m.dataPoints[r].x.getTime() : m.dataPoints[r].x, 
                                h = Math.floor((b - c) / h), b < e[h].min && (e[h].min = b), b > e[h].max && (e[h].max = b);
                            }
                        }
                        for (var b, f = this, h = !1, r = 0; r < this._axes.length; r++) if (this._axes[r].scaleBreaks && this._axes[r].scaleBreaks.autoCalculate && 1 <= this._axes[r].scaleBreaks.maxNumberOfAutoBreaks) {
                            h = !0;
                            this._axes[r].dataInfo._dataRanges = [];
                            for (var x = 0; x < 100 / Math.max(parseFloat(this._axes[r].scaleBreaks.collapsibleThreshold) || 10, 10); x++) this._axes[r].dataInfo._dataRanges.push({
                                min: 1 / 0,
                                max: -1 / 0
                            });
                        }
                        if (h) {
                            for (r = 0; r < this.plotInfo.plotTypes.length; r++) for (h = this.plotInfo.plotTypes[r], 
                            x = 0; x < h.plotUnits.length; x++) b = h.plotUnits[x], "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type || "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "waterfall" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? e(b) : 0 <= b.type.indexOf("stacked") && c(b);
                            for (r = 0; r < this._axes.length; r++) if (this._axes[r].dataInfo._dataRanges) {
                                var d = this._axes[r].dataInfo.min;
                                b = (this._axes[r].dataInfo.max + 1 - d) * Math.max(parseFloat(this._axes[r].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                                var m, q, k = this._axes[r].dataInfo._dataRanges;
                                h = [];
                                if (this._axes[r].dataInfo.dataPointYPositiveSums) {
                                    var n = this._axes[r].dataInfo.dataPointYPositiveSums;
                                    m = k;
                                    for (x in n) if (n.hasOwnProperty(x) && !isNaN(x) && (q = n[x], !p(q))) {
                                        var g = Math.floor((q - d) / b);
                                        q < m[g].min && (m[g].min = q);
                                        q > m[g].max && (m[g].max = q);
                                    }
                                    delete this._axes[r].dataInfo.dataPointYPositiveSums;
                                }
                                if (this._axes[r].dataInfo.dataPointYNegativeSums) {
                                    n = this._axes[r].dataInfo.dataPointYNegativeSums;
                                    m = k;
                                    for (x in n) n.hasOwnProperty(x) && !isNaN(x) && (q = -1 * n[x], p(q) || (g = Math.floor((q - d) / b), 
                                    q < m[g].min && (m[g].min = q), q > m[g].max && (m[g].max = q)));
                                    delete this._axes[r].dataInfo.dataPointYNegativeSums;
                                }
                                for (x = 0; x < k.length - 1; x++) if (m = k[x].max, isFinite(m)) for (;x < k.length - 1; ) if (d = k[x + 1].min, 
                                isFinite(d)) {
                                    q = d - m;
                                    q > b && h.push({
                                        diff: q,
                                        start: m,
                                        end: d
                                    });
                                    break;
                                } else x++;
                                if (this._axes[r].scaleBreaks.customBreaks) for (x = 0; x < this._axes[r].scaleBreaks.customBreaks.length; x++) for (b = 0; b < h.length; b++) if (this._axes[r].scaleBreaks.customBreaks[x].startValue <= h[b].start && h[b].start <= this._axes[r].scaleBreaks.customBreaks[x].endValue || this._axes[r].scaleBreaks.customBreaks[x].startValue <= h[b].start && h[b].start <= this._axes[r].scaleBreaks.customBreaks[x].endValue || h[b].start <= this._axes[r].scaleBreaks.customBreaks[x].startValue && this._axes[r].scaleBreaks.customBreaks[x].startValue <= h[b].end || h[b].start <= this._axes[r].scaleBreaks.customBreaks[x].endValue && this._axes[r].scaleBreaks.customBreaks[x].endValue <= h[b].end) h.splice(b, 1), 
                                b--;
                                h.sort((function(a, b) {
                                    return b.diff - a.diff;
                                }));
                                for (x = 0; x < Math.min(h.length, this._axes[r].scaleBreaks.maxNumberOfAutoBreaks); x++) b = a(h[x].start, h[x].end, this._axes[r].logarithmic ? this._axes[r].dataInfo.max / this._axes[r].dataInfo.min : this._axes[r].dataInfo.max - this._axes[r].dataInfo.min, this._axes[r].logarithmic), 
                                this._axes[r].scaleBreaks.autoBreaks.push(new ca(this, "autoBreaks", b, x, ++this._eventManager.lastObjectId, this._axes[r].scaleBreaks)), 
                                this._axes[r].scaleBreaks._appliedBreaks.push(this._axes[r].scaleBreaks.autoBreaks[this._axes[r].scaleBreaks.autoBreaks.length - 1]);
                                this._axes[r].scaleBreaks._appliedBreaks.sort((function(a, b) {
                                    return a.startValue - b.startValue;
                                }));
                            }
                        }
                    };
                    l.prototype.renderCrosshairs = function(a) {
                        for (var e = 0; e < this.axisX.length; e++) this.axisX[e] != a && this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && !this.axisX[e].crosshair._hidden && this.axisX[e].showCrosshair(this.axisX[e].crosshair._updatedValue);
                        for (e = 0; e < this.axisX2.length; e++) this.axisX2[e] != a && this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && !this.axisX2[e].crosshair._hidden && this.axisX2[e].showCrosshair(this.axisX2[e].crosshair._updatedValue);
                        for (e = 0; e < this.axisY.length; e++) this.axisY[e] != a && this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && !this.axisY[e].crosshair._hidden && this.axisY[e].showCrosshair(this.axisY[e].crosshair._updatedValue);
                        for (e = 0; e < this.axisY2.length; e++) this.axisY2[e] != a && this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && !this.axisY2[e].crosshair._hidden && this.axisY2[e].showCrosshair(this.axisY2[e].crosshair._updatedValue);
                    };
                    l.prototype.getDataPointAtXY = function(a, e, c) {
                        c = c || !1;
                        for (var b = [], f = this._dataInRenderedOrder.length - 1; 0 <= f; f--) {
                            var h = null;
                            (h = this._dataInRenderedOrder[f].getDataPointAtXY(a, e, c)) && b.push(h);
                        }
                        a = null;
                        e = !1;
                        for (c = 0; c < b.length; c++) if ("line" === b[c].dataSeries.type || "stepLine" === b[c].dataSeries.type || "area" === b[c].dataSeries.type || "stepArea" === b[c].dataSeries.type) if (f = oa("markerSize", b[c].dataPoint, b[c].dataSeries) || 8, 
                        b[c].distance <= f / 2) {
                            e = !0;
                            break;
                        }
                        for (c = 0; c < b.length; c++) e && "line" !== b[c].dataSeries.type && "stepLine" !== b[c].dataSeries.type && "area" !== b[c].dataSeries.type && "stepArea" !== b[c].dataSeries.type || (a ? b[c].distance <= a.distance && (a = b[c]) : a = b[c]);
                        return a;
                    };
                    l.prototype.getObjectAtXY = function(a, e, c) {
                        var b = null;
                        if (c = this.getDataPointAtXY(a, e, c || !1)) b = c.dataSeries.dataPointIds[c.dataPointIndex]; else if (v) b = ab(a, e, this._eventManager.ghostCtx); else for (c = 0; c < this.legend.items.length; c++) {
                            var f = this.legend.items[c];
                            a >= f.x1 && a <= f.x2 && e >= f.y1 && e <= f.y2 && (b = f.id);
                        }
                        return b;
                    };
                    l.prototype.getAutoFontSize = mb;
                    l.prototype.resetOverlayedCanvas = function() {
                        this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height);
                    };
                    l.prototype.clearCanvas = lb;
                    l.prototype.attachEvent = function(a) {
                        this._events.push(a);
                    };
                    l.prototype._touchEventHandler = function(a) {
                        if (a.changedTouches && this.interactivityEnabled) {
                            var e = [], c = a.changedTouches, b = c ? c[0] : a, f = null;
                            switch (a.type) {
                              case "touchstart":
                              case "MSPointerDown":
                                e = [ "mousemove", "mousedown" ];
                                this._lastTouchData = Qa(b);
                                this._lastTouchData.time = new Date;
                                break;

                              case "touchmove":
                              case "MSPointerMove":
                                e = [ "mousemove" ];
                                break;

                              case "touchend":
                              case "MSPointerUp":
                                var h = this._lastTouchData && this._lastTouchData.time ? new Date - this._lastTouchData.time : 0;
                                e = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > h ? [ "mouseup", "click" ] : [ "mouseup" ];
                                break;

                              default:
                                return;
                            }
                            if (!(c && 1 < c.length)) {
                                f = Qa(b);
                                f.time = new Date;
                                try {
                                    var r = f.y - this._lastTouchData.y;
                                    h = f.time - this._lastTouchData.time;
                                    if (1 < Math.abs(r) && this._lastTouchData.scroll || 5 < Math.abs(r) && 250 > h) this._lastTouchData.scroll = !0;
                                } catch (x) {}
                                this._lastTouchEventType = a.type;
                                if (this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), 
                                this.isDrag = !1; else for (c = 0; c < e.length; c++) if (f = e[c], r = document.createEvent("MouseEvent"), 
                                r.initMouseEvent(f, !0, !0, window, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1, !1, !1, !1, 0, null), 
                                b.target.dispatchEvent(r), !p(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < h || "click" === f) a.preventManipulation && a.preventManipulation(), 
                                a.preventDefault && a.cancelable && a.preventDefault();
                            }
                        }
                    };
                    l.prototype._dispatchRangeEvent = function(a, e) {
                        var c = {
                            chart: this
                        };
                        c.type = a;
                        c.trigger = e;
                        var b = [];
                        this.axisX && 0 < this.axisX.length && b.push("axisX");
                        this.axisX2 && 0 < this.axisX2.length && b.push("axisX2");
                        this.axisY && 0 < this.axisY.length && b.push("axisY");
                        this.axisY2 && 0 < this.axisY2.length && b.push("axisY2");
                        for (var f = 0; f < b.length; f++) if (p(c[b[f]]) && (c[b[f]] = []), "axisY" === b[f]) for (var h = 0; h < this.axisY.length; h++) c[b[f]].push({
                            viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,
                            viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum
                        }); else if ("axisY2" === b[f]) for (h = 0; h < this.axisY2.length; h++) c[b[f]].push({
                            viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,
                            viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum
                        }); else if ("axisX" === b[f]) for (h = 0; h < this.axisX.length; h++) c[b[f]].push({
                            viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,
                            viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum
                        }); else if ("axisX2" === b[f]) for (h = 0; h < this.axisX2.length; h++) c[b[f]].push({
                            viewportMinimum: this[b[f]][h].sessionVariables.newViewportMinimum,
                            viewportMaximum: this[b[f]][h].sessionVariables.newViewportMaximum
                        });
                        this.dispatchEvent(a, c, this);
                    };
                    l.prototype._mouseEventHandler = function(a) {
                        function e() {
                            l.capturedEventParam && (f = l.capturedEventParam, r = f.bounds, "mouseup" === b && (l.capturedEventParam = null, 
                            f.chart.overlaidCanvas.releaseCapture ? f.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", f.chart._mouseEventHandler, !1)), 
                            f.hasOwnProperty(b) && ("mouseup" !== b || f.chart.overlaidCanvas.releaseCapture ? a.target !== f.chart.overlaidCanvas && v || f[b].call(f.context, c.x, c.y) : a.target !== f.chart.overlaidCanvas && (f.chart.isDrag = !1)));
                        }
                        "undefined" === typeof a.target && a.srcElement && (a.target = a.srcElement);
                        var f, h, c = Qa(a), b = a.type;
                        a.which ? h = 3 == a.which : a.button && (h = 2 == a.button);
                        if (this._ignoreNextEvent) e(), this._ignoreNextEvent = !1; else if (e(), this.interactivityEnabled) {
                            a.preventManipulation && a.preventManipulation();
                            a.preventDefault && a.preventDefault();
                            var r;
                            Ia && window.console && (window.console.log(b + " --\x3e x: " + c.x + "; y:" + c.y), 
                            h && window.console.log(a.which), "mouseup" === b && window.console.log("mouseup"));
                            if (!h) {
                                if (!l.capturedEventParam && this._events) {
                                    for (h = 0; h < this._events.length; h++) if (this._events[h].hasOwnProperty(b)) if (f = this._events[h], 
                                    r = f.bounds, c.x >= r.x1 && c.x <= r.x2 && c.y >= r.y1 && c.y <= r.y2) {
                                        f[b].call(f.context, c.x, c.y);
                                        "mousedown" === b && !0 === f.capture ? (l.capturedEventParam = f, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === b && (f.chart.overlaidCanvas.releaseCapture ? f.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1));
                                        break;
                                    } else f = null;
                                    a.target.style.cursor = f && f.cursor ? f.cursor : this._defaultCursor;
                                }
                                h = this.plotArea;
                                if (c.x < h.x1 || c.x > h.x2 || c.y < h.y1 || c.y > h.y2) {
                                    this.toolTip && this.toolTip.enabled ? (this.toolTip.hide(), this.toolTip.dispatchEvent("hidden", {
                                        chart: this,
                                        toolTip: this.toolTip
                                    }, this.toolTip)) : this.resetOverlayedCanvas();
                                    for (h = 0; h < this.axisX.length; h++) this.axisX[h].crosshair && this.axisX[h].crosshair.enabled && (this.axisX[h].crosshair.hide(), 
                                    this.axisX[h].crosshair.dispatchEvent("hidden", {
                                        chart: this,
                                        axis: this.axisX[h].options
                                    }, this.axisX[h].crosshair));
                                    for (h = 0; h < this.axisX2.length; h++) this.axisX2[h].crosshair && this.axisX2[h].crosshair.enabled && (this.axisX2[h].crosshair.hide(), 
                                    this.axisX2[h].crosshair.dispatchEvent("hidden", {
                                        chart: this,
                                        axis: this.axisX2[h].options
                                    }, this.axisX2[h].crosshair));
                                    for (h = 0; h < this.axisY.length; h++) this.axisY[h].crosshair && this.axisY[h].crosshair.enabled && (this.axisY[h].crosshair.hide(), 
                                    this.axisY[h].crosshair.dispatchEvent("hidden", {
                                        chart: this,
                                        axis: this.axisY[h].options
                                    }, this.axisY[h].crosshair));
                                    for (h = 0; h < this.axisY2.length; h++) this.axisY2[h].crosshair && this.axisY2[h].crosshair.enabled && (this.axisY2[h].crosshair.hide(), 
                                    this.axisY2[h].crosshair.dispatchEvent("hidden", {
                                        chart: this,
                                        axis: this.axisY2[h].options
                                    }, this.axisY2[h].crosshair));
                                }
                                this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a);
                            }
                        }
                    };
                    l.prototype._plotAreaMouseDown = function(a, e) {
                        this.isDrag = !0;
                        this.dragStartPoint = {
                            x: a,
                            y: e
                        };
                    };
                    l.prototype._plotAreaMouseUp = function(a, e) {
                        if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
                            var c = e - this.dragStartPoint.y, b = a - this.dragStartPoint.x, f = 0 <= this.zoomType.indexOf("x"), h = 0 <= this.zoomType.indexOf("y"), r = !1;
                            this.resetOverlayedCanvas();
                            if ("xySwapped" === this.plotInfo.axisPlacement) {
                                var x = h;
                                h = f, f = x;
                            }
                            if (this.panEnabled || this.zoomEnabled) {
                                if (this.panEnabled) for (f = h = 0; f < this._axes.length; f++) c = this._axes[f], 
                                c.logarithmic ? c.viewportMinimum < c.minimum ? (h = c.minimum / c.viewportMinimum, 
                                c.sessionVariables.newViewportMinimum = c.viewportMinimum * h, c.sessionVariables.newViewportMaximum = c.viewportMaximum * h, 
                                r = !0) : c.viewportMaximum > c.maximum && (h = c.viewportMaximum / c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum / h, 
                                c.sessionVariables.newViewportMaximum = c.viewportMaximum / h, r = !0) : c.viewportMinimum < c.minimum ? (h = c.minimum - c.viewportMinimum, 
                                c.sessionVariables.newViewportMinimum = c.viewportMinimum + h, c.sessionVariables.newViewportMaximum = c.viewportMaximum + h, 
                                r = !0) : c.viewportMaximum > c.maximum && (h = c.viewportMaximum - c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum - h, 
                                c.sessionVariables.newViewportMaximum = c.viewportMaximum - h, r = !0); else if ((!f || 2 < Math.abs(b)) && (!h || 2 < Math.abs(c)) && this.zoomEnabled) {
                                    if (!this.dragStartPoint) return;
                                    c = f ? this.dragStartPoint.x : this.plotArea.x1;
                                    b = h ? this.dragStartPoint.y : this.plotArea.y1;
                                    f = f ? a : this.plotArea.x2;
                                    h = h ? e : this.plotArea.y2;
                                    2 < Math.abs(c - f) && 2 < Math.abs(b - h) && this._zoomPanToSelectedRegion(c, b, f, h) && (r = !0);
                                }
                                r && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), 
                                this.stockChart && this.stockChart.navigator && this.stockChart.navigator.enabled && (this.stockChart._rangeEventParameter || (this.stockChart._rangeEventParameter = {
                                    stockChart: this.stockChart,
                                    source: "chart",
                                    index: this.stockChart.charts.indexOf(this),
                                    minimum: this.stockChart.sessionVariables._axisXMin,
                                    maximum: this.stockChart.sessionVariables._axisXMax
                                }), this.stockChart._rangeEventParameter.type = "rangeChanging", this.stockChart.dispatchEvent("rangeChanging", this.stockChart._rangeEventParameter, this.stockChart)), 
                                this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), this.stockChart && this.stockChart.navigator && this.stockChart.navigator.enabled && (this.stockChart._rangeEventParameter.type = "rangeChanged", 
                                this.stockChart.dispatchEvent("rangeChanged", this.stockChart._rangeEventParameter, this.stockChart)), 
                                r && this.zoomEnabled && "none" === this._zoomButton.style.display && (Ma(this._zoomButton, this._resetButton), 
                                ua(this, this._zoomButton, "pan"), ua(this, this._resetButton, "reset")));
                            }
                        }
                        this.isDrag = !1;
                        if ("none" !== this.plotInfo.axisPlacement) {
                            this.resetOverlayedCanvas();
                            if (this.axisX && 0 < this.axisX.length) for (r = 0; r < this.axisX.length; r++) this.axisX[r].crosshair && this.axisX[r].crosshair.enabled && this.axisX[r].renderCrosshair(a, e);
                            if (this.axisX2 && 0 < this.axisX2.length) for (r = 0; r < this.axisX2.length; r++) this.axisX2[r].crosshair && this.axisX2[r].crosshair.enabled && this.axisX2[r].renderCrosshair(a, e);
                            if (this.axisY && 0 < this.axisY.length) for (r = 0; r < this.axisY.length; r++) this.axisY[r].crosshair && this.axisY[r].crosshair.enabled && this.axisY[r].renderCrosshair(a, e);
                            if (this.axisY2 && 0 < this.axisY2.length) for (r = 0; r < this.axisY2.length; r++) this.axisY2[r].crosshair && this.axisY2[r].crosshair.enabled && this.axisY2[r].renderCrosshair(a, e);
                            if (this.axisX && 0 < this.axisX.length) for (r = 0; r < this.axisX.length; r++) this.axisX[r].crosshair && this.axisX[r].crosshair.enabled && this.axisX[r].crosshair.renderLabel();
                            if (this.axisX2 && 0 < this.axisX2.length) for (r = 0; r < this.axisX2.length; r++) this.axisX2[r].crosshair && this.axisX2[r].crosshair.enabled && this.axisX2[r].crosshair.renderLabel();
                            if (this.axisY && 0 < this.axisY.length) for (r = 0; r < this.axisY.length; r++) this.axisY[r].crosshair && this.axisY[r].crosshair.enabled && this.axisY[r].crosshair.renderLabel();
                            if (this.axisY2 && 0 < this.axisY2.length) for (r = 0; r < this.axisY2.length; r++) this.axisY2[r].crosshair && this.axisY2[r].crosshair.enabled && this.axisY2[r].crosshair.renderLabel();
                        }
                    };
                    l.prototype._plotAreaMouseMove = function(a, e) {
                        if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
                            var c = 0, b = 0, f = c = null, h = (f = 0 <= this.zoomType.indexOf("x"), 0 <= this.zoomType.indexOf("y")), r = this;
                            "xySwapped" === this.plotInfo.axisPlacement && (c = h, h = f, f = c);
                            c = this.dragStartPoint.x - a;
                            b = this.dragStartPoint.y - e;
                            if (2 < Math.abs(c) && 8 > Math.abs(c) && (this.panEnabled || this.zoomEnabled)) {
                                this.toolTip.hide();
                                this.toolTip && this.toolTip.enabled && this.toolTip.dispatchEvent("hidden", {
                                    chart: this,
                                    toolTip: this.toolTip
                                }, this.toolTip);
                                for (var x = 0; x < this.axisX.length; x++) this.axisX[x].crosshair && this.axisX[x].crosshair.enabled && (this.axisX[x].crosshair.hide(), 
                                this.axisX[x].crosshair.dispatchEvent("hidden", {
                                    chart: this,
                                    axis: this.axisX[x].options
                                }, this.axisX[x].crosshair));
                                for (x = 0; x < this.axisX2.length; x++) this.axisX2[x].crosshair && this.axisX2[x].crosshair.enabled && (this.axisX2[x].crosshair.hide(), 
                                this.axisX2[x].crosshair.dispatchEvent("hidden", {
                                    chart: this,
                                    axis: this.axisX2[x].options
                                }, this.axisX2[x].crosshair));
                                for (x = 0; x < this.axisY.length; x++) this.axisY[x].crosshair && this.axisY[x].crosshair.enabled && (this.axisY[x].crosshair.hide(), 
                                this.axisY[x].crosshair.dispatchEvent("hidden", {
                                    chart: this,
                                    axis: this.axisY[x].options
                                }, this.axisY[x].crosshair));
                                for (x = 0; x < this.axisY2.length; x++) this.axisY2[x].crosshair && this.axisY2[x].crosshair.enabled && (this.axisY2[x].crosshair.hide(), 
                                this.axisY2[x].crosshair.dispatchEvent("hidden", {
                                    chart: this,
                                    axis: this.axisY2[x].options
                                }, this.axisY2[x].crosshair));
                            } else this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, e);
                            if ((!f || 2 < Math.abs(c) || !h || 2 < Math.abs(b)) && (this.panEnabled || this.zoomEnabled)) if (this.panEnabled) f = {
                                x1: f ? this.plotArea.x1 + c : this.plotArea.x1,
                                y1: h ? this.plotArea.y1 + b : this.plotArea.y1,
                                x2: f ? this.plotArea.x2 + c : this.plotArea.x2,
                                y2: h ? this.plotArea.y2 + b : this.plotArea.y2
                            }, clearTimeout(r._panTimerId), r._panTimerId = setTimeout(function(b, c, f, g) {
                                return function() {
                                    r._zoomPanToSelectedRegion(b, c, f, g, !0) && (r._dispatchRangeEvent("rangeChanging", "pan"), 
                                    r.stockChart && r.stockChart.navigator && r.stockChart.navigator.enabled && (r.stockChart._rangeEventParameter.type = "rangeChanging", 
                                    r.stockChart.dispatchEvent("rangeChanging", r.stockChart._rangeEventParameter, r.stockChart)), 
                                    r.render(), r._dispatchRangeEvent("rangeChanged", "pan"), r.stockChart && r.stockChart.navigator && r.stockChart.navigator.enabled && (r.stockChart._rangeEventParameter.type = "rangeChanged", 
                                    r.stockChart.dispatchEvent("rangeChanged", r.stockChart._rangeEventParameter, r.stockChart)), 
                                    r.dragStartPoint.x = a, r.dragStartPoint.y = e);
                                };
                            }(f.x1, f.y1, f.x2, f.y2), 0); else if (this.zoomEnabled) {
                                this.resetOverlayedCanvas();
                                c = this.overlaidCanvasCtx.globalAlpha;
                                this.overlaidCanvasCtx.fillStyle = "#A89896";
                                b = f ? this.dragStartPoint.x : this.plotArea.x1, x = h ? this.dragStartPoint.y : this.plotArea.y1;
                                var d = f ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, k = h ? e - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
                                this.validateRegion(b, x, f ? a : this.plotArea.x2 - this.plotArea.x1, h ? e : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), 
                                this.overlaidCanvasCtx.fillStyle = "#99B2B5");
                                this.overlaidCanvasCtx.globalAlpha = .7;
                                this.overlaidCanvasCtx.fillRect(b, x, d, k);
                                this.overlaidCanvasCtx.globalAlpha = c;
                            }
                        } else if (this.toolTip.mouseMoveHandler(a, e), "none" !== this.plotInfo.axisPlacement) {
                            if (this.axisX && 0 < this.axisX.length) for (f = 0; f < this.axisX.length; f++) this.axisX[f].crosshair && this.axisX[f].crosshair.enabled && this.axisX[f].renderCrosshair(a, e);
                            if (this.axisX2 && 0 < this.axisX2.length) for (f = 0; f < this.axisX2.length; f++) this.axisX2[f].crosshair && this.axisX2[f].crosshair.enabled && this.axisX2[f].renderCrosshair(a, e);
                            if (this.axisY && 0 < this.axisY.length) for (f = 0; f < this.axisY.length; f++) this.axisY[f].crosshair && this.axisY[f].crosshair.enabled && this.axisY[f].renderCrosshair(a, e);
                            if (this.axisY2 && 0 < this.axisY2.length) for (f = 0; f < this.axisY2.length; f++) this.axisY2[f].crosshair && this.axisY2[f].crosshair.enabled && this.axisY2[f].renderCrosshair(a, e);
                            if (this.axisX && 0 < this.axisX.length) for (f = 0; f < this.axisX.length; f++) this.axisX[f].crosshair && this.axisX[f].crosshair.enabled && this.axisX[f].crosshair.renderLabel();
                            if (this.axisX2 && 0 < this.axisX2.length) for (f = 0; f < this.axisX2.length; f++) this.axisX2[f].crosshair && this.axisX2[f].crosshair.enabled && this.axisX2[f].crosshair.renderLabel();
                            if (this.axisY && 0 < this.axisY.length) for (f = 0; f < this.axisY.length; f++) this.axisY[f].crosshair && this.axisY[f].crosshair.enabled && this.axisY[f].crosshair.renderLabel();
                            if (this.axisY2 && 0 < this.axisY2.length) for (f = 0; f < this.axisY2.length; f++) this.axisY2[f].crosshair && this.axisY2[f].crosshair.enabled && this.axisY2[f].crosshair.renderLabel();
                        }
                    };
                    l.prototype._zoomPanToSelectedRegion = function(a, e, c, b, f) {
                        a = this.validateRegion(a, e, c, b, f);
                        e = a.axesWithValidRange;
                        c = a.axesRanges;
                        if (a.isValid) for (b = 0; b < e.length; b++) f = c[b], e[b].setViewPortRange(f.val1, f.val2), 
                        this.syncCharts && "y" != this.zoomType && this.syncCharts(f.val1, f.val2), this.stockChart && (this.stockChart._rangeEventParameter = {
                            stockChart: this.stockChart,
                            source: "chart",
                            index: this.stockChart.charts.indexOf(this),
                            minimum: f.val1,
                            maximum: f.val2
                        });
                        return a.isValid;
                    };
                    l.prototype.validateRegion = function(a, e, c, b, f) {
                        f = f || !1;
                        for (var h = 0 <= this.zoomType.indexOf("x"), r = 0 <= this.zoomType.indexOf("y"), x = !1, d = [], k = [], m = [], q = 0; q < this._axes.length; q++) ("axisX" === this._axes[q].type && h || "axisY" === this._axes[q].type && r) && k.push(this._axes[q]);
                        for (r = 0; r < k.length; r++) {
                            q = k[r], h = !1;
                            var n = q.convertPixelToValue({
                                x: a,
                                y: e
                            }), g = q.convertPixelToValue({
                                x: c,
                                y: b
                            });
                            if (n > g) {
                                var p = g;
                                g = n, n = p;
                            }
                            if (q.scaleBreaks) for (p = 0; !h && p < q.scaleBreaks._appliedBreaks.length; p++) h = q.scaleBreaks._appliedBreaks[p].startValue <= n && q.scaleBreaks._appliedBreaks[p].endValue >= g;
                            if (isFinite(q.dataInfo.minDiff)) if (p = q.getApparentDifference(n, g, null, !0), 
                            !(h || !(this.panEnabled && q.scaleBreaks && q.scaleBreaks._appliedBreaks.length) && (q.logarithmic && p < Math.pow(q.dataInfo.minDiff, 3) || !q.logarithmic && p < 3 * Math.abs(q.dataInfo.minDiff)) || n < q.minimum || g > q.maximum)) d.push(q), 
                            m.push({
                                val1: n,
                                val2: g
                            }), x = !0; else if (!f) {
                                x = !1;
                                break;
                            }
                        }
                        return {
                            isValid: x,
                            axesWithValidRange: d,
                            axesRanges: m
                        };
                    };
                    l.prototype.preparePlotArea = function() {
                        var a = this.plotArea;
                        !v && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);
                        if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
                            var e = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;
                            if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
                                var c = this.axisY[0];
                                a.x1 = e.x1 < e.x2 ? e.x1 : c.lineCoordinates.x1;
                                a.y1 = e.y1 < c.lineCoordinates.y1 ? e.y1 : c.lineCoordinates.y1;
                                a.x2 = e.x2 > c.lineCoordinates.x2 ? e.x2 : c.lineCoordinates.x2;
                                a.y2 = e.y1 > c.lineCoordinates.y2 ? e.y1 : c.lineCoordinates.y2;
                                a.width = a.x2 - a.x1;
                                a.height = a.y2 - a.y1;
                            }
                            this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (c = this.axisY2[0], 
                            a.x1 = e.x1 < e.x2 ? e.x1 : c.lineCoordinates.x1, a.y1 = e.y1 < c.lineCoordinates.y1 ? e.y1 : c.lineCoordinates.y1, 
                            a.x2 = e.x2 > c.lineCoordinates.x2 ? e.x2 : c.lineCoordinates.x2, a.y2 = e.y2 > c.lineCoordinates.y2 ? e.y2 : c.lineCoordinates.y2, 
                            a.width = a.x2 - a.x1, a.height = a.y2 - a.y1);
                        } else e = this.layoutManager.getFreeSpace(), a.x1 = e.x1, a.x2 = e.x2, a.y1 = e.y1, 
                        a.y2 = e.y2, a.width = e.width, a.height = e.height;
                        v || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", 
                        a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));
                        a.layoutManager = new Fa(a.x1, a.y1, a.x2, a.y2, 2);
                    };
                    l.prototype.renderIndexLabels = function(a) {
                        var e = a || this.plotArea.ctx, c = this.plotArea, b = 0, f = 0, h = 0, r = f = h = 0, x = 0, d = b = 0, k = 0;
                        for (a = 0; a < this._indexLabels.length; a++) {
                            var n, g, m = this._indexLabels[a], q = m.chartType.toLowerCase(), na = (x = oa("indexLabelFontColor", m.dataPoint, m.dataSeries), 
                            oa("indexLabelFontSize", m.dataPoint, m.dataSeries));
                            d = oa("indexLabelFontFamily", m.dataPoint, m.dataSeries), k = oa("indexLabelFontStyle", m.dataPoint, m.dataSeries);
                            n = oa("indexLabelFontWeight", m.dataPoint, m.dataSeries);
                            var w = oa("indexLabelBackgroundColor", m.dataPoint, m.dataSeries);
                            g = oa("indexLabelMaxWidth", m.dataPoint, m.dataSeries);
                            h = oa("indexLabelWrap", m.dataPoint, m.dataSeries);
                            var y = oa("indexLabelLineDashType", m.dataPoint, m.dataSeries), s = oa("indexLabelLineColor", m.dataPoint, m.dataSeries), z = p(m.dataPoint.indexLabelLineThickness) ? p(m.dataSeries.options.indexLabelLineThickness) ? 0 : m.dataSeries.options.indexLabelLineThickness : m.dataPoint.indexLabelLineThickness, u = (b = 0 < z ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, 
                            {
                                percent: null,
                                total: null
                            }), l = null;
                            if (0 <= m.dataSeries.type.indexOf("stacked") || "pie" === m.dataSeries.type || "doughnut" === m.dataSeries.type) u = this.getPercentAndTotal(m.dataSeries, m.dataPoint);
                            if (m.dataSeries.indexLabelFormatter || m.dataPoint.indexLabelFormatter) l = {
                                chart: this,
                                dataSeries: m.dataSeries,
                                dataPoint: m.dataPoint,
                                index: m.indexKeyword,
                                total: u.total,
                                percent: u.percent
                            };
                            var C = m.dataPoint.indexLabelFormatter ? m.dataPoint.indexLabelFormatter(l) : m.dataPoint.indexLabel ? this.replaceKeywordsWithValue(m.dataPoint.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : m.dataSeries.indexLabelFormatter ? m.dataSeries.indexLabelFormatter(l) : m.dataSeries.indexLabel ? this.replaceKeywordsWithValue(m.dataSeries.indexLabel, m.dataPoint, m.dataSeries, null, m.indexKeyword) : null;
                            if (null !== C && "" !== C) {
                                u = oa("indexLabelPlacement", m.dataPoint, m.dataSeries), l = oa("indexLabelOrientation", m.dataPoint, m.dataSeries);
                                var A = oa("indexLabelTextAlign", m.dataPoint, m.dataSeries), t = m.direction, B = (f = m.dataSeries.axisX, 
                                r = m.dataSeries.axisY, !1);
                                w = new ka(e, {
                                    x: 0,
                                    y: 0,
                                    maxWidth: g ? g : .5 * this.width,
                                    maxHeight: h ? 5 * na : 1.5 * na,
                                    angle: "horizontal" === l ? 0 : -90,
                                    text: C,
                                    padding: 0,
                                    backgroundColor: w,
                                    textAlign: A,
                                    fontSize: na,
                                    fontFamily: d,
                                    fontWeight: n,
                                    fontColor: x,
                                    fontStyle: k,
                                    textBaseline: "middle"
                                });
                                w.measureText();
                                m.dataSeries.indexLabelMaxWidth = w.maxWidth;
                                if ("stackedarea100" === q) {
                                    if (m.point.x < c.x1 || m.point.x > c.x2 || m.point.y < c.y1 - 1 || m.point.y > c.y2 + 1) continue;
                                } else if ("rangearea" === q || "rangesplinearea" === q) {
                                    if (m.dataPoint.x < f.viewportMinimum || m.dataPoint.x > f.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < r.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > r.viewportMaximum) continue;
                                } else if (0 <= q.indexOf("line") || 0 <= q.indexOf("area") || 0 <= q.indexOf("bubble") || 0 <= q.indexOf("scatter")) {
                                    if (m.dataPoint.x < f.viewportMinimum || m.dataPoint.x > f.viewportMaximum || m.dataPoint.y < r.viewportMinimum || m.dataPoint.y > r.viewportMaximum) continue;
                                } else if (0 <= q.indexOf("column") || "waterfall" === q || "error" === q && !m.axisSwapped) {
                                    if (m.dataPoint.x < f.viewportMinimum || m.dataPoint.x > f.viewportMaximum || m.bounds.y1 > c.y2 || m.bounds.y2 < c.y1) continue;
                                } else if (0 <= q.indexOf("bar") || "error" === q) {
                                    if (m.dataPoint.x < f.viewportMinimum || m.dataPoint.x > f.viewportMaximum || m.bounds.x1 > c.x2 || m.bounds.x2 < c.x1) continue;
                                } else if ("candlestick" === q || "ohlc" === q) {
                                    if (m.dataPoint.x < f.viewportMinimum || m.dataPoint.x > f.viewportMaximum || Math.max.apply(null, m.dataPoint.y) < r.viewportMinimum || Math.min.apply(null, m.dataPoint.y) > r.viewportMaximum) continue;
                                } else if (m.dataPoint.x < f.viewportMinimum || m.dataPoint.x > f.viewportMaximum) continue;
                                r = x = 2;
                                "horizontal" === l ? (d = w.width, k = w.height) : (k = w.width, d = w.height);
                                if ("normal" === this.plotInfo.axisPlacement) {
                                    if (0 <= q.indexOf("line") || 0 <= q.indexOf("area")) u = "auto", x = 4; else if (0 <= q.indexOf("stacked")) "auto" === u && (u = "inside"); else if ("bubble" === q || "scatter" === q) u = "inside";
                                    n = m.point.x - d / 2 + ("horizontal" === l ? 0 : w._lineHeight / 2);
                                    if ("inside" !== u) f = c.y1, h = c.y2, 0 < t ? (g = m.point.y + w._lineHeight / 2 - k - x - b, 
                                    g < f && (g = "auto" === u ? Math.max(m.point.y, f) + w._lineHeight / 2 + x + b : f + w._lineHeight / 2 + x + b, 
                                    B = g + k > m.point.y)) : (g = m.point.y + w._lineHeight / 2 + x + b, g > h - k + w._lineHeight / 2 - x && (g = "auto" === u ? Math.min(m.point.y, h) + w._lineHeight / 2 - k - x - b : h + w._lineHeight / 2 - k - x - b, 
                                    B = g < m.point.y)); else {
                                        Math.max(m.bounds.y1, c.y1);
                                        h = Math.min(m.bounds.y2, c.y2) - k + w._lineHeight / 2;
                                        b = 0 <= q.indexOf("range") || "error" === q ? 0 < t ? Math.max(m.bounds.y1, c.y1) + w._lineHeight / 2 + x : Math.min(m.bounds.y2, c.y2) + w._lineHeight / 2 - k - x : (Math.max(m.bounds.y1, c.y1) + Math.min(m.bounds.y2, c.y2)) / 2 - k / 2 + w._lineHeight / 2;
                                        if (0 < t) {
                                            if (g = b, "bubble" === q || "scatter" === q) g = m.point.y - k / 2 + w._lineHeight / 2, 
                                            k > m.bounds.y2 - m.bounds.y1 && (g -= k / 2 + x), 0 > g - w._lineHeight / 2 && (g += Math.abs(g - w._lineHeight / 2) <= (m.bounds.y2 - m.bounds.y1) / 2 + x ? Math.abs(g - w._lineHeight / 2) : (m.bounds.y2 - m.bounds.y1) / 2 + x);
                                        } else g = Math.min(m.point.y, b), g > h - k - x && ("bubble" === q || "scatter" === q) && (g = Math.min(m.point.y + x, c.y2 - k - x));
                                        g = Math.min(g, h);
                                    }
                                } else 0 <= q.indexOf("line") || 0 <= q.indexOf("area") || 0 <= q.indexOf("scatter") ? (u = "auto", 
                                r = 4) : 0 <= q.indexOf("stacked") ? "auto" === u && (u = "inside") : "bubble" === q && (u = "inside"), 
                                g = m.point.y + w._lineHeight / 2 - k / 2, "inside" !== u ? (h = c.x1, f = c.x2, 
                                0 > t ? (n = m.point.x - d + ("horizontal" === l ? 0 : w._lineHeight / 2) - r - b, 
                                ("horizontal" === l ? n : n - w._lineHeight / 2) < h && (n = "auto" === u ? Math.max(m.point.x, h) + ("horizontal" === l ? 0 : w._lineHeight / 2) + x + b : h + ("horizontal" === l ? 0 : w._lineHeight / 2) + r + b, 
                                B = n + d > m.point.x)) : (n = m.point.x + ("horizontal" === l ? 0 : w._lineHeight / 2) + r + b, 
                                ("horizontal" === l ? n : n - w._lineHeight / 2) > f - d - r - b && (n = "auto" === u ? Math.min(m.point.x, f) - ("horizontal" === l ? d : d - w._lineHeight / 2) - r - b : f - d - r - b + ("horizontal" === l ? 0 : w._lineHeight / 2), 
                                B = n < m.point.x))) : (h = Math.max(m.bounds.x1, c.x1), Math.min(m.bounds.x2, c.x2), 
                                b = 0 <= q.indexOf("range") || "error" === q ? 0 > t ? Math.max(m.bounds.x1, c.x1) : Math.min(m.bounds.x2, c.x2) - d - r + ("horizontal" === l ? 0 : w._lineHeight / 2) : (Math.max(m.bounds.x1, c.x1) + Math.min(m.bounds.x2, c.x2)) / 2 - d / 2 + ("horizontal" === l ? 0 : w._lineHeight / 2), 
                                n = 0 > t ? b : Math.min(m.point.x, b), n = Math.max(n, h + ("horizontal" === l ? 0 : w._lineHeight / 2 + x)));
                                "vertical" === l && (g += k - w._lineHeight / 2, "bubble" === q || "scatter" === q) && (n += w._lineHeight / 2 - na / 2);
                                w.x = n;
                                w.y = g;
                                w.render(!0);
                                z && "inside" !== u && (0 > q.indexOf("bar") && ("error" !== q || !m.axisSwapped) && m.point.x > c.x1 && m.point.x < c.x2 || !B) && (0 > q.indexOf("column") && ("error" !== q || m.axisSwapped) && m.point.y > c.y1 && m.point.y < c.y2 || !B) && (e.lineWidth = z, 
                                e.strokeStyle = s ? s : "gray", e.setLineDash && e.setLineDash(H(y, z)), e.beginPath(), 
                                e.moveTo(m.point.x, m.point.y), 0 <= q.indexOf("bar") || "error" === q && m.axisSwapped ? e.lineTo(n + (0 < m.direction ? 0 : d) + ("vertical" === l ? -w._lineHeight / 2 : 0), g + ("vertical" === l ? -k / 2 : k / 2 - w._lineHeight / 2)) : 0 <= q.indexOf("column") || "error" === q && !m.axisSwapped ? e.lineTo(n + d / 2 - ("horizontal" === l ? 0 : w._lineHeight / 2), g + ("vertical" === l ? g - k < m.point.y ? 0 : -k : (g - w._lineHeight / 2 < m.point.y ? k : 0) - w._lineHeight / 2)) : 0 <= q.indexOf("waterfall") ? e.lineTo(n + d / 2 - ("horizontal" === l ? 0 : w._lineHeight / 2), "vertical" === l ? 0 < t && g < m.point.y ? g : 0 > t && g - k > m.point.y ? g - k : m.point.y : 0 < t && g + k - w._lineHeight / 2 < m.point.y ? g + k - w._lineHeight / 2 : 0 > t && g - w._lineHeight / 2 > m.point.y ? g - w._lineHeight / 2 : m.point.y) : e.lineTo(n + d / 2 - ("horizontal" === l ? 0 : w._lineHeight / 2), g + ("vertical" === l ? g - k < m.point.y ? 0 : -k : (g + k < m.point.y ? k : 0) - w._lineHeight / 2)), 
                                e.stroke());
                            }
                        }
                        e = {
                            source: e,
                            dest: this.plotArea.ctx,
                            animationCallback: N.fadeInAnimation,
                            easingFunction: N.easing.easeInQuad,
                            animationBase: 0,
                            startTimePercent: .7
                        };
                        for (a = 0; a < this._indexLabels.length; a++) m = this._indexLabels[a], w = oa("indexLabelBackgroundColor", m.dataPoint, m.dataSeries), 
                        m.dataSeries.indexLabelBackgroundColor = p(w) ? v ? "transparent" : null : w;
                        return e;
                    };
                    l.prototype.renderLine = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var b = this._eventManager.ghostCtx;
                            c.save();
                            var f = this.plotArea;
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            for (var r, h = [], x = 0; x < a.dataSeriesIndexes.length; x++) {
                                var d = a.dataSeriesIndexes[x], k = this.data[d];
                                c.lineWidth = k.lineThickness;
                                var m = k.dataPoints, q = "solid";
                                if (c.setLineDash) {
                                    var n = H(k.nullDataLineDashType, k.lineThickness), g = (q = k.lineDashType, H(q, k.lineThickness));
                                    c.setLineDash(g);
                                }
                                var p = k.id;
                                this._eventManager.objectMap[p] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: d
                                };
                                p = Y(p);
                                b.strokeStyle = p;
                                b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
                                p = k._colorSet;
                                var w = p = k.lineColor = k.options.lineColor ? k.options.lineColor : p[0];
                                c.strokeStyle = p;
                                var l, u, y = !0, s = 0;
                                c.beginPath();
                                if (0 < m.length) {
                                    var E = !1;
                                    for (s = 0; s < m.length; s++) if (l = m[s].x.getTime ? m[s].x.getTime() : m[s].x, 
                                    !(l < a.axisX.dataInfo.viewPortMin || l > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !E))) if ("number" !== typeof m[s].y) 0 < s && !(k.connectNullData || E || y) && (c.stroke(), 
                                    v && b.stroke()), E = !0; else {
                                        l = a.axisX.convertValueToPixel(l);
                                        u = a.axisY.convertValueToPixel(m[s].y);
                                        var C = k.dataPointIds[s];
                                        this._eventManager.objectMap[C] = {
                                            id: C,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: d,
                                            dataPointIndex: s,
                                            x1: l,
                                            y1: u
                                        };
                                        y || E ? (!y && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || q === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), 
                                        c.beginPath(), c.moveTo(r.x, r.y), q = k.nullDataLineDashType, c.setLineDash(n)), 
                                        c.lineTo(l, u), v && b.lineTo(l, u)) : (c.beginPath(), c.moveTo(l, u), v && (b.beginPath(), 
                                        b.moveTo(l, u))), E = y = !1) : (c.lineTo(l, u), v && b.lineTo(l, u), 0 == s % 500 && (c.stroke(), 
                                        c.beginPath(), c.moveTo(l, u), v && (b.stroke(), b.beginPath(), b.moveTo(l, u))));
                                        r = {
                                            x: l,
                                            y: u
                                        };
                                        s < m.length - 1 && (w !== (m[s].lineColor || p) || q !== (m[s].lineDashType || k.lineDashType)) && (c.stroke(), 
                                        c.beginPath(), c.moveTo(l, u), w = m[s].lineColor || p, c.strokeStyle = w, c.setLineDash && (m[s].lineDashType ? (q = m[s].lineDashType, 
                                        c.setLineDash(H(q, k.lineThickness))) : (q = k.lineDashType, c.setLineDash(g))));
                                        if (0 !== m[s].markerSize && (0 < m[s].markerSize || 0 < k.markerSize)) {
                                            var A = k.getMarkerProperties(s, l, u, c);
                                            h.push(A);
                                            C = Y(C);
                                            v && h.push({
                                                x: l,
                                                y: u,
                                                ctx: b,
                                                type: A.type,
                                                size: A.size,
                                                color: C,
                                                borderColor: C,
                                                borderThickness: A.borderThickness
                                            });
                                        }
                                        (m[s].indexLabel || k.indexLabel || m[s].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "line",
                                            dataPoint: m[s],
                                            dataSeries: k,
                                            point: {
                                                x: l,
                                                y: u
                                            },
                                            direction: 0 > m[s].y === a.axisY.reversed ? 1 : -1,
                                            color: p
                                        });
                                    }
                                    c.stroke();
                                    v && b.stroke();
                                }
                            }
                            W.drawMarkers(h);
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), b.beginPath());
                            c.restore();
                            c.beginPath();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderStepLine = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var b = this._eventManager.ghostCtx;
                            c.save();
                            var f = this.plotArea;
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            for (var r, h = [], x = 0; x < a.dataSeriesIndexes.length; x++) {
                                var d = a.dataSeriesIndexes[x], k = this.data[d];
                                c.lineWidth = k.lineThickness;
                                var m = k.dataPoints, q = "solid";
                                if (c.setLineDash) {
                                    var n = H(k.nullDataLineDashType, k.lineThickness), g = (q = k.lineDashType, H(q, k.lineThickness));
                                    c.setLineDash(g);
                                }
                                var p = k.id;
                                this._eventManager.objectMap[p] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: d
                                };
                                p = Y(p);
                                b.strokeStyle = p;
                                b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
                                p = k._colorSet;
                                var w = p = k.lineColor = k.options.lineColor ? k.options.lineColor : p[0];
                                c.strokeStyle = p;
                                var z, u, l = !0, s = 0;
                                c.beginPath();
                                if (0 < m.length) {
                                    var E = !1;
                                    for (s = 0; s < m.length; s++) if (z = m[s].getTime ? m[s].x.getTime() : m[s].x, 
                                    !(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !E))) if ("number" !== typeof m[s].y) 0 < s && !(k.connectNullData || E || l) && (c.stroke(), 
                                    v && b.stroke()), E = !0; else {
                                        var C = u;
                                        z = a.axisX.convertValueToPixel(z);
                                        u = a.axisY.convertValueToPixel(m[s].y);
                                        var A = k.dataPointIds[s];
                                        this._eventManager.objectMap[A] = {
                                            id: A,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: d,
                                            dataPointIndex: s,
                                            x1: z,
                                            y1: u
                                        };
                                        l || E ? (!l && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || q === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), 
                                        c.beginPath(), c.moveTo(r.x, r.y), q = k.nullDataLineDashType, c.setLineDash(n)), 
                                        c.lineTo(z, C), c.lineTo(z, u), v && (b.lineTo(z, C), b.lineTo(z, u))) : (c.beginPath(), 
                                        c.moveTo(z, u), v && (b.beginPath(), b.moveTo(z, u))), E = l = !1) : (c.lineTo(z, C), 
                                        v && b.lineTo(z, C), c.lineTo(z, u), v && b.lineTo(z, u), 0 == s % 500 && (c.stroke(), 
                                        c.beginPath(), c.moveTo(z, u), v && (b.stroke(), b.beginPath(), b.moveTo(z, u))));
                                        r = {
                                            x: z,
                                            y: u
                                        };
                                        s < m.length - 1 && (w !== (m[s].lineColor || p) || q !== (m[s].lineDashType || k.lineDashType)) && (c.stroke(), 
                                        c.beginPath(), c.moveTo(z, u), w = m[s].lineColor || p, c.strokeStyle = w, c.setLineDash && (m[s].lineDashType ? (q = m[s].lineDashType, 
                                        c.setLineDash(H(q, k.lineThickness))) : (q = k.lineDashType, c.setLineDash(g))));
                                        0 !== m[s].markerSize && (0 < m[s].markerSize || 0 < k.markerSize) && (C = k.getMarkerProperties(s, z, u, c), 
                                        h.push(C), A = Y(A), v && h.push({
                                            x: z,
                                            y: u,
                                            ctx: b,
                                            type: C.type,
                                            size: C.size,
                                            color: A,
                                            borderColor: A,
                                            borderThickness: C.borderThickness
                                        }));
                                        (m[s].indexLabel || k.indexLabel || m[s].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "stepLine",
                                            dataPoint: m[s],
                                            dataSeries: k,
                                            point: {
                                                x: z,
                                                y: u
                                            },
                                            direction: 0 > m[s].y === a.axisY.reversed ? 1 : -1,
                                            color: p
                                        });
                                    }
                                    c.stroke();
                                    v && b.stroke();
                                }
                            }
                            W.drawMarkers(h);
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), b.beginPath());
                            c.restore();
                            c.beginPath();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderSpline = function(a) {
                        function e(a) {
                            a = t(a, 2);
                            if (0 < a.length) {
                                b.beginPath();
                                v && f.beginPath();
                                b.moveTo(a[0].x, a[0].y);
                                a[0].newStrokeStyle && (b.strokeStyle = a[0].newStrokeStyle);
                                a[0].newLineDashArray && b.setLineDash(a[0].newLineDashArray);
                                v && f.moveTo(a[0].x, a[0].y);
                                for (var c = 0; c < a.length - 3; c += 3) if (b.bezierCurveTo(a[c + 1].x, a[c + 1].y, a[c + 2].x, a[c + 2].y, a[c + 3].x, a[c + 3].y), 
                                v && f.bezierCurveTo(a[c + 1].x, a[c + 1].y, a[c + 2].x, a[c + 2].y, a[c + 3].x, a[c + 3].y), 
                                0 < c && 0 === c % 3e3 || a[c + 3].newStrokeStyle || a[c + 3].newLineDashArray) b.stroke(), 
                                b.beginPath(), b.moveTo(a[c + 3].x, a[c + 3].y), a[c + 3].newStrokeStyle && (b.strokeStyle = a[c + 3].newStrokeStyle), 
                                a[c + 3].newLineDashArray && b.setLineDash(a[c + 3].newLineDashArray), v && (f.stroke(), 
                                f.beginPath(), f.moveTo(a[c + 3].x, a[c + 3].y));
                                b.stroke();
                                v && f.stroke();
                            }
                        }
                        var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var f = this._eventManager.ghostCtx;
                            b.save();
                            var h = this.plotArea;
                            b.beginPath();
                            b.rect(h.x1, h.y1, h.width, h.height);
                            b.clip();
                            for (var r = [], x = 0; x < a.dataSeriesIndexes.length; x++) {
                                var d = a.dataSeriesIndexes[x], k = this.data[d];
                                b.lineWidth = k.lineThickness;
                                var m = k.dataPoints, q = "solid";
                                if (b.setLineDash) {
                                    var n = H(k.nullDataLineDashType, k.lineThickness), g = (q = k.lineDashType, H(q, k.lineThickness));
                                    b.setLineDash(g);
                                }
                                var p = k.id;
                                this._eventManager.objectMap[p] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: d
                                };
                                p = Y(p);
                                f.strokeStyle = p;
                                f.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
                                p = k._colorSet;
                                var w = p = k.lineColor = k.options.lineColor ? k.options.lineColor : p[0];
                                b.strokeStyle = p;
                                var s, z, l = 0, u = [];
                                b.beginPath();
                                if (0 < m.length) for (z = !1, l = 0; l < m.length; l++) if (s = m[l].getTime ? m[l].x.getTime() : m[l].x, 
                                !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !z))) if ("number" !== typeof m[l].y) 0 < l && !z && (k.connectNullData ? b.setLineDash && 0 < u.length && (k.options.nullDataLineDashType || !m[l - 1].lineDashType) && (u[u.length - 1].newLineDashArray = n, 
                                q = k.nullDataLineDashType) : (e(u), u = [])), z = !0; else {
                                    s = a.axisX.convertValueToPixel(s);
                                    z = a.axisY.convertValueToPixel(m[l].y);
                                    var E = k.dataPointIds[l];
                                    this._eventManager.objectMap[E] = {
                                        id: E,
                                        objectType: "dataPoint",
                                        dataSeriesIndex: d,
                                        dataPointIndex: l,
                                        x1: s,
                                        y1: z
                                    };
                                    u[u.length] = {
                                        x: s,
                                        y: z
                                    };
                                    l < m.length - 1 && (w !== (m[l].lineColor || p) || q !== (m[l].lineDashType || k.lineDashType)) && (w = m[l].lineColor || p, 
                                    u[u.length - 1].newStrokeStyle = w, b.setLineDash && (m[l].lineDashType ? (q = m[l].lineDashType, 
                                    u[u.length - 1].newLineDashArray = H(q, k.lineThickness)) : (q = k.lineDashType, 
                                    u[u.length - 1].newLineDashArray = g)));
                                    if (0 !== m[l].markerSize && (0 < m[l].markerSize || 0 < k.markerSize)) {
                                        var C = k.getMarkerProperties(l, s, z, b);
                                        r.push(C);
                                        E = Y(E);
                                        v && r.push({
                                            x: s,
                                            y: z,
                                            ctx: f,
                                            type: C.type,
                                            size: C.size,
                                            color: E,
                                            borderColor: E,
                                            borderThickness: C.borderThickness
                                        });
                                    }
                                    (m[l].indexLabel || k.indexLabel || m[l].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "spline",
                                        dataPoint: m[l],
                                        dataSeries: k,
                                        point: {
                                            x: s,
                                            y: z
                                        },
                                        direction: 0 > m[l].y === a.axisY.reversed ? 1 : -1,
                                        color: p
                                    });
                                    z = !1;
                                }
                                e(u);
                            }
                            W.drawMarkers(r);
                            v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            b.clearRect(h.x1, h.y1, h.width, h.height), f.beginPath());
                            b.restore();
                            b.beginPath();
                            return {
                                source: c,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderColumn = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var r, x, d, b = null, f = this.plotArea, h = 0, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = (h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, .9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0), q = a.axisX.dataInfo.minDiff;
                            isFinite(q) || (q = .3 * Math.abs(a.axisX.range));
                            q = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.width * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
                            this.dataPointMaxWidth && h > m && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, m));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && m < h && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, h));
                            q < h && (q = h);
                            q > m && (q = m);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (m = 0; m < a.dataSeriesIndexes.length; m++) {
                                var n = a.dataSeriesIndexes[m], g = this.data[n], p = g.dataPoints;
                                if (0 < p.length) {
                                    var l = 5 < q && g.bevelEnabled ? !0 : !1;
                                    for (h = 0; h < p.length; h++) if (p[h].getTime ? d = p[h].x.getTime() : d = p[h].x, 
                                    !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && "number" === typeof p[h].y) {
                                        r = a.axisX.convertValueToPixel(d);
                                        x = a.axisY.convertValueToPixel(p[h].y);
                                        r = a.axisX.reversed ? r + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + m) * q << 0 : r - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + m) * q << 0;
                                        var s, y = a.axisX.reversed ? r - q << 0 : r + q << 0;
                                        0 <= p[h].y ? s = k : (s = x, x = k);
                                        x > s && (b = x, x = s, s = b);
                                        b = p[h].color ? p[h].color : g._colorSet[h % g._colorSet.length];
                                        aa(c, a.axisX.reversed ? y : r, x, a.axisX.reversed ? r : y, s, b, 0, null, l && (a.axisY.reversed ? 0 > p[h].y : 0 <= p[h].y), (a.axisY.reversed ? 0 <= p[h].y : 0 > p[h].y) && l, !1, !1, g.fillOpacity);
                                        b = g.dataPointIds[h];
                                        this._eventManager.objectMap[b] = {
                                            id: b,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: n,
                                            dataPointIndex: h,
                                            x1: r,
                                            y1: x,
                                            x2: y,
                                            y2: s
                                        };
                                        b = Y(b);
                                        v && aa(this._eventManager.ghostCtx, a.axisX.reversed ? y : r, x, a.axisX.reversed ? r : y, s, b, 0, null, !1, !1, !1, !1);
                                        (p[h].indexLabel || g.indexLabel || p[h].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "column",
                                            dataPoint: p[h],
                                            dataSeries: g,
                                            point: {
                                                x: r + (y - r) / 2,
                                                y: 0 > p[h].y === a.axisY.reversed ? x : s
                                            },
                                            direction: 0 > p[h].y === a.axisY.reversed ? 1 : -1,
                                            bounds: {
                                                x1: r,
                                                y1: Math.min(x, s),
                                                x2: y,
                                                y2: Math.max(x, s)
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.yScaleAnimation,
                                easingFunction: N.easing.easeOutQuart,
                                animationBase: k < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : k > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : k
                            };
                        }
                    };
                    l.prototype.renderStackedColumn = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var m, q, b = null, f = this.plotArea, h = [], r = [], x = [], d = [], k = 0, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = (k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0), p = a.axisX.dataInfo.minDiff;
                            isFinite(p) || (p = .3 * Math.abs(a.axisX.range));
                            p = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
                            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, g));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, k));
                            p < k && (p = k);
                            p > g && (p = g);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
                                var l = a.dataSeriesIndexes[g], y = this.data[l], s = y.dataPoints;
                                if (0 < s.length) {
                                    var z = 5 < p && y.bevelEnabled ? !0 : !1;
                                    c.strokeStyle = "#4572A7 ";
                                    for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, 
                                    !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[k].y) {
                                        m = a.axisX.convertValueToPixel(b);
                                        m = m - a.plotType.plotUnits.length * p / 2 + a.index * p << 0;
                                        var E, u = m + p << 0;
                                        if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) x[b] = s[k].y + (x[b] ? x[b] : 0), 
                                        0 < x[b] && (q = a.axisY.convertValueToPixel(x[b]), E = "undefined" !== typeof h[b] ? h[b] : n, 
                                        h[b] = q); else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) d[b] = s[k].y + (d[b] ? d[b] : 0), 
                                        E = a.axisY.convertValueToPixel(d[b]), q = "undefined" !== typeof r[b] ? r[b] : n, 
                                        r[b] = E; else if (q = a.axisY.convertValueToPixel(s[k].y), 0 <= s[k].y) {
                                            var C = "undefined" !== typeof h[b] ? h[b] : 0;
                                            q -= C;
                                            E = n - C;
                                            h[b] = C + (E - q);
                                        } else C = r[b] ? r[b] : 0, E = q + C, q = n + C, r[b] = C + (E - q);
                                        b = s[k].color ? s[k].color : y._colorSet[k % y._colorSet.length];
                                        aa(c, m, a.axisY.reversed ? E : q, u, a.axisY.reversed ? q : E, b, 0, null, z && (a.axisY.reversed ? 0 > s[k].y : 0 <= s[k].y), (a.axisY.reversed ? 0 <= s[k].y : 0 > s[k].y) && z, !1, !1, y.fillOpacity);
                                        b = y.dataPointIds[k];
                                        this._eventManager.objectMap[b] = {
                                            id: b,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: l,
                                            dataPointIndex: k,
                                            x1: m,
                                            y1: q,
                                            x2: u,
                                            y2: E
                                        };
                                        b = Y(b);
                                        v && aa(this._eventManager.ghostCtx, m, q, u, E, b, 0, null, !1, !1, !1, !1);
                                        (s[k].indexLabel || y.indexLabel || s[k].indexLabelFormatter || y.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "stackedColumn",
                                            dataPoint: s[k],
                                            dataSeries: y,
                                            point: {
                                                x: m + (u - m) / 2,
                                                y: 0 <= s[k].y ? q : E
                                            },
                                            direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,
                                            bounds: {
                                                x1: m,
                                                y1: Math.min(q, E),
                                                x2: u,
                                                y2: Math.max(q, E)
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.yScaleAnimation,
                                easingFunction: N.easing.easeOutQuart,
                                animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n
                            };
                        }
                    };
                    l.prototype.renderStackedColumn100 = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var m, q, b = null, f = this.plotArea, h = [], r = [], x = [], d = [], k = 0, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = (k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0), p = a.axisX.dataInfo.minDiff;
                            isFinite(p) || (p = .3 * Math.abs(a.axisX.range));
                            p = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
                            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, g));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, k));
                            p < k && (p = k);
                            p > g && (p = g);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
                                var l = a.dataSeriesIndexes[g], y = this.data[l], s = y.dataPoints;
                                if (0 < s.length) {
                                    var z = 5 < p && y.bevelEnabled ? !0 : !1;
                                    for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, 
                                    !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[k].y) {
                                        m = a.axisX.convertValueToPixel(b);
                                        q = 0 !== a.dataPointYSums[b] ? 100 * (s[k].y / a.dataPointYSums[b]) : 0;
                                        m = m - a.plotType.plotUnits.length * p / 2 + a.index * p << 0;
                                        var E, u = m + p << 0;
                                        if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) {
                                            x[b] = q + ("undefined" !== typeof x[b] ? x[b] : 0);
                                            if (0 >= x[b]) continue;
                                            q = a.axisY.convertValueToPixel(x[b]);
                                            E = h[b] ? h[b] : n;
                                            h[b] = q;
                                        } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) d[b] = q + ("undefined" !== typeof d[b] ? d[b] : 0), 
                                        E = a.axisY.convertValueToPixel(d[b]), q = r[b] ? r[b] : n, r[b] = E; else if (q = a.axisY.convertValueToPixel(q), 
                                        0 <= s[k].y) {
                                            var C = "undefined" !== typeof h[b] ? h[b] : 0;
                                            q -= C;
                                            E = n - C;
                                            a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.y1 - q) && (q = f.y1);
                                            h[b] = C + (E - q);
                                        } else C = "undefined" !== typeof r[b] ? r[b] : 0, E = q + C, q = n + C, a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.y2 - E) && (E = f.y2), 
                                        r[b] = C + (E - q);
                                        b = s[k].color ? s[k].color : y._colorSet[k % y._colorSet.length];
                                        aa(c, m, a.axisY.reversed ? E : q, u, a.axisY.reversed ? q : E, b, 0, null, z && (a.axisY.reversed ? 0 > s[k].y : 0 <= s[k].y), (a.axisY.reversed ? 0 <= s[k].y : 0 > s[k].y) && z, !1, !1, y.fillOpacity);
                                        b = y.dataPointIds[k];
                                        this._eventManager.objectMap[b] = {
                                            id: b,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: l,
                                            dataPointIndex: k,
                                            x1: m,
                                            y1: q,
                                            x2: u,
                                            y2: E
                                        };
                                        b = Y(b);
                                        v && aa(this._eventManager.ghostCtx, m, q, u, E, b, 0, null, !1, !1, !1, !1);
                                        (s[k].indexLabel || y.indexLabel || s[k].indexLabelFormatter || y.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "stackedColumn100",
                                            dataPoint: s[k],
                                            dataSeries: y,
                                            point: {
                                                x: m + (u - m) / 2,
                                                y: 0 <= s[k].y ? q : E
                                            },
                                            direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,
                                            bounds: {
                                                x1: m,
                                                y1: Math.min(q, E),
                                                x2: u,
                                                y2: Math.max(q, E)
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.yScaleAnimation,
                                easingFunction: N.easing.easeOutQuart,
                                animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n
                            };
                        }
                    };
                    l.prototype.renderBar = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var r, x, d, b = null, f = this.plotArea, h = 0, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m = (h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, .9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0), q = a.axisX.dataInfo.minDiff;
                            isFinite(q) || (q = .3 * Math.abs(a.axisX.range));
                            q = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.height * (a.axisX.logarithmic ? Math.log(q) / Math.log(a.axisX.range) : Math.abs(q) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
                            this.dataPointMaxWidth && h > m && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, m));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && m < h && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, h));
                            q < h && (q = h);
                            q > m && (q = m);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (m = 0; m < a.dataSeriesIndexes.length; m++) {
                                var n = a.dataSeriesIndexes[m], g = this.data[n], p = g.dataPoints;
                                if (0 < p.length) {
                                    var l = 5 < q && g.bevelEnabled ? !0 : !1;
                                    c.strokeStyle = "#4572A7 ";
                                    for (h = 0; h < p.length; h++) if (p[h].getTime ? d = p[h].x.getTime() : d = p[h].x, 
                                    !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && "number" === typeof p[h].y) {
                                        x = a.axisX.convertValueToPixel(d);
                                        r = a.axisY.convertValueToPixel(p[h].y);
                                        x = a.axisX.reversed ? x + a.plotType.totalDataSeries * q / 2 - (a.previousDataSeriesCount + m) * q << 0 : x - a.plotType.totalDataSeries * q / 2 + (a.previousDataSeriesCount + m) * q << 0;
                                        var s, y = a.axisX.reversed ? x - q << 0 : x + q << 0;
                                        0 <= p[h].y ? s = k : (s = r, r = k);
                                        b = p[h].color ? p[h].color : g._colorSet[h % g._colorSet.length];
                                        aa(c, a.axisY.reversed ? r : s, a.axisX.reversed ? y : x, a.axisY.reversed ? s : r, a.axisX.reversed ? x : y, b, 0, null, l, !1, !1, !1, g.fillOpacity);
                                        b = g.dataPointIds[h];
                                        this._eventManager.objectMap[b] = {
                                            id: b,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: n,
                                            dataPointIndex: h,
                                            x1: s,
                                            y1: x,
                                            x2: r,
                                            y2: y
                                        };
                                        b = Y(b);
                                        v && aa(this._eventManager.ghostCtx, s, a.axisX.reversed ? y : x, r, a.axisX.reversed ? x : y, b, 0, null, !1, !1, !1, !1);
                                        (p[h].indexLabel || g.indexLabel || p[h].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "bar",
                                            dataPoint: p[h],
                                            dataSeries: g,
                                            point: {
                                                x: 0 <= p[h].y ? r : s,
                                                y: x + (y - x) / 2
                                            },
                                            direction: 0 > p[h].y === a.axisY.reversed ? 1 : -1,
                                            bounds: {
                                                x1: Math.min(s, r),
                                                y1: x,
                                                x2: Math.max(s, r),
                                                y2: y
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xScaleAnimation,
                                easingFunction: N.easing.easeOutQuart,
                                animationBase: k < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : k > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : k
                            };
                        }
                    };
                    l.prototype.renderStackedBar = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var m, q, b = null, f = this.plotArea, h = [], r = [], d = [], p = [], k = 0, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = (k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0), l = a.axisX.dataInfo.minDiff;
                            isFinite(l) || (l = .3 * Math.abs(a.axisX.range));
                            l = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.height * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
                            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, g));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, k));
                            l < k && (l = k);
                            l > g && (l = g);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
                                var w = a.dataSeriesIndexes[g], y = this.data[w], s = y.dataPoints;
                                if (0 < s.length) {
                                    var z = 5 < l && y.bevelEnabled ? !0 : !1;
                                    c.strokeStyle = "#4572A7 ";
                                    for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, 
                                    !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[k].y) {
                                        q = a.axisX.convertValueToPixel(b);
                                        q = q - a.plotType.plotUnits.length * l / 2 + a.index * l << 0;
                                        var E, u = q + l << 0;
                                        if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) d[b] = s[k].y + (d[b] ? d[b] : 0), 
                                        0 < d[b] && (E = h[b] ? h[b] : n, h[b] = m = a.axisY.convertValueToPixel(d[b])); else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) p[b] = s[k].y + (p[b] ? p[b] : 0), 
                                        m = r[b] ? r[b] : n, r[b] = E = a.axisY.convertValueToPixel(p[b]); else if (m = a.axisY.convertValueToPixel(s[k].y), 
                                        0 <= s[k].y) {
                                            var C = h[b] ? h[b] : 0;
                                            E = n + C;
                                            m += C;
                                            h[b] = C + (m - E);
                                        } else C = r[b] ? r[b] : 0, E = m - C, m = n - C, r[b] = C + (m - E);
                                        b = s[k].color ? s[k].color : y._colorSet[k % y._colorSet.length];
                                        aa(c, a.axisY.reversed ? m : E, q, a.axisY.reversed ? E : m, u, b, 0, null, z, !1, !1, !1, y.fillOpacity);
                                        b = y.dataPointIds[k];
                                        this._eventManager.objectMap[b] = {
                                            id: b,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: w,
                                            dataPointIndex: k,
                                            x1: E,
                                            y1: q,
                                            x2: m,
                                            y2: u
                                        };
                                        b = Y(b);
                                        v && aa(this._eventManager.ghostCtx, E, q, m, u, b, 0, null, !1, !1, !1, !1);
                                        (s[k].indexLabel || y.indexLabel || s[k].indexLabelFormatter || y.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "stackedBar",
                                            dataPoint: s[k],
                                            dataSeries: y,
                                            point: {
                                                x: 0 <= s[k].y ? m : E,
                                                y: q + (u - q) / 2
                                            },
                                            direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,
                                            bounds: {
                                                x1: Math.min(E, m),
                                                y1: q,
                                                x2: Math.max(E, m),
                                                y2: u
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xScaleAnimation,
                                easingFunction: N.easing.easeOutQuart,
                                animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n
                            };
                        }
                    };
                    l.prototype.renderStackedBar100 = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var m, q, b = null, f = this.plotArea, h = [], r = [], d = [], p = [], k = 0, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), g = (k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0), l = a.axisX.dataInfo.minDiff;
                            isFinite(l) || (l = .3 * Math.abs(a.axisX.range));
                            l = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.height * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
                            this.dataPointMaxWidth && k > g && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, g));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && g < k && (g = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, k));
                            l < k && (l = k);
                            l > g && (l = g);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (g = 0; g < a.dataSeriesIndexes.length; g++) {
                                var w = a.dataSeriesIndexes[g], y = this.data[w], s = y.dataPoints;
                                if (0 < s.length) {
                                    var z = 5 < l && y.bevelEnabled ? !0 : !1;
                                    c.strokeStyle = "#4572A7 ";
                                    for (k = 0; k < s.length; k++) if (b = s[k].x.getTime ? s[k].x.getTime() : s[k].x, 
                                    !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof s[k].y) {
                                        q = a.axisX.convertValueToPixel(b);
                                        var u;
                                        u = 0 !== a.dataPointYSums[b] ? 100 * (s[k].y / a.dataPointYSums[b]) : 0;
                                        q = q - a.plotType.plotUnits.length * l / 2 + a.index * l << 0;
                                        var E = q + l << 0;
                                        if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < s[k].y) {
                                            d[b] = u + (d[b] ? d[b] : 0);
                                            if (0 >= d[b]) continue;
                                            u = h[b] ? h[b] : n;
                                            h[b] = m = a.axisY.convertValueToPixel(d[b]);
                                        } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= s[k].y) p[b] = u + (p[b] ? p[b] : 0), 
                                        m = r[b] ? r[b] : n, r[b] = u = a.axisY.convertValueToPixel(p[b]); else if (m = a.axisY.convertValueToPixel(u), 
                                        0 <= s[k].y) {
                                            var C = h[b] ? h[b] : 0;
                                            u = n + C;
                                            m += C;
                                            a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.x2 - m) && (m = f.x2);
                                            h[b] = C + (m - u);
                                        } else C = r[b] ? r[b] : 0, u = m - C, m = n - C, a.dataSeriesIndexes.length - 1 === g && 1 >= Math.abs(f.x1 - u) && (u = f.x1), 
                                        r[b] = C + (m - u);
                                        b = s[k].color ? s[k].color : y._colorSet[k % y._colorSet.length];
                                        aa(c, a.axisY.reversed ? m : u, q, a.axisY.reversed ? u : m, E, b, 0, null, z, !1, !1, !1, y.fillOpacity);
                                        b = y.dataPointIds[k];
                                        this._eventManager.objectMap[b] = {
                                            id: b,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: w,
                                            dataPointIndex: k,
                                            x1: u,
                                            y1: q,
                                            x2: m,
                                            y2: E
                                        };
                                        b = Y(b);
                                        v && aa(this._eventManager.ghostCtx, u, q, m, E, b, 0, null, !1, !1, !1, !1);
                                        (s[k].indexLabel || y.indexLabel || s[k].indexLabelFormatter || y.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "stackedBar100",
                                            dataPoint: s[k],
                                            dataSeries: y,
                                            point: {
                                                x: 0 <= s[k].y ? m : u,
                                                y: q + (E - q) / 2
                                            },
                                            direction: 0 > s[k].y === a.axisY.reversed ? 1 : -1,
                                            bounds: {
                                                x1: Math.min(u, m),
                                                y1: q,
                                                x2: Math.max(u, m),
                                                y2: E
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xScaleAnimation,
                                easingFunction: N.easing.easeOutQuart,
                                animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n
                            };
                        }
                    };
                    l.prototype.renderArea = function(a) {
                        var e, c;
                        function b() {
                            C && (0 < g.lineThickness && h.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? E = u : 0 > a.axisY.viewportMaximum ? E = d.y1 : 0 < a.axisY.viewportMinimum && (E = u), 
                            h.lineTo(y, E), h.lineTo(C.x, E), h.closePath(), h.globalAlpha = g.fillOpacity, 
                            h.fill(), h.globalAlpha = 1, v && (r.lineTo(y, E), r.lineTo(C.x, E), r.closePath(), 
                            r.fill()), h.beginPath(), h.moveTo(y, s), r.beginPath(), r.moveTo(y, s), C = {
                                x: y,
                                y: s
                            });
                        }
                        var f = a.targetCanvasCtx || this.plotArea.ctx, h = v ? this._preRenderCtx : f;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var m, r = this._eventManager.ghostCtx, d = a.axisY.lineCoordinates, p = [], k = this.plotArea;
                            h.save();
                            v && r.save();
                            h.beginPath();
                            h.rect(k.x1, k.y1, k.width, k.height);
                            h.clip();
                            v && (r.beginPath(), r.rect(k.x1, k.y1, k.width, k.height), r.clip());
                            for (var q = 0; q < a.dataSeriesIndexes.length; q++) {
                                var n = a.dataSeriesIndexes[q], g = this.data[n], l = g.dataPoints;
                                p = g.id;
                                this._eventManager.objectMap[p] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: n
                                };
                                p = Y(p);
                                r.fillStyle = p;
                                p = [];
                                e = !0;
                                var y, s, z, E, w = 0, u = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), C = null;
                                if (0 < l.length) {
                                    var A = g._colorSet[w % g._colorSet.length], t = g.lineColor = g.options.lineColor || A, B = t;
                                    h.fillStyle = A;
                                    h.strokeStyle = t;
                                    h.lineWidth = g.lineThickness;
                                    c = "solid";
                                    if (h.setLineDash) {
                                        var L = H(g.nullDataLineDashType, g.lineThickness);
                                        c = g.lineDashType;
                                        var T = H(c, g.lineThickness);
                                        h.setLineDash(T);
                                    }
                                    for (var ga = !0; w < l.length; w++) if (z = l[w].x.getTime ? l[w].x.getTime() : l[w].x, 
                                    !(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !ga))) if ("number" !== typeof l[w].y) g.connectNullData || ga || e || b(), 
                                    ga = !0; else {
                                        y = a.axisX.convertValueToPixel(z);
                                        s = a.axisY.convertValueToPixel(l[w].y);
                                        e || ga ? (!e && g.connectNullData ? (h.setLineDash && (g.options.nullDataLineDashType || c === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (e = y, 
                                        c = s, y = m.x, s = m.y, b(), h.moveTo(m.x, m.y), y = e, s = c, C = m, c = g.nullDataLineDashType, 
                                        h.setLineDash(L)), h.lineTo(y, s), v && r.lineTo(y, s)) : (h.beginPath(), h.moveTo(y, s), 
                                        v && (r.beginPath(), r.moveTo(y, s)), C = {
                                            x: y,
                                            y: s
                                        }), ga = e = !1) : (h.lineTo(y, s), v && r.lineTo(y, s), 0 == w % 250 && b());
                                        m = {
                                            x: y,
                                            y: s
                                        };
                                        w < l.length - 1 && (B !== (l[w].lineColor || t) || c !== (l[w].lineDashType || g.lineDashType)) && (b(), 
                                        B = l[w].lineColor || t, h.strokeStyle = B, h.setLineDash && (l[w].lineDashType ? (c = l[w].lineDashType, 
                                        h.setLineDash(H(c, g.lineThickness))) : (c = g.lineDashType, h.setLineDash(T))));
                                        var ba = g.dataPointIds[w];
                                        this._eventManager.objectMap[ba] = {
                                            id: ba,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: n,
                                            dataPointIndex: w,
                                            x1: y,
                                            y1: s
                                        };
                                        0 !== l[w].markerSize && (0 < l[w].markerSize || 0 < g.markerSize) && (z = g.getMarkerProperties(w, y, s, h), 
                                        p.push(z), ba = Y(ba), v && p.push({
                                            x: y,
                                            y: s,
                                            ctx: r,
                                            type: z.type,
                                            size: z.size,
                                            color: ba,
                                            borderColor: ba,
                                            borderThickness: z.borderThickness
                                        }));
                                        (l[w].indexLabel || g.indexLabel || l[w].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "area",
                                            dataPoint: l[w],
                                            dataSeries: g,
                                            point: {
                                                x: y,
                                                y: s
                                            },
                                            direction: 0 > l[w].y === a.axisY.reversed ? 1 : -1,
                                            color: A
                                        });
                                    }
                                    b();
                                    W.drawMarkers(p);
                                }
                            }
                            v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), h.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && h.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && h.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            h.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());
                            h.restore();
                            return {
                                source: f,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderSplineArea = function(a) {
                        function e() {
                            var c = t(z, 2);
                            if (0 < c.length) {
                                if (0 < m.lineThickness) {
                                    b.beginPath();
                                    b.moveTo(c[0].x, c[0].y);
                                    c[0].newStrokeStyle && (b.strokeStyle = c[0].newStrokeStyle);
                                    c[0].newLineDashArray && b.setLineDash(c[0].newLineDashArray);
                                    for (var g = 0; g < c.length - 3; g += 3) if (b.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y), 
                                    v && f.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y), 
                                    c[g + 3].newStrokeStyle || c[g + 3].newLineDashArray) b.stroke(), b.beginPath(), 
                                    b.moveTo(c[g + 3].x, c[g + 3].y), c[g + 3].newStrokeStyle && (b.strokeStyle = c[g + 3].newStrokeStyle), 
                                    c[g + 3].newLineDashArray && b.setLineDash(c[g + 3].newLineDashArray);
                                    b.stroke();
                                }
                                b.beginPath();
                                b.moveTo(c[0].x, c[0].y);
                                v && (f.beginPath(), f.moveTo(c[0].x, c[0].y));
                                for (g = 0; g < c.length - 3; g += 3) b.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y), 
                                v && f.bezierCurveTo(c[g + 1].x, c[g + 1].y, c[g + 2].x, c[g + 2].y, c[g + 3].x, c[g + 3].y);
                                a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? y = w : 0 > a.axisY.viewportMaximum ? y = h.y1 : 0 < a.axisY.viewportMinimum && (y = w);
                                s = {
                                    x: c[0].x,
                                    y: c[0].y
                                };
                                b.lineTo(c[c.length - 1].x, y);
                                b.lineTo(s.x, y);
                                b.closePath();
                                b.globalAlpha = m.fillOpacity;
                                b.fill();
                                b.globalAlpha = 1;
                                v && (f.lineTo(c[c.length - 1].x, y), f.lineTo(s.x, y), f.closePath(), f.fill());
                            }
                        }
                        var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var f = this._eventManager.ghostCtx, h = a.axisY.lineCoordinates, r = [], d = this.plotArea;
                            b.save();
                            v && f.save();
                            b.beginPath();
                            b.rect(d.x1, d.y1, d.width, d.height);
                            b.clip();
                            v && (f.beginPath(), f.rect(d.x1, d.y1, d.width, d.height), f.clip());
                            for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
                                var k = a.dataSeriesIndexes[p], m = this.data[k], q = m.dataPoints;
                                r = m.id;
                                this._eventManager.objectMap[r] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: k
                                };
                                r = Y(r);
                                f.fillStyle = r;
                                r = [];
                                var g, l, y, n = 0, w = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), s = null, z = [];
                                if (0 < q.length) {
                                    var u = m._colorSet[n % m._colorSet.length], E = m.lineColor = m.options.lineColor || u, C = E;
                                    b.fillStyle = u;
                                    b.strokeStyle = E;
                                    b.lineWidth = m.lineThickness;
                                    var A = "solid";
                                    if (b.setLineDash) {
                                        var B = H(m.nullDataLineDashType, m.lineThickness), D = (A = m.lineDashType, H(A, m.lineThickness));
                                        b.setLineDash(D);
                                    }
                                    for (l = !1; n < q.length; n++) if (g = q[n].x.getTime ? q[n].x.getTime() : q[n].x, 
                                    !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !l))) if ("number" !== typeof q[n].y) 0 < n && !l && (m.connectNullData ? b.setLineDash && 0 < z.length && (m.options.nullDataLineDashType || !q[n - 1].lineDashType) && (z[z.length - 1].newLineDashArray = B, 
                                    A = m.nullDataLineDashType) : (e(), z = [])), l = !0; else {
                                        g = a.axisX.convertValueToPixel(g);
                                        l = a.axisY.convertValueToPixel(q[n].y);
                                        var L = m.dataPointIds[n];
                                        this._eventManager.objectMap[L] = {
                                            id: L,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: k,
                                            dataPointIndex: n,
                                            x1: g,
                                            y1: l
                                        };
                                        z[z.length] = {
                                            x: g,
                                            y: l
                                        };
                                        n < q.length - 1 && (C !== (q[n].lineColor || E) || A !== (q[n].lineDashType || m.lineDashType)) && (C = q[n].lineColor || E, 
                                        z[z.length - 1].newStrokeStyle = C, b.setLineDash && (q[n].lineDashType ? (A = q[n].lineDashType, 
                                        z[z.length - 1].newLineDashArray = H(A, m.lineThickness)) : (A = m.lineDashType, 
                                        z[z.length - 1].newLineDashArray = D)));
                                        if (0 !== q[n].markerSize && (0 < q[n].markerSize || 0 < m.markerSize)) {
                                            var T = m.getMarkerProperties(n, g, l, b);
                                            r.push(T);
                                            L = Y(L);
                                            v && r.push({
                                                x: g,
                                                y: l,
                                                ctx: f,
                                                type: T.type,
                                                size: T.size,
                                                color: L,
                                                borderColor: L,
                                                borderThickness: T.borderThickness
                                            });
                                        }
                                        (q[n].indexLabel || m.indexLabel || q[n].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "splineArea",
                                            dataPoint: q[n],
                                            dataSeries: m,
                                            point: {
                                                x: g,
                                                y: l
                                            },
                                            direction: 0 > q[n].y === a.axisY.reversed ? 1 : -1,
                                            color: u
                                        });
                                        l = !1;
                                    }
                                    e();
                                    W.drawMarkers(r);
                                }
                            }
                            v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            b.clearRect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.restore());
                            b.restore();
                            return {
                                source: c,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderStepArea = function(a) {
                        var e, c;
                        function b() {
                            C && (0 < g.lineThickness && h.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? E = u : 0 > a.axisY.viewportMaximum ? E = d.y1 : 0 < a.axisY.viewportMinimum && (E = u), 
                            h.lineTo(y, E), h.lineTo(C.x, E), h.closePath(), h.globalAlpha = g.fillOpacity, 
                            h.fill(), h.globalAlpha = 1, v && (r.lineTo(y, E), r.lineTo(C.x, E), r.closePath(), 
                            r.fill()), h.beginPath(), h.moveTo(y, s), r.beginPath(), r.moveTo(y, s), C = {
                                x: y,
                                y: s
                            });
                        }
                        var f = a.targetCanvasCtx || this.plotArea.ctx, h = v ? this._preRenderCtx : f;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var m, r = this._eventManager.ghostCtx, d = a.axisY.lineCoordinates, p = [], k = this.plotArea;
                            h.save();
                            v && r.save();
                            h.beginPath();
                            h.rect(k.x1, k.y1, k.width, k.height);
                            h.clip();
                            v && (r.beginPath(), r.rect(k.x1, k.y1, k.width, k.height), r.clip());
                            for (var q = 0; q < a.dataSeriesIndexes.length; q++) {
                                var n = a.dataSeriesIndexes[q], g = this.data[n], l = g.dataPoints;
                                p = g.id;
                                this._eventManager.objectMap[p] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: n
                                };
                                p = Y(p);
                                r.fillStyle = p;
                                p = [];
                                e = !0;
                                var y, s, z, E, w = 0, u = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), C = null;
                                c = !1;
                                if (0 < l.length) {
                                    var A = g._colorSet[w % g._colorSet.length], t = g.lineColor = g.options.lineColor || A, B = t;
                                    h.fillStyle = A;
                                    h.strokeStyle = t;
                                    h.lineWidth = g.lineThickness;
                                    var L = "solid";
                                    if (h.setLineDash) {
                                        var T = H(g.nullDataLineDashType, g.lineThickness), D = (L = g.lineDashType, H(L, g.lineThickness));
                                        h.setLineDash(D);
                                    }
                                    for (;w < l.length; w++) if (z = l[w].x.getTime ? l[w].x.getTime() : l[w].x, !(z < a.axisX.dataInfo.viewPortMin || z > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !c))) {
                                        var ba = s;
                                        "number" !== typeof l[w].y ? (g.connectNullData || c || e || b(), c = !0) : (y = a.axisX.convertValueToPixel(z), 
                                        s = a.axisY.convertValueToPixel(l[w].y), e || c ? (!e && g.connectNullData ? (h.setLineDash && (g.options.nullDataLineDashType || L === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (e = y, 
                                        c = s, y = m.x, s = m.y, b(), h.moveTo(m.x, m.y), y = e, s = c, C = m, L = g.nullDataLineDashType, 
                                        h.setLineDash(T)), h.lineTo(y, ba), h.lineTo(y, s), v && (r.lineTo(y, ba), r.lineTo(y, s))) : (h.beginPath(), 
                                        h.moveTo(y, s), v && (r.beginPath(), r.moveTo(y, s)), C = {
                                            x: y,
                                            y: s
                                        }), c = e = !1) : (h.lineTo(y, ba), v && r.lineTo(y, ba), h.lineTo(y, s), v && r.lineTo(y, s), 
                                        0 == w % 250 && b()), m = {
                                            x: y,
                                            y: s
                                        }, w < l.length - 1 && (B !== (l[w].lineColor || t) || L !== (l[w].lineDashType || g.lineDashType)) && (b(), 
                                        B = l[w].lineColor || t, h.strokeStyle = B, h.setLineDash && (l[w].lineDashType ? (L = l[w].lineDashType, 
                                        h.setLineDash(H(L, g.lineThickness))) : (L = g.lineDashType, h.setLineDash(D)))), 
                                        z = g.dataPointIds[w], this._eventManager.objectMap[z] = {
                                            id: z,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: n,
                                            dataPointIndex: w,
                                            x1: y,
                                            y1: s
                                        }, 0 !== l[w].markerSize && (0 < l[w].markerSize || 0 < g.markerSize) && (ba = g.getMarkerProperties(w, y, s, h), 
                                        p.push(ba), z = Y(z), v && p.push({
                                            x: y,
                                            y: s,
                                            ctx: r,
                                            type: ba.type,
                                            size: ba.size,
                                            color: z,
                                            borderColor: z,
                                            borderThickness: ba.borderThickness
                                        })), (l[w].indexLabel || g.indexLabel || l[w].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "stepArea",
                                            dataPoint: l[w],
                                            dataSeries: g,
                                            point: {
                                                x: y,
                                                y: s
                                            },
                                            direction: 0 > l[w].y === a.axisY.reversed ? 1 : -1,
                                            color: A
                                        }));
                                    }
                                    b();
                                    W.drawMarkers(p);
                                }
                            }
                            v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), h.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && h.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && h.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            h.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore());
                            h.restore();
                            return {
                                source: f,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderStackedArea = function(a) {
                        function e() {
                            if (!(1 > k.length)) {
                                for (0 < A.lineThickness && b.stroke(); 0 < k.length; ) {
                                    var a = k.pop();
                                    b.lineTo(a.x, a.y);
                                    v && y.lineTo(a.x, a.y);
                                }
                                b.closePath();
                                b.globalAlpha = A.fillOpacity;
                                b.fill();
                                b.globalAlpha = 1;
                                b.beginPath();
                                v && (y.closePath(), y.fill(), y.beginPath());
                                k = [];
                            }
                        }
                        var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var g, l, s, z, u, f = null, h = null, r = [], d = this.plotArea, p = [], k = [], m = [], q = [], n = 0, w = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), y = this._eventManager.ghostCtx;
                            v && y.beginPath();
                            b.save();
                            v && y.save();
                            b.beginPath();
                            b.rect(d.x1, d.y1, d.width, d.height);
                            b.clip();
                            v && (y.beginPath(), y.rect(d.x1, d.y1, d.width, d.height), y.clip());
                            f = [];
                            for (var E = 0; E < a.dataSeriesIndexes.length; E++) {
                                var C = a.dataSeriesIndexes[E], A = this.data[C], t = A.dataPoints;
                                A.dataPointIndexes = [];
                                for (n = 0; n < t.length; n++) C = t[n].x.getTime ? t[n].x.getTime() : t[n].x, A.dataPointIndexes[C] = n, 
                                f[C] || (m.push(C), f[C] = !0);
                                m.sort(Sa);
                            }
                            for (E = 0; E < a.dataSeriesIndexes.length; E++) {
                                C = a.dataSeriesIndexes[E];
                                A = this.data[C];
                                t = A.dataPoints;
                                z = !0;
                                k = [];
                                n = A.id;
                                this._eventManager.objectMap[n] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: C
                                };
                                n = Y(n);
                                y.fillStyle = n;
                                if (0 < m.length) {
                                    f = A._colorSet[0];
                                    var B = A.lineColor = A.options.lineColor || f, L = B;
                                    b.fillStyle = f;
                                    b.strokeStyle = B;
                                    b.lineWidth = A.lineThickness;
                                    u = "solid";
                                    if (b.setLineDash) {
                                        var T = H(A.nullDataLineDashType, A.lineThickness);
                                        u = A.lineDashType;
                                        var D = H(u, A.lineThickness);
                                        b.setLineDash(D);
                                    }
                                    var ba = !0;
                                    for (n = 0; n < m.length; n++) {
                                        h = m[n];
                                        var ha = null;
                                        ha = 0 <= A.dataPointIndexes[h] ? t[A.dataPointIndexes[h]] : {
                                            x: h,
                                            y: null
                                        };
                                        if (!(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !ba))) if ("number" !== typeof ha.y) A.connectNullData || ba || z || e(), 
                                        ba = !0; else {
                                            g = a.axisX.convertValueToPixel(h);
                                            var pa = p[h] ? p[h] : 0;
                                            if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                                                q[h] = ha.y + (q[h] ? q[h] : 0);
                                                if (0 >= q[h] && a.axisY.logarithmic) continue;
                                                l = a.axisY.convertValueToPixel(q[h]);
                                            } else l = a.axisY.convertValueToPixel(ha.y), l -= pa;
                                            k.push({
                                                x: g,
                                                y: w - pa
                                            });
                                            p[h] = w - l;
                                            z || ba ? (!z && A.connectNullData ? (b.setLineDash && (A.options.nullDataLineDashType || u === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (z = k.pop(), 
                                            u = k[k.length - 1], e(), b.moveTo(s.x, s.y), k.push(u), k.push(z), u = A.nullDataLineDashType, 
                                            b.setLineDash(T)), b.lineTo(g, l), v && y.lineTo(g, l)) : (b.beginPath(), b.moveTo(g, l), 
                                            v && (y.beginPath(), y.moveTo(g, l))), ba = z = !1) : (b.lineTo(g, l), v && y.lineTo(g, l), 
                                            0 == n % 250 && (e(), b.moveTo(g, l), v && y.moveTo(g, l), k.push({
                                                x: g,
                                                y: w - pa
                                            })));
                                            s = {
                                                x: g,
                                                y: l
                                            };
                                            n < t.length - 1 && (L !== (t[n].lineColor || B) || u !== (t[n].lineDashType || A.lineDashType)) && (e(), 
                                            b.beginPath(), b.moveTo(g, l), k.push({
                                                x: g,
                                                y: w - pa
                                            }), L = t[n].lineColor || B, b.strokeStyle = L, b.setLineDash && (t[n].lineDashType ? (u = t[n].lineDashType, 
                                            b.setLineDash(H(u, A.lineThickness))) : (u = A.lineDashType, b.setLineDash(D))));
                                            if (0 <= A.dataPointIndexes[h]) {
                                                var la = A.dataPointIds[A.dataPointIndexes[h]];
                                                this._eventManager.objectMap[la] = {
                                                    id: la,
                                                    objectType: "dataPoint",
                                                    dataSeriesIndex: C,
                                                    dataPointIndex: A.dataPointIndexes[h],
                                                    x1: g,
                                                    y1: l
                                                };
                                            }
                                            0 <= A.dataPointIndexes[h] && 0 !== ha.markerSize && (0 < ha.markerSize || 0 < A.markerSize) && (pa = A.getMarkerProperties(A.dataPointIndexes[h], g, l, b), 
                                            r.push(pa), h = Y(la), v && r.push({
                                                x: g,
                                                y: l,
                                                ctx: y,
                                                type: pa.type,
                                                size: pa.size,
                                                color: h,
                                                borderColor: h,
                                                borderThickness: pa.borderThickness
                                            }));
                                            (ha.indexLabel || A.indexLabel || ha.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({
                                                chartType: "stackedArea",
                                                dataPoint: ha,
                                                dataSeries: A,
                                                point: {
                                                    x: g,
                                                    y: l
                                                },
                                                direction: 0 > ha.y === a.axisY.reversed ? 1 : -1,
                                                color: f
                                            });
                                        }
                                    }
                                    e();
                                    b.moveTo(g, l);
                                    v && y.moveTo(g, l);
                                }
                                delete A.dataPointIndexes;
                            }
                            W.drawMarkers(r);
                            v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            b.clearRect(d.x1, d.y1, d.width, d.height), y.restore());
                            b.restore();
                            return {
                                source: c,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderStackedArea100 = function(a) {
                        function e() {
                            for (0 < A.lineThickness && b.stroke(); 0 < k.length; ) {
                                var a = k.pop();
                                b.lineTo(a.x, a.y);
                                v && u.lineTo(a.x, a.y);
                            }
                            b.closePath();
                            b.globalAlpha = A.fillOpacity;
                            b.fill();
                            b.globalAlpha = 1;
                            b.beginPath();
                            v && (u.closePath(), u.fill(), u.beginPath());
                            k = [];
                        }
                        var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var g, l, w, y, s, f = null, h = null, r = this.plotArea, d = [], p = [], k = [], m = [], q = [], n = 0, z = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), u = this._eventManager.ghostCtx;
                            b.save();
                            v && u.save();
                            b.beginPath();
                            b.rect(r.x1, r.y1, r.width, r.height);
                            b.clip();
                            v && (u.beginPath(), u.rect(r.x1, r.y1, r.width, r.height), u.clip());
                            f = [];
                            for (var E = 0; E < a.dataSeriesIndexes.length; E++) {
                                var C = a.dataSeriesIndexes[E], A = this.data[C], t = A.dataPoints;
                                A.dataPointIndexes = [];
                                for (n = 0; n < t.length; n++) C = t[n].x.getTime ? t[n].x.getTime() : t[n].x, A.dataPointIndexes[C] = n, 
                                f[C] || (m.push(C), f[C] = !0);
                                m.sort(Sa);
                            }
                            for (E = 0; E < a.dataSeriesIndexes.length; E++) {
                                C = a.dataSeriesIndexes[E];
                                A = this.data[C];
                                t = A.dataPoints;
                                y = !0;
                                f = A.id;
                                this._eventManager.objectMap[f] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: C
                                };
                                f = Y(f);
                                u.fillStyle = f;
                                k = [];
                                if (0 < m.length) {
                                    f = A._colorSet[n % A._colorSet.length];
                                    var B = A.lineColor = A.options.lineColor || f, L = B;
                                    b.fillStyle = f;
                                    b.strokeStyle = B;
                                    b.lineWidth = A.lineThickness;
                                    s = "solid";
                                    if (b.setLineDash) {
                                        var T = H(A.nullDataLineDashType, A.lineThickness);
                                        s = A.lineDashType;
                                        var D = H(s, A.lineThickness);
                                        b.setLineDash(D);
                                    }
                                    var ba = !0;
                                    for (n = 0; n < m.length; n++) {
                                        h = m[n];
                                        var ha = null;
                                        ha = 0 <= A.dataPointIndexes[h] ? t[A.dataPointIndexes[h]] : {
                                            x: h,
                                            y: null
                                        };
                                        if (!(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !ba))) if ("number" !== typeof ha.y) A.connectNullData || ba || y || e(), 
                                        ba = !0; else {
                                            var pa;
                                            pa = 0 !== a.dataPointYSums[h] ? 100 * (ha.y / a.dataPointYSums[h]) : 0;
                                            g = a.axisX.convertValueToPixel(h);
                                            var la = p[h] ? p[h] : 0;
                                            if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                                                q[h] = pa + (q[h] ? q[h] : 0);
                                                if (0 >= q[h] && a.axisY.logarithmic) continue;
                                                l = a.axisY.convertValueToPixel(q[h]);
                                            } else l = a.axisY.convertValueToPixel(pa), l -= la;
                                            k.push({
                                                x: g,
                                                y: z - la
                                            });
                                            p[h] = z - l;
                                            y || ba ? (!y && A.connectNullData ? (b.setLineDash && (A.options.nullDataLineDashType || s === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (y = k.pop(), 
                                            s = k[k.length - 1], e(), b.moveTo(w.x, w.y), k.push(s), k.push(y), s = A.nullDataLineDashType, 
                                            b.setLineDash(T)), b.lineTo(g, l), v && u.lineTo(g, l)) : (b.beginPath(), b.moveTo(g, l), 
                                            v && (u.beginPath(), u.moveTo(g, l))), ba = y = !1) : (b.lineTo(g, l), v && u.lineTo(g, l), 
                                            0 == n % 250 && (e(), b.moveTo(g, l), v && u.moveTo(g, l), k.push({
                                                x: g,
                                                y: z - la
                                            })));
                                            w = {
                                                x: g,
                                                y: l
                                            };
                                            n < t.length - 1 && (L !== (t[n].lineColor || B) || s !== (t[n].lineDashType || A.lineDashType)) && (e(), 
                                            b.beginPath(), b.moveTo(g, l), k.push({
                                                x: g,
                                                y: z - la
                                            }), L = t[n].lineColor || B, b.strokeStyle = L, b.setLineDash && (t[n].lineDashType ? (s = t[n].lineDashType, 
                                            b.setLineDash(H(s, A.lineThickness))) : (s = A.lineDashType, b.setLineDash(D))));
                                            if (0 <= A.dataPointIndexes[h]) {
                                                var F = A.dataPointIds[A.dataPointIndexes[h]];
                                                this._eventManager.objectMap[F] = {
                                                    id: F,
                                                    objectType: "dataPoint",
                                                    dataSeriesIndex: C,
                                                    dataPointIndex: A.dataPointIndexes[h],
                                                    x1: g,
                                                    y1: l
                                                };
                                            }
                                            0 <= A.dataPointIndexes[h] && 0 !== ha.markerSize && (0 < ha.markerSize || 0 < A.markerSize) && (la = A.getMarkerProperties(A.dataPointIndexes[h], g, l, b), 
                                            d.push(la), h = Y(F), v && d.push({
                                                x: g,
                                                y: l,
                                                ctx: u,
                                                type: la.type,
                                                size: la.size,
                                                color: h,
                                                borderColor: h,
                                                borderThickness: la.borderThickness
                                            }));
                                            (ha.indexLabel || A.indexLabel || ha.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({
                                                chartType: "stackedArea100",
                                                dataPoint: ha,
                                                dataSeries: A,
                                                point: {
                                                    x: g,
                                                    y: l
                                                },
                                                direction: 0 > ha.y === a.axisY.reversed ? 1 : -1,
                                                color: f
                                            });
                                        }
                                    }
                                    e();
                                    b.moveTo(g, l);
                                    v && u.moveTo(g, l);
                                }
                                delete A.dataPointIndexes;
                            }
                            W.drawMarkers(d);
                            v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            b.clearRect(r.x1, r.y1, r.width, r.height), u.restore());
                            b.restore();
                            return {
                                source: c,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderBubble = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var h, r, b = this.plotArea, f = 0;
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(b.x1, b.y1, b.width, b.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), 
                            this._eventManager.ghostCtx.clip());
                            for (var d = -1 / 0, p = 1 / 0, k = 0; k < a.dataSeriesIndexes.length; k++) {
                                var m = a.dataSeriesIndexes[k], q = this.data[m], n = q.dataPoints, g = 0;
                                for (f = 0; f < n.length; f++) h = n[f].getTime ? h = n[f].x.getTime() : h = n[f].x, 
                                h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax || "undefined" === typeof n[f].z || (g = n[f].z, 
                                g > d && (d = g), g < p && (p = g));
                            }
                            var l = 25 * Math.PI, w = Math.max(Math.pow(.25 * Math.min(b.height, b.width) / 2, 2) * Math.PI, l);
                            for (k = 0; k < a.dataSeriesIndexes.length; k++) if (m = a.dataSeriesIndexes[k], 
                            q = this.data[m], n = q.dataPoints, 0 < n.length) for (c.strokeStyle = "#4572A7 ", 
                            f = 0; f < n.length; f++) if (h = n[f].getTime ? h = n[f].x.getTime() : h = n[f].x, 
                            !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && "number" === typeof n[f].y) {
                                h = a.axisX.convertValueToPixel(h);
                                r = a.axisY.convertValueToPixel(n[f].y);
                                g = n[f].z;
                                var y = 2 * Math.max(Math.sqrt((d === p ? w / 2 : l + (w - l) / (d - p) * (g - p)) / Math.PI) << 0, 1);
                                g = q.getMarkerProperties(f, c);
                                g.size = y;
                                c.globalAlpha = q.fillOpacity;
                                W.drawMarker(h, r, c, g.type, g.size, g.color, g.borderColor, g.borderThickness);
                                c.globalAlpha = 1;
                                var s = q.dataPointIds[f];
                                this._eventManager.objectMap[s] = {
                                    id: s,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: m,
                                    dataPointIndex: f,
                                    x1: h,
                                    y1: r,
                                    size: y
                                };
                                y = Y(s);
                                v && W.drawMarker(h, r, this._eventManager.ghostCtx, g.type, g.size, y, y, g.borderThickness);
                                (n[f].indexLabel || q.indexLabel || n[f].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "bubble",
                                    dataPoint: n[f],
                                    dataSeries: q,
                                    point: {
                                        x: h,
                                        y: r
                                    },
                                    direction: 1,
                                    bounds: {
                                        x1: h - g.size / 2,
                                        y1: r - g.size / 2,
                                        x2: h + g.size / 2,
                                        y2: r + g.size / 2
                                    },
                                    color: null
                                });
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderScatter = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var h, r, b = this.plotArea, f = 0;
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(b.x1, b.y1, b.width, b.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), 
                            this._eventManager.ghostCtx.clip());
                            for (var d = 0; d < a.dataSeriesIndexes.length; d++) {
                                var p = a.dataSeriesIndexes[d], k = this.data[p], m = k.dataPoints;
                                if (0 < m.length) {
                                    c.strokeStyle = "#4572A7 ";
                                    Math.pow(.3 * Math.min(b.height, b.width) / 2, 2);
                                    var q = 0, n = 0;
                                    for (f = 0; f < m.length; f++) if (h = m[f].getTime ? h = m[f].x.getTime() : h = m[f].x, 
                                    !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && "number" === typeof m[f].y) {
                                        h = a.axisX.convertValueToPixel(h);
                                        r = a.axisY.convertValueToPixel(m[f].y);
                                        var g = k.getMarkerProperties(f, h, r, c);
                                        c.globalAlpha = k.fillOpacity;
                                        W.drawMarker(g.x, g.y, g.ctx, g.type, g.size, g.color, g.borderColor, g.borderThickness);
                                        c.globalAlpha = 1;
                                        Math.sqrt((q - h) * (q - h) + (n - r) * (n - r)) < Math.min(g.size, 5) && m.length > Math.min(this.plotArea.width, this.plotArea.height) || (q = k.dataPointIds[f], 
                                        this._eventManager.objectMap[q] = {
                                            id: q,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: p,
                                            dataPointIndex: f,
                                            x1: h,
                                            y1: r
                                        }, q = Y(q), v && W.drawMarker(g.x, g.y, this._eventManager.ghostCtx, g.type, g.size, q, q, g.borderThickness), 
                                        (m[f].indexLabel || k.indexLabel || m[f].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "scatter",
                                            dataPoint: m[f],
                                            dataSeries: k,
                                            point: {
                                                x: h,
                                                y: r
                                            },
                                            direction: 1,
                                            bounds: {
                                                x1: h - g.size / 2,
                                                y1: r - g.size / 2,
                                                x2: h + g.size / 2,
                                                y2: r + g.size / 2
                                            },
                                            color: null
                                        }), q = h, n = r);
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderCandlestick = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e, b = this._eventManager.ghostCtx;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var l, k, m, q, n, g, f = null, h = null, r = this.plotArea, d = 0, na = (f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            h = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .015 * this.width, 
                            a.axisX.dataInfo.minDiff);
                            isFinite(na) || (na = .3 * Math.abs(a.axisX.range));
                            na = this.options.dataPointWidth ? this.dataPointWidth : .7 * r.width * (a.axisX.logarithmic ? Math.log(na) / Math.log(a.axisX.range) : Math.abs(na) / Math.abs(a.axisX.range)) << 0;
                            this.dataPointMaxWidth && f > h && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, h));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && h < f && (h = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, f));
                            na < f && (na = f);
                            na > h && (na = h);
                            c.save();
                            v && b.save();
                            c.beginPath();
                            c.rect(r.x1, r.y1, r.width, r.height);
                            c.clip();
                            v && (b.beginPath(), b.rect(r.x1, r.y1, r.width, r.height), b.clip());
                            for (var w = 0; w < a.dataSeriesIndexes.length; w++) {
                                var y = a.dataSeriesIndexes[w], s = this.data[y], z = s.dataPoints;
                                if (0 < z.length) {
                                    var u = 5 < na && s.bevelEnabled ? !0 : !1;
                                    for (d = 0; d < z.length; d++) if (z[d].getTime ? g = z[d].x.getTime() : g = z[d].x, 
                                    !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && !p(z[d].y) && z[d].y.length && "number" === typeof z[d].y[0] && "number" === typeof z[d].y[1] && "number" === typeof z[d].y[2] && "number" === typeof z[d].y[3]) {
                                        l = a.axisX.convertValueToPixel(g);
                                        k = a.axisY.convertValueToPixel(z[d].y[0]);
                                        m = a.axisY.convertValueToPixel(z[d].y[1]);
                                        q = a.axisY.convertValueToPixel(z[d].y[2]);
                                        n = a.axisY.convertValueToPixel(z[d].y[3]);
                                        var t = l - na / 2 << 0, C = t + na << 0, A = (h = s.options.fallingColor ? s.fallingColor : s._colorSet[0], 
                                        f = z[d].color ? z[d].color : s._colorSet[0], Math.round(Math.max(1, .15 * na))), B = 0 === A % 2 ? 0 : .5, D = s.dataPointIds[d];
                                        this._eventManager.objectMap[D] = {
                                            id: D,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: y,
                                            dataPointIndex: d,
                                            x1: t,
                                            y1: k,
                                            x2: C,
                                            y2: m,
                                            x3: l,
                                            y3: q,
                                            x4: l,
                                            y4: n,
                                            borderThickness: A,
                                            color: f
                                        };
                                        c.strokeStyle = f;
                                        c.beginPath();
                                        c.lineWidth = A;
                                        b.lineWidth = Math.max(A, 4);
                                        "candlestick" === s.type ? (c.moveTo(l - B, m), c.lineTo(l - B, Math.min(k, n)), 
                                        c.stroke(), c.moveTo(l - B, Math.max(k, n)), c.lineTo(l - B, q), c.stroke(), aa(c, t, Math.min(k, n), C, Math.max(k, n), z[d].y[0] <= z[d].y[3] ? s.risingColor : h, A, f, u, u, !1, !1, s.fillOpacity), 
                                        v && (f = Y(D), b.strokeStyle = f, b.moveTo(l - B, m), b.lineTo(l - B, Math.min(k, n)), 
                                        b.stroke(), b.moveTo(l - B, Math.max(k, n)), b.lineTo(l - B, q), b.stroke(), aa(b, t, Math.min(k, n), C, Math.max(k, n), f, 0, null, !1, !1, !1, !1))) : "ohlc" === s.type && (c.moveTo(l - B, m), 
                                        c.lineTo(l - B, q), c.stroke(), c.beginPath(), c.moveTo(l, k), c.lineTo(t, k), c.stroke(), 
                                        c.beginPath(), c.moveTo(l, n), c.lineTo(C, n), c.stroke(), v && (f = Y(D), b.strokeStyle = f, 
                                        b.moveTo(l - B, m), b.lineTo(l - B, q), b.stroke(), b.beginPath(), b.moveTo(l, k), 
                                        b.lineTo(t, k), b.stroke(), b.beginPath(), b.moveTo(l, n), b.lineTo(C, n), b.stroke()));
                                        (z[d].indexLabel || s.indexLabel || z[d].indexLabelFormatter || s.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: s.type,
                                            dataPoint: z[d],
                                            dataSeries: s,
                                            point: {
                                                x: t + (C - t) / 2,
                                                y: a.axisY.reversed ? q : m
                                            },
                                            direction: 1,
                                            bounds: {
                                                x1: t,
                                                y1: Math.min(m, q),
                                                x2: C,
                                                y2: Math.max(m, q)
                                            },
                                            color: f
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(r.x1, r.y1, r.width, r.height), b.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderBoxAndWhisker = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e, b = this._eventManager.ghostCtx;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var d, l, k, m, q, n, g, f = null, h = this.plotArea, r = 0, t = (f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, 
                            r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .015 * this.width, 
                            a.axisX.dataInfo.minDiff);
                            isFinite(t) || (t = .3 * Math.abs(a.axisX.range));
                            t = this.options.dataPointWidth ? this.dataPointWidth : .7 * h.width * (a.axisX.logarithmic ? Math.log(t) / Math.log(a.axisX.range) : Math.abs(t) / Math.abs(a.axisX.range)) << 0;
                            this.dataPointMaxWidth && f > r && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, r));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && r < f && (r = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, f));
                            t < f && (t = f);
                            t > r && (t = r);
                            c.save();
                            v && b.save();
                            c.beginPath();
                            c.rect(h.x1, h.y1, h.width, h.height);
                            c.clip();
                            v && (b.beginPath(), b.rect(h.x1, h.y1, h.width, h.height), b.clip());
                            for (var w = !1, y = (w = !!a.axisY.reversed, 0); y < a.dataSeriesIndexes.length; y++) {
                                var s = a.dataSeriesIndexes[y], z = this.data[s], u = z.dataPoints;
                                if (0 < u.length) {
                                    var E = 5 < t && z.bevelEnabled ? !0 : !1;
                                    for (r = 0; r < u.length; r++) if (u[r].getTime ? g = u[r].x.getTime() : g = u[r].x, 
                                    !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && !p(u[r].y) && u[r].y.length && "number" === typeof u[r].y[0] && "number" === typeof u[r].y[1] && "number" === typeof u[r].y[2] && "number" === typeof u[r].y[3] && "number" === typeof u[r].y[4] && 5 === u[r].y.length) {
                                        d = a.axisX.convertValueToPixel(g);
                                        l = a.axisY.convertValueToPixel(u[r].y[0]);
                                        k = a.axisY.convertValueToPixel(u[r].y[1]);
                                        m = a.axisY.convertValueToPixel(u[r].y[2]);
                                        q = a.axisY.convertValueToPixel(u[r].y[3]);
                                        n = a.axisY.convertValueToPixel(u[r].y[4]);
                                        var C = d - t / 2 << 0, A = d + t / 2 << 0, B = (f = u[r].color ? u[r].color : z._colorSet[0], 
                                        Math.round(Math.max(1, .15 * t))), D = 0 === B % 2 ? 0 : .5, L = u[r].whiskerColor ? u[r].whiskerColor : u[r].color ? z.whiskerColor ? z.whiskerColor : u[r].color : z.whiskerColor ? z.whiskerColor : f, T = "number" === typeof u[r].whiskerThickness ? u[r].whiskerThickness : "number" === typeof z.options.whiskerThickness ? z.whiskerThickness : B, ga = u[r].whiskerDashType ? u[r].whiskerDashType : z.whiskerDashType, ba = p(u[r].whiskerLength) ? p(z.options.whiskerLength) ? t : z.whiskerLength : u[r].whiskerLength, ha = (ba = "number" === typeof ba ? 0 >= ba ? 0 : ba >= t ? t : ba : "string" === typeof ba ? parseInt(ba) * t / 100 > t ? t : parseInt(ba) * t / 100 : t, 
                                        1 === Math.round(T) % 2 ? .5 : 0), pa = u[r].stemColor ? u[r].stemColor : u[r].color ? z.stemColor ? z.stemColor : u[r].color : z.stemColor ? z.stemColor : f, la = "number" === typeof u[r].stemThickness ? u[r].stemThickness : "number" === typeof z.options.stemThickness ? z.stemThickness : B, F = 1 === Math.round(la) % 2 ? .5 : 0, I = u[r].stemDashType ? u[r].stemDashType : z.stemDashType, K = u[r].lineColor ? u[r].lineColor : u[r].color ? z.lineColor ? z.lineColor : u[r].color : z.lineColor ? z.lineColor : f, O = "number" === typeof u[r].lineThickness ? u[r].lineThickness : "number" === typeof z.options.lineThickness ? z.lineThickness : B, S = u[r].lineDashType ? u[r].lineDashType : z.lineDashType, M = 1 === Math.round(O) % 2 ? .5 : 0, P = z.upperBoxColor, Q = z.lowerBoxColor, va = p(z.options.fillOpacity) ? 1 : z.fillOpacity, R = z.dataPointIds[r];
                                        this._eventManager.objectMap[R] = {
                                            id: R,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: s,
                                            dataPointIndex: r,
                                            x1: C,
                                            y1: l,
                                            x2: A,
                                            y2: k,
                                            x3: d,
                                            y3: m,
                                            x4: d,
                                            y4: q,
                                            y5: n,
                                            borderThickness: B,
                                            color: f,
                                            stemThickness: la,
                                            stemColor: pa,
                                            whiskerThickness: T,
                                            whiskerLength: ba,
                                            whiskerColor: L,
                                            lineThickness: O,
                                            lineColor: K
                                        };
                                        c.save();
                                        0 < la && (c.beginPath(), c.strokeStyle = pa, c.lineWidth = la, c.setLineDash && c.setLineDash(H(I, la)), 
                                        c.moveTo(d - F, k), c.lineTo(d - F, l), c.stroke(), c.moveTo(d - F, q), c.lineTo(d - F, m), 
                                        c.stroke());
                                        c.restore();
                                        b.lineWidth = Math.max(B, 4);
                                        c.beginPath();
                                        aa(c, C, Math.min(n, k), A, Math.max(k, n), Q, 0, f, w ? E : !1, w ? !1 : E, !1, !1, va);
                                        c.beginPath();
                                        aa(c, C, Math.min(m, n), A, Math.max(n, m), P, 0, f, w ? !1 : E, w ? E : !1, !1, !1, va);
                                        c.beginPath();
                                        c.lineWidth = B;
                                        c.strokeStyle = f;
                                        c.rect(C - D, Math.min(k, m) - D, A - C + 2 * D, Math.max(k, m) - Math.min(k, m) + 2 * D);
                                        c.stroke();
                                        c.save();
                                        0 < O && (c.beginPath(), c.globalAlpha = 1, c.setLineDash && c.setLineDash(H(S, O)), 
                                        c.strokeStyle = K, c.lineWidth = O, c.moveTo(C, n - M), c.lineTo(A, n - M), c.stroke());
                                        c.restore();
                                        c.save();
                                        0 < T && (c.beginPath(), c.setLineDash && c.setLineDash(H(ga, T)), c.strokeStyle = L, 
                                        c.lineWidth = T, c.moveTo(d - ba / 2 << 0, q - ha), c.lineTo(d + ba / 2 << 0, q - ha), 
                                        c.stroke(), c.moveTo(d - ba / 2 << 0, l + ha), c.lineTo(d + ba / 2 << 0, l + ha), 
                                        c.stroke());
                                        c.restore();
                                        v && (f = Y(R), b.strokeStyle = f, b.lineWidth = la, 0 < la && (b.moveTo(d - D - F, k), 
                                        b.lineTo(d - D - F, Math.max(l, q)), b.stroke(), b.moveTo(d - D - F, Math.min(l, q)), 
                                        b.lineTo(d - D - F, m), b.stroke()), aa(b, C, Math.max(k, m), A, Math.min(k, m), f, 0, null, !1, !1, !1, !1), 
                                        0 < T && (b.beginPath(), b.lineWidth = T, b.moveTo(d + ba / 2, q - ha), b.lineTo(d - ba / 2, q - ha), 
                                        b.stroke(), b.moveTo(d + ba / 2, l + ha), b.lineTo(d - ba / 2, l + ha), b.stroke()));
                                        (u[r].indexLabel || z.indexLabel || u[r].indexLabelFormatter || z.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: z.type,
                                            dataPoint: u[r],
                                            dataSeries: z,
                                            point: {
                                                x: C + (A - C) / 2,
                                                y: a.axisY.reversed ? l : q
                                            },
                                            direction: 1,
                                            bounds: {
                                                x1: C,
                                                y1: Math.min(l, q),
                                                x2: A,
                                                y2: Math.max(l, q)
                                            },
                                            color: f
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(h.x1, h.y1, h.width, h.height), b.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderRangeColumn = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var r, d, l, b = null, f = this.plotArea, h = 0;
                            h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                            r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .03 * this.width;
                            var k = a.axisX.dataInfo.minDiff;
                            isFinite(k) || (k = .3 * Math.abs(a.axisX.range));
                            k = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
                            this.dataPointMaxWidth && h > r && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, r));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && r < h && (r = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, h));
                            k < h && (k = h);
                            k > r && (k = r);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (var m = 0; m < a.dataSeriesIndexes.length; m++) {
                                var q = a.dataSeriesIndexes[m], n = this.data[q], g = n.dataPoints;
                                if (0 < g.length) {
                                    var t = 5 < k && n.bevelEnabled ? !0 : !1;
                                    for (h = 0; h < g.length; h++) if (g[h].getTime ? l = g[h].x.getTime() : l = g[h].x, 
                                    !(l < a.axisX.dataInfo.viewPortMin || l > a.axisX.dataInfo.viewPortMax) && !p(g[h].y) && g[h].y.length && "number" === typeof g[h].y[0] && "number" === typeof g[h].y[1]) {
                                        b = a.axisX.convertValueToPixel(l);
                                        r = a.axisY.convertValueToPixel(g[h].y[0]);
                                        d = a.axisY.convertValueToPixel(g[h].y[1]);
                                        var w = a.axisX.reversed ? b + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + m) * k << 0 : b - a.plotType.totalDataSeries * k / 2 + (a.previousDataSeriesCount + m) * k << 0, y = a.axisX.reversed ? w - k << 0 : w + k << 0;
                                        b = g[h].color ? g[h].color : n._colorSet[h % n._colorSet.length];
                                        if (r > d) {
                                            var s = r;
                                            r = d;
                                            d = s;
                                        }
                                        s = n.dataPointIds[h];
                                        this._eventManager.objectMap[s] = {
                                            id: s,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: q,
                                            dataPointIndex: h,
                                            x1: w,
                                            y1: r,
                                            x2: y,
                                            y2: d
                                        };
                                        aa(c, a.axisX.reversed ? y : w, r, a.axisX.reversed ? w : y, d, b, 0, b, t, t, !1, !1, n.fillOpacity);
                                        b = Y(s);
                                        v && aa(this._eventManager.ghostCtx, a.axisX.reversed ? y : w, r, a.axisX.reversed ? w : y, d, b, 0, null, !1, !1, !1, !1);
                                        if (g[h].indexLabel || n.indexLabel || g[h].indexLabelFormatter || n.indexLabelFormatter) this._indexLabels.push({
                                            chartType: "rangeColumn",
                                            dataPoint: g[h],
                                            dataSeries: n,
                                            indexKeyword: 0,
                                            point: {
                                                x: w + (y - w) / 2,
                                                y: g[h].y[1] >= g[h].y[0] ? d : r
                                            },
                                            direction: g[h].y[1] >= g[h].y[0] ? -1 : 1,
                                            bounds: {
                                                x1: w,
                                                y1: Math.min(r, d),
                                                x2: y,
                                                y2: Math.max(r, d)
                                            },
                                            color: b
                                        }), this._indexLabels.push({
                                            chartType: "rangeColumn",
                                            dataPoint: g[h],
                                            dataSeries: n,
                                            indexKeyword: 1,
                                            point: {
                                                x: w + (y - w) / 2,
                                                y: g[h].y[1] >= g[h].y[0] ? r : d
                                            },
                                            direction: g[h].y[1] >= g[h].y[0] ? 1 : -1,
                                            bounds: {
                                                x1: w,
                                                y1: Math.min(r, d),
                                                x2: y,
                                                y2: Math.max(r, d)
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderError = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e, b = a.axisY._position ? "left" === a.axisY._position || "right" === a.axisY._position ? !1 : !0 : !1;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var l, k, m, q, n, g, t, f = null, h = !1, r = this.plotArea, d = 0, w = a.axisX.dataInfo.minDiff;
                            isFinite(w) || (w = .3 * Math.abs(a.axisX.range));
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(r.x1, r.y1, r.width, r.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(r.x1, r.y1, r.width, r.height), 
                            this._eventManager.ghostCtx.clip());
                            for (var y = 0, s = 0; s < this.data.length; s++) !this.data[s].type.match(/(bar|column)/gi) || !this.data[s].visible || this.data[s].type.match(/(stacked)/gi) && y || y++;
                            for (var z = 0; z < a.dataSeriesIndexes.length; z++) {
                                var u = a.dataSeriesIndexes[z], E = this.data[u], C = E.dataPoints, A = p(E._linkedSeries) ? !1 : E._linkedSeries.type.match(/(bar|column)/gi) && E._linkedSeries.visible ? !0 : !1, D = 0;
                                if (A) for (f = E._linkedSeries.id, s = 0; s < f; s++) !this.data[s].type.match(/(bar|column)/gi) || !this.data[s].visible || this.data[s].type.match(/(stacked)/gi) && D || (this.data[s].type.match(/(range)/gi) && (h = !0), 
                                D++);
                                f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                                d = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(.15 * this.height, .9 * (this.plotArea.height / (A ? y : 1))) << 0 : .3 * this.width;
                                h && (d = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : b ? Math.min(.15 * this.height, .9 * (this.plotArea.height / (A ? y : 1))) << 0 : .03 * this.width);
                                s = this.options.dataPointWidth ? this.dataPointWidth : .9 * ((b ? r.height : r.width) * (a.axisX.logarithmic ? Math.log(w) / Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) / (A ? y : 1)) << 0;
                                this.dataPointMaxWidth && f > d && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, d));
                                !this.dataPointMaxWidth && this.dataPointMinWidth && d < f && (d = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, f));
                                s < f && (s = f);
                                s > d && (s = d);
                                if (0 < C.length) {
                                    var H = E._colorSet;
                                    for (d = 0; d < C.length; d++) {
                                        f = E.lineColor = E.options.color ? E.options.color : H[0];
                                        var L = {
                                            color: C[d].whiskerColor ? C[d].whiskerColor : C[d].color ? E.whiskerColor ? E.whiskerColor : C[d].color : E.whiskerColor ? E.whiskerColor : f,
                                            thickness: p(C[d].whiskerThickness) ? E.whiskerThickness : C[d].whiskerThickness,
                                            dashType: C[d].whiskerDashType ? C[d].whiskerDashType : E.whiskerDashType,
                                            length: p(C[d].whiskerLength) ? p(E.options.whiskerLength) ? s : E.options.whiskerLength : C[d].whiskerLength,
                                            trimLength: p(C[d].whiskerLength) ? p(E.options.whiskerLength) ? 50 : 0 : 0
                                        };
                                        L.length = "number" === typeof L.length ? 0 >= L.length ? 0 : L.length >= s ? s : L.length : "string" === typeof L.length ? parseInt(L.length) * s / 100 > s ? s : parseInt(L.length) * s / 100 > s : s;
                                        L.thickness = "number" === typeof L.thickness ? 0 > L.thickness ? 0 : Math.round(L.thickness) : 2;
                                        var T = {
                                            color: C[d].stemColor ? C[d].stemColor : C[d].color ? E.stemColor ? E.stemColor : C[d].color : E.stemColor ? E.stemColor : f,
                                            thickness: C[d].stemThickness ? C[d].stemThickness : E.stemThickness,
                                            dashType: C[d].stemDashType ? C[d].stemDashType : E.stemDashType
                                        };
                                        T.thickness = "number" === typeof T.thickness ? 0 > T.thickness ? 0 : Math.round(T.thickness) : 2;
                                        C[d].getTime ? t = C[d].x.getTime() : t = C[d].x;
                                        if (!(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && !p(C[d].y) && C[d].y.length && "number" === typeof C[d].y[0] && "number" === typeof C[d].y[1]) {
                                            var ga = a.axisX.convertValueToPixel(t);
                                            b ? k = ga : l = ga;
                                            ga = a.axisY.convertValueToPixel(C[d].y[0]);
                                            b ? m = ga : n = ga;
                                            ga = a.axisY.convertValueToPixel(C[d].y[1]);
                                            b ? q = ga : g = ga;
                                            b ? (n = a.axisX.reversed ? k + (A ? y : 1) * s / 2 - (A ? D - 1 : 0) * s << 0 : k - (A ? y : 1) * s / 2 + (A ? D - 1 : 0) * s << 0, 
                                            g = a.axisX.reversed ? n - s << 0 : n + s << 0) : (m = a.axisX.reversed ? l + (A ? y : 1) * s / 2 - (A ? D - 1 : 0) * s << 0 : l - (A ? y : 1) * s / 2 + (A ? D - 1 : 0) * s << 0, 
                                            q = a.axisX.reversed ? m - s << 0 : m + s << 0);
                                            !b && n > g && (ga = n, n = g, g = ga);
                                            b && m > q && (ga = m, m = q, q = ga);
                                            ga = E.dataPointIds[d];
                                            this._eventManager.objectMap[ga] = {
                                                id: ga,
                                                objectType: "dataPoint",
                                                dataSeriesIndex: u,
                                                dataPointIndex: d,
                                                x1: Math.min(m, q),
                                                y1: Math.min(n, g),
                                                x2: Math.max(q, m),
                                                y2: Math.max(g, n),
                                                isXYSwapped: b,
                                                stemProperties: T,
                                                whiskerProperties: L
                                            };
                                            B(c, Math.min(m, q), Math.min(n, g), Math.max(q, m), Math.max(g, n), f, L, T, b);
                                            v && B(this._eventManager.ghostCtx, m, n, q, g, f, L, T, b);
                                            if (C[d].indexLabel || E.indexLabel || C[d].indexLabelFormatter || E.indexLabelFormatter) this._indexLabels.push({
                                                chartType: "error",
                                                dataPoint: C[d],
                                                dataSeries: E,
                                                indexKeyword: 0,
                                                point: {
                                                    x: b ? C[d].y[1] >= C[d].y[0] ? m : q : m + (q - m) / 2,
                                                    y: b ? n + (g - n) / 2 : C[d].y[1] >= C[d].y[0] ? g : n
                                                },
                                                direction: C[d].y[1] >= C[d].y[0] ? -1 : 1,
                                                bounds: {
                                                    x1: b ? Math.min(m, q) : m,
                                                    y1: b ? n : Math.min(n, g),
                                                    x2: b ? Math.max(m, q) : q,
                                                    y2: b ? g : Math.max(n, g)
                                                },
                                                color: f,
                                                axisSwapped: b
                                            }), this._indexLabels.push({
                                                chartType: "error",
                                                dataPoint: C[d],
                                                dataSeries: E,
                                                indexKeyword: 1,
                                                point: {
                                                    x: b ? C[d].y[1] >= C[d].y[0] ? q : m : m + (q - m) / 2,
                                                    y: b ? n + (g - n) / 2 : C[d].y[1] >= C[d].y[0] ? n : g
                                                },
                                                direction: C[d].y[1] >= C[d].y[0] ? 1 : -1,
                                                bounds: {
                                                    x1: b ? Math.min(m, q) : m,
                                                    y1: b ? n : Math.min(n, g),
                                                    x2: b ? Math.max(m, q) : q,
                                                    y2: b ? g : Math.max(n, g)
                                                },
                                                color: f,
                                                axisSwapped: b
                                            });
                                        }
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderRangeBar = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var r, d, l, k, b = null, f = this.plotArea, h = 0;
                            h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                            r = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, .9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;
                            var m = a.axisX.dataInfo.minDiff;
                            isFinite(m) || (m = .3 * Math.abs(a.axisX.range));
                            m = this.options.dataPointWidth ? this.dataPointWidth : .9 * (f.height * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
                            this.dataPointMaxWidth && h > r && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, r));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && r < h && (r = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, h));
                            m < h && (m = h);
                            m > r && (m = r);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(f.x1, f.y1, f.width, f.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), 
                            this._eventManager.ghostCtx.clip());
                            for (var q = 0; q < a.dataSeriesIndexes.length; q++) {
                                var n = a.dataSeriesIndexes[q], g = this.data[n], t = g.dataPoints;
                                if (0 < t.length) {
                                    var w = 5 < m && g.bevelEnabled ? !0 : !1;
                                    c.strokeStyle = "#4572A7 ";
                                    for (h = 0; h < t.length; h++) if (t[h].getTime ? k = t[h].x.getTime() : k = t[h].x, 
                                    !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !p(t[h].y) && t[h].y.length && "number" === typeof t[h].y[0] && "number" === typeof t[h].y[1]) {
                                        r = a.axisY.convertValueToPixel(t[h].y[0]);
                                        d = a.axisY.convertValueToPixel(t[h].y[1]);
                                        l = a.axisX.convertValueToPixel(k);
                                        l = a.axisX.reversed ? l + a.plotType.totalDataSeries * m / 2 - (a.previousDataSeriesCount + q) * m << 0 : l - a.plotType.totalDataSeries * m / 2 + (a.previousDataSeriesCount + q) * m << 0;
                                        var y = a.axisX.reversed ? l - m << 0 : l + m << 0;
                                        r > d && (b = r, r = d, d = b);
                                        b = t[h].color ? t[h].color : g._colorSet[h % g._colorSet.length];
                                        aa(c, r, a.axisX.reversed ? y : l, d, a.axisX.reversed ? l : y, b, 0, null, w, !1, !1, !1, g.fillOpacity);
                                        b = g.dataPointIds[h];
                                        this._eventManager.objectMap[b] = {
                                            id: b,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: n,
                                            dataPointIndex: h,
                                            x1: r,
                                            y1: l,
                                            x2: d,
                                            y2: y
                                        };
                                        b = Y(b);
                                        v && aa(this._eventManager.ghostCtx, r, a.axisX.reversed ? y : l, d, a.axisX.reversed ? l : y, b, 0, null, !1, !1, !1, !1);
                                        if (t[h].indexLabel || g.indexLabel || t[h].indexLabelFormatter || g.indexLabelFormatter) this._indexLabels.push({
                                            chartType: "rangeBar",
                                            dataPoint: t[h],
                                            dataSeries: g,
                                            indexKeyword: 0,
                                            point: {
                                                x: t[h].y[1] >= t[h].y[0] ? r : d,
                                                y: l + (y - l) / 2
                                            },
                                            direction: t[h].y[1] >= t[h].y[0] ? -1 : 1,
                                            bounds: {
                                                x1: Math.min(r, d),
                                                y1: l,
                                                x2: Math.max(r, d),
                                                y2: y
                                            },
                                            color: b
                                        }), this._indexLabels.push({
                                            chartType: "rangeBar",
                                            dataPoint: t[h],
                                            dataSeries: g,
                                            indexKeyword: 1,
                                            point: {
                                                x: t[h].y[1] >= t[h].y[0] ? d : r,
                                                y: l + (y - l) / 2
                                            },
                                            direction: t[h].y[1] >= t[h].y[0] ? 1 : -1,
                                            bounds: {
                                                x1: Math.min(r, d),
                                                y1: l,
                                                x2: Math.max(r, d),
                                                y2: y
                                            },
                                            color: b
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderRangeArea = function(a) {
                        function e() {
                            if (z) {
                                for (var a = null, c = p.length - 1; 0 <= c; c--) a = p[c], b.lineTo(a.x, a.y2), 
                                f.lineTo(a.x, a.y2);
                                b.closePath();
                                b.globalAlpha = m.fillOpacity;
                                b.fill();
                                b.globalAlpha = 1;
                                f.fill();
                                if (0 < m.lineThickness) {
                                    b.beginPath();
                                    b.moveTo(a.x, a.y2);
                                    for (c = 0; c < p.length; c++) a = p[c], b.lineTo(a.x, a.y2);
                                    b.moveTo(p[0].x, p[0].y1);
                                    for (c = 0; c < p.length; c++) a = p[c], b.lineTo(a.x, a.y1);
                                    b.stroke();
                                }
                                b.beginPath();
                                b.moveTo(l, w);
                                f.beginPath();
                                f.moveTo(l, w);
                                z = {
                                    x: l,
                                    y: w
                                };
                                p = [];
                                p.push({
                                    x: l,
                                    y1: w,
                                    y2: y
                                });
                            }
                        }
                        var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var f = this._eventManager.ghostCtx, h = [], r = this.plotArea;
                            b.save();
                            v && f.save();
                            b.beginPath();
                            b.rect(r.x1, r.y1, r.width, r.height);
                            b.clip();
                            v && (f.beginPath(), f.rect(r.x1, r.y1, r.width, r.height), f.clip());
                            for (var d = 0; d < a.dataSeriesIndexes.length; d++) {
                                var p = [], k = a.dataSeriesIndexes[d], m = this.data[k], q = m.dataPoints;
                                h = m.id;
                                this._eventManager.objectMap[h] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: k
                                };
                                h = Y(h);
                                f.fillStyle = h;
                                h = [];
                                var l, w, y, s, n = !0, g = 0, z = null;
                                if (0 < q.length) {
                                    var u = m._colorSet[g % m._colorSet.length], t = m.lineColor = m.options.lineColor || u, C = t;
                                    b.fillStyle = u;
                                    b.strokeStyle = t;
                                    b.lineWidth = m.lineThickness;
                                    var A = "solid";
                                    if (b.setLineDash) {
                                        var B = H(m.nullDataLineDashType, m.lineThickness), D = (A = m.lineDashType, H(A, m.lineThickness));
                                        b.setLineDash(D);
                                    }
                                    for (var L = !0; g < q.length; g++) if (s = q[g].x.getTime ? q[g].x.getTime() : q[g].x, 
                                    !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!m.connectNullData || !L))) if (null !== q[g].y && q[g].y.length && "number" === typeof q[g].y[0] && "number" === typeof q[g].y[1]) {
                                        l = a.axisX.convertValueToPixel(s);
                                        w = a.axisY.convertValueToPixel(q[g].y[0]);
                                        y = a.axisY.convertValueToPixel(q[g].y[1]);
                                        n || L ? (m.connectNullData && !n ? (b.setLineDash && (m.options.nullDataLineDashType || A === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (p[p.length - 1].newLineDashArray = D, 
                                        A = m.nullDataLineDashType, b.setLineDash(B)), b.lineTo(l, w), v && f.lineTo(l, w), 
                                        p.push({
                                            x: l,
                                            y1: w,
                                            y2: y
                                        })) : (b.beginPath(), b.moveTo(l, w), z = {
                                            x: l,
                                            y: w
                                        }, p = [], p.push({
                                            x: l,
                                            y1: w,
                                            y2: y
                                        }), v && (f.beginPath(), f.moveTo(l, w))), L = n = !1) : (b.lineTo(l, w), p.push({
                                            x: l,
                                            y1: w,
                                            y2: y
                                        }), v && f.lineTo(l, w), 0 == g % 250 && e());
                                        s = m.dataPointIds[g];
                                        this._eventManager.objectMap[s] = {
                                            id: s,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: k,
                                            dataPointIndex: g,
                                            x1: l,
                                            y1: w,
                                            y2: y
                                        };
                                        g < q.length - 1 && (C !== (q[g].lineColor || t) || A !== (q[g].lineDashType || m.lineDashType)) && (e(), 
                                        C = q[g].lineColor || t, p[p.length - 1].newStrokeStyle = C, b.strokeStyle = C, 
                                        b.setLineDash && (q[g].lineDashType ? (A = q[g].lineDashType, p[p.length - 1].newLineDashArray = H(A, m.lineThickness), 
                                        b.setLineDash(p[p.length - 1].newLineDashArray)) : (A = m.lineDashType, p[p.length - 1].newLineDashArray = D, 
                                        b.setLineDash(D))));
                                        if (0 !== q[g].markerSize && (0 < q[g].markerSize || 0 < m.markerSize)) {
                                            var T = m.getMarkerProperties(g, l, y, b);
                                            h.push(T);
                                            var ga = Y(s);
                                            v && h.push({
                                                x: l,
                                                y,
                                                ctx: f,
                                                type: T.type,
                                                size: T.size,
                                                color: ga,
                                                borderColor: ga,
                                                borderThickness: T.borderThickness
                                            });
                                            T = m.getMarkerProperties(g, l, w, b);
                                            h.push(T);
                                            ga = Y(s);
                                            v && h.push({
                                                x: l,
                                                y: w,
                                                ctx: f,
                                                type: T.type,
                                                size: T.size,
                                                color: ga,
                                                borderColor: ga,
                                                borderThickness: T.borderThickness
                                            });
                                        }
                                        if (q[g].indexLabel || m.indexLabel || q[g].indexLabelFormatter || m.indexLabelFormatter) this._indexLabels.push({
                                            chartType: "rangeArea",
                                            dataPoint: q[g],
                                            dataSeries: m,
                                            indexKeyword: 0,
                                            point: {
                                                x: l,
                                                y: w
                                            },
                                            direction: q[g].y[0] > q[g].y[1] === a.axisY.reversed ? -1 : 1,
                                            color: u
                                        }), this._indexLabels.push({
                                            chartType: "rangeArea",
                                            dataPoint: q[g],
                                            dataSeries: m,
                                            indexKeyword: 1,
                                            point: {
                                                x: l,
                                                y
                                            },
                                            direction: q[g].y[0] > q[g].y[1] === a.axisY.reversed ? 1 : -1,
                                            color: u
                                        });
                                    } else L || n || e(), L = !0;
                                    e();
                                    W.drawMarkers(h);
                                }
                            }
                            v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            b.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());
                            b.restore();
                            return {
                                source: c,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderRangeSplineArea = function(a) {
                        function e(a, c) {
                            var g = t(w, 2);
                            if (0 < g.length) {
                                if (0 < k.lineThickness) {
                                    b.strokeStyle = c;
                                    b.setLineDash && b.setLineDash(a);
                                    b.beginPath();
                                    b.moveTo(g[0].x, g[0].y);
                                    for (var e = 0; e < g.length - 3; e += 3) {
                                        if (g[e].newStrokeStyle || g[e].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(g[e].x, g[e].y), 
                                        g[e].newStrokeStyle && (b.strokeStyle = g[e].newStrokeStyle), g[e].newLineDashArray && b.setLineDash(g[e].newLineDashArray);
                                        b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);
                                    }
                                }
                                b.beginPath();
                                b.moveTo(g[0].x, g[0].y);
                                v && (f.beginPath(), f.moveTo(g[0].x, g[0].y));
                                for (e = 0; e < g.length - 3; e += 3) b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y), 
                                v && f.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);
                                g = t(y, 2);
                                b.lineTo(y[y.length - 1].x, y[y.length - 1].y);
                                for (e = g.length - 1; 2 < e; e -= 3) b.bezierCurveTo(g[e - 1].x, g[e - 1].y, g[e - 2].x, g[e - 2].y, g[e - 3].x, g[e - 3].y), 
                                v && f.bezierCurveTo(g[e - 1].x, g[e - 1].y, g[e - 2].x, g[e - 2].y, g[e - 3].x, g[e - 3].y);
                                b.closePath();
                                b.globalAlpha = k.fillOpacity;
                                b.fill();
                                v && (f.closePath(), f.fill());
                                b.globalAlpha = 1;
                                if (0 < k.lineThickness) {
                                    b.strokeStyle = c;
                                    b.setLineDash && b.setLineDash(a);
                                    b.beginPath();
                                    b.moveTo(g[0].x, g[0].y);
                                    for (var h = e = 0; e < g.length - 3; e += 3, h++) {
                                        if (w[h].newStrokeStyle || w[h].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(g[e].x, g[e].y), 
                                        w[h].newStrokeStyle && (b.strokeStyle = w[h].newStrokeStyle), w[h].newLineDashArray && b.setLineDash(w[h].newLineDashArray);
                                        b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);
                                    }
                                    g = t(w, 2);
                                    b.moveTo(g[0].x, g[0].y);
                                    for (h = e = 0; e < g.length - 3; e += 3, h++) {
                                        if (w[h].newStrokeStyle || w[h].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(g[e].x, g[e].y), 
                                        w[h].newStrokeStyle && (b.strokeStyle = w[h].newStrokeStyle), w[h].newLineDashArray && b.setLineDash(w[h].newLineDashArray);
                                        b.bezierCurveTo(g[e + 1].x, g[e + 1].y, g[e + 2].x, g[e + 2].y, g[e + 3].x, g[e + 3].y);
                                    }
                                    b.stroke();
                                }
                                b.beginPath();
                            }
                        }
                        var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var f = this._eventManager.ghostCtx, h = [], r = this.plotArea;
                            b.save();
                            v && f.save();
                            b.beginPath();
                            b.rect(r.x1, r.y1, r.width, r.height);
                            b.clip();
                            v && (f.beginPath(), f.rect(r.x1, r.y1, r.width, r.height), f.clip());
                            for (var d = 0; d < a.dataSeriesIndexes.length; d++) {
                                var p = a.dataSeriesIndexes[d], k = this.data[p], m = k.dataPoints;
                                h = k.id;
                                this._eventManager.objectMap[h] = {
                                    objectType: "dataSeries",
                                    dataSeriesIndex: p
                                };
                                h = Y(h);
                                f.fillStyle = h;
                                h = [];
                                var n, g, l, q = 0, w = [], y = [];
                                if (0 < m.length) {
                                    var s = k._colorSet[q % k._colorSet.length], z = k.lineColor = k.options.lineColor || s, u = z;
                                    b.fillStyle = s;
                                    b.lineWidth = k.lineThickness;
                                    var C, E = "solid";
                                    if (b.setLineDash) {
                                        var A = H(k.nullDataLineDashType, k.lineThickness);
                                        E = k.lineDashType;
                                        C = H(E, k.lineThickness);
                                    }
                                    for (g = !1; q < m.length; q++) if (n = m[q].x.getTime ? m[q].x.getTime() : m[q].x, 
                                    !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !g))) if (null !== m[q].y && m[q].y.length && "number" === typeof m[q].y[0] && "number" === typeof m[q].y[1]) {
                                        n = a.axisX.convertValueToPixel(n);
                                        g = a.axisY.convertValueToPixel(m[q].y[0]);
                                        l = a.axisY.convertValueToPixel(m[q].y[1]);
                                        var B = k.dataPointIds[q];
                                        this._eventManager.objectMap[B] = {
                                            id: B,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: p,
                                            dataPointIndex: q,
                                            x1: n,
                                            y1: g,
                                            y2: l
                                        };
                                        w[w.length] = {
                                            x: n,
                                            y: g
                                        };
                                        y[y.length] = {
                                            x: n,
                                            y: l
                                        };
                                        q < m.length - 1 && (u !== (m[q].lineColor || z) || E !== (m[q].lineDashType || k.lineDashType)) && (u = m[q].lineColor || z, 
                                        w[w.length - 1].newStrokeStyle = u, b.setLineDash && (m[q].lineDashType ? (E = m[q].lineDashType, 
                                        w[w.length - 1].newLineDashArray = H(E, k.lineThickness)) : (E = k.lineDashType, 
                                        w[w.length - 1].newLineDashArray = C)));
                                        if (0 !== m[q].markerSize && (0 < m[q].markerSize || 0 < k.markerSize)) {
                                            var D = k.getMarkerProperties(q, n, g, b);
                                            h.push(D);
                                            var L = Y(B);
                                            v && h.push({
                                                x: n,
                                                y: g,
                                                ctx: f,
                                                type: D.type,
                                                size: D.size,
                                                color: L,
                                                borderColor: L,
                                                borderThickness: D.borderThickness
                                            });
                                            D = k.getMarkerProperties(q, n, l, b);
                                            h.push(D);
                                            L = Y(B);
                                            v && h.push({
                                                x: n,
                                                y: l,
                                                ctx: f,
                                                type: D.type,
                                                size: D.size,
                                                color: L,
                                                borderColor: L,
                                                borderThickness: D.borderThickness
                                            });
                                        }
                                        if (m[q].indexLabel || k.indexLabel || m[q].indexLabelFormatter || k.indexLabelFormatter) this._indexLabels.push({
                                            chartType: "rangeSplineArea",
                                            dataPoint: m[q],
                                            dataSeries: k,
                                            indexKeyword: 0,
                                            point: {
                                                x: n,
                                                y: g
                                            },
                                            direction: m[q].y[0] <= m[q].y[1] ? -1 : 1,
                                            color: s
                                        }), this._indexLabels.push({
                                            chartType: "rangeSplineArea",
                                            dataPoint: m[q],
                                            dataSeries: k,
                                            indexKeyword: 1,
                                            point: {
                                                x: n,
                                                y: l
                                            },
                                            direction: m[q].y[0] <= m[q].y[1] ? 1 : -1,
                                            color: s
                                        });
                                        g = !1;
                                    } else 0 < q && !g && (k.connectNullData ? b.setLineDash && 0 < w.length && (k.options.nullDataLineDashType || !m[q - 1].lineDashType) && (w[w.length - 1].newLineDashArray = A, 
                                    E = k.nullDataLineDashType) : (e(C, z), w = [], y = [])), g = !0;
                                    e(C, z);
                                    W.drawMarkers(h);
                                }
                            }
                            v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            b.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());
                            b.restore();
                            return {
                                source: c,
                                dest: this.plotArea.ctx,
                                animationCallback: N.xClipAnimation,
                                easingFunction: N.easing.linear,
                                animationBase: 0
                            };
                        }
                    };
                    l.prototype.renderWaterfall = function(a) {
                        var e = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : e;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var d, p, k, m, b = this._eventManager.ghostCtx, f = null, h = this.plotArea, r = 0, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0);
                            r = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                            p = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, .9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;
                            var n = a.axisX.dataInfo.minDiff;
                            isFinite(n) || (n = .3 * Math.abs(a.axisX.range));
                            n = this.options.dataPointWidth ? this.dataPointWidth : .6 * (h.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
                            this.dataPointMaxWidth && r > p && (r = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, p));
                            !this.dataPointMaxWidth && this.dataPointMinWidth && p < r && (p = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, r));
                            n < r && (n = r);
                            n > p && (n = p);
                            c.save();
                            v && this._eventManager.ghostCtx.save();
                            c.beginPath();
                            c.rect(h.x1, h.y1, h.width, h.height);
                            c.clip();
                            v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), 
                            this._eventManager.ghostCtx.clip());
                            for (var g = 0; g < a.dataSeriesIndexes.length; g++) {
                                var l = a.dataSeriesIndexes[g], w = this.data[l], y = w.dataPoints;
                                f = w._colorSet[0];
                                w.risingColor = w.options.risingColor ? w.options.risingColor : f;
                                w.fallingColor = w.options.fallingColor ? w.options.fallingColor : "#e40a0a";
                                var s = "number" === typeof w.options.lineThickness ? Math.round(w.lineThickness) : 1, z = 1 === Math.round(s) % 2 ? -.5 : 0;
                                if (0 < y.length) {
                                    var u = 5 < n && w.bevelEnabled ? !0 : !1, t = !1, C = null, A = null;
                                    for (r = 0; r < y.length; r++) if (y[r].getTime ? m = y[r].x.getTime() : m = y[r].x, 
                                    "number" !== typeof y[r].y) {
                                        if (0 < r && !t && w.connectNullData) var B = w.options.nullDataLineDashType || !y[r - 1].lineDashType ? w.nullDataLineDashType : y[r - 1].lineDashType;
                                        t = !0;
                                    } else {
                                        d = a.axisX.convertValueToPixel(m);
                                        p = 0 === w.dataPointEOs[r].cumulativeSum ? q : a.axisY.convertValueToPixel(w.dataPointEOs[r].cumulativeSum);
                                        k = 0 === w.dataPointEOs[r].cumulativeSumYStartValue ? q : a.axisY.convertValueToPixel(w.dataPointEOs[r].cumulativeSumYStartValue);
                                        d = a.axisX.reversed ? d + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + g) * n << 0 : d - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + g) * n << 0;
                                        var D = a.axisX.reversed ? d - n << 0 : d + n << 0;
                                        p > k && (f = p, p = k, k = f);
                                        a.axisY.reversed && (f = p, p = k, k = f);
                                        f = w.dataPointIds[r];
                                        this._eventManager.objectMap[f] = {
                                            id: f,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: l,
                                            dataPointIndex: r,
                                            x1: d,
                                            y1: p,
                                            x2: D,
                                            y2: k
                                        };
                                        var L = y[r].color ? y[r].color : 0 < y[r].y ? w.risingColor : w.fallingColor;
                                        aa(c, a.axisX.reversed ? D : d, a.axisY.reversed ? k : p, a.axisX.reversed ? d : D, a.axisY.reversed ? p : k, L, 0, L, u, u, !1, !1, w.fillOpacity);
                                        f = Y(f);
                                        v && aa(this._eventManager.ghostCtx, a.axisX.reversed ? D : d, p, a.axisX.reversed ? d : D, k, f, 0, null, !1, !1, !1, !1);
                                        var T;
                                        L = d;
                                        T = "undefined" !== typeof y[r].isIntermediateSum && !0 === y[r].isIntermediateSum || "undefined" !== typeof y[r].isCumulativeSum && !0 === y[r].isCumulativeSum ? 0 < y[r].y ? p : k : 0 < y[r].y ? k : p;
                                        0 < r && C && (!t || w.connectNullData) && (t && c.setLineDash && c.setLineDash(H(B, s)), 
                                        c.beginPath(), c.moveTo(C, A - z), c.lineTo(L, T - z), 0 < s && c.stroke(), v && (b.beginPath(), 
                                        b.moveTo(C, A - z), b.lineTo(L, T - z), 0 < s && b.stroke()));
                                        t = !1;
                                        C = D;
                                        A = 0 < y[r].y ? p : k;
                                        L = y[r].lineDashType ? y[r].lineDashType : w.options.lineDashType ? w.options.lineDashType : "shortDash";
                                        c.strokeStyle = y[r].lineColor ? y[r].lineColor : w.options.lineColor ? w.options.lineColor : "#9e9e9e";
                                        c.lineWidth = s;
                                        c.setLineDash && (L = H(L, s), c.setLineDash(L));
                                        (y[r].indexLabel || w.indexLabel || y[r].indexLabelFormatter || w.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "waterfall",
                                            dataPoint: y[r],
                                            dataSeries: w,
                                            point: {
                                                x: d + (D - d) / 2,
                                                y: 0 <= y[r].y ? p : k
                                            },
                                            direction: 0 > y[r].y === a.axisY.reversed ? 1 : -1,
                                            bounds: {
                                                x1: d,
                                                y1: Math.min(p, k),
                                                x2: D,
                                                y2: Math.max(p, k)
                                            },
                                            color: f
                                        });
                                    }
                                }
                            }
                            v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", 
                            a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), 
                            a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), 
                            this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), 
                            c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());
                            c.restore();
                            return {
                                source: e,
                                dest: this.plotArea.ctx,
                                animationCallback: N.fadeInAnimation,
                                easingFunction: N.easing.easeInQuad,
                                animationBase: 0
                            };
                        }
                    };
                    var ra = function(a, e, c, b, f, h, r, d, p) {
                        if (!(0 > c)) {
                            "undefined" === typeof d && (d = 1);
                            if (!v) {
                                var k = Number((r % (2 * Math.PI)).toFixed(8));
                                Number((h % (2 * Math.PI)).toFixed(8)) === k && (r -= 1e-4);
                            }
                            a.save();
                            a.globalAlpha = d;
                            "pie" === f ? (a.beginPath(), a.moveTo(e.x, e.y), a.arc(e.x, e.y, c, h, r, !1), 
                            a.fillStyle = b, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === f && (a.beginPath(), 
                            a.arc(e.x, e.y, c, h, r, !1), 0 <= p && a.arc(e.x, e.y, p * c, r, h, !0), a.closePath(), 
                            a.fillStyle = b, a.strokeStyle = "white", a.lineWidth = 2, a.fill());
                            a.globalAlpha = 1;
                            a.restore();
                        }
                    };
                    l.prototype.renderPie = function(a) {
                        function e() {
                            if (k && m) {
                                var a = 0, b = 0, c = 0, f = 0;
                                p(k.options.indexLabelMaxWidth) && (k.indexLabelMaxWidth = .33 * n.width);
                                for (var e = 0; e < m.length; e++) {
                                    var h = m[e], r = k.dataPointIds[e];
                                    g[e].id = r;
                                    g[e].objectType = "dataPoint";
                                    g[e].dataPointIndex = e;
                                    g[e].dataSeriesIndex = 0;
                                    var d = g[e], q = {
                                        percent: null,
                                        total: null
                                    }, x = null;
                                    q = l.getPercentAndTotal(k, h);
                                    if (k.indexLabelFormatter || h.indexLabelFormatter) x = {
                                        chart: l.options,
                                        dataSeries: k,
                                        dataPoint: h,
                                        total: q.total,
                                        percent: q.percent
                                    };
                                    q = h.indexLabelFormatter ? h.indexLabelFormatter(x) : h.indexLabel ? l.replaceKeywordsWithValue(h.indexLabel, h, k, e) : k.indexLabelFormatter ? k.indexLabelFormatter(x) : k.indexLabel ? l.replaceKeywordsWithValue(k.indexLabel, h, k, e) : h.label ? h.label : "";
                                    l._eventManager.objectMap[r] = d;
                                    d.center = {
                                        x: u.x,
                                        y: u.y
                                    };
                                    d.y = h.y;
                                    d.radius = A;
                                    d.percentInnerRadius = D;
                                    d.indexLabelText = q;
                                    d.indexLabelPlacement = k.indexLabelPlacement;
                                    d.indexLabelLineColor = h.indexLabelLineColor ? h.indexLabelLineColor : k.options.indexLabelLineColor ? k.options.indexLabelLineColor : h.color ? h.color : k._colorSet[e % k._colorSet.length];
                                    d.indexLabelLineThickness = p(h.indexLabelLineThickness) ? k.indexLabelLineThickness : h.indexLabelLineThickness;
                                    d.indexLabelLineDashType = h.indexLabelLineDashType ? h.indexLabelLineDashType : k.indexLabelLineDashType;
                                    d.indexLabelFontColor = h.indexLabelFontColor ? h.indexLabelFontColor : k.indexLabelFontColor;
                                    d.indexLabelFontStyle = h.indexLabelFontStyle ? h.indexLabelFontStyle : k.indexLabelFontStyle;
                                    d.indexLabelFontWeight = h.indexLabelFontWeight ? h.indexLabelFontWeight : k.indexLabelFontWeight;
                                    d.indexLabelFontSize = p(h.indexLabelFontSize) ? k.indexLabelFontSize : h.indexLabelFontSize;
                                    d.indexLabelFontFamily = h.indexLabelFontFamily ? h.indexLabelFontFamily : k.indexLabelFontFamily;
                                    d.indexLabelBackgroundColor = h.indexLabelBackgroundColor ? h.indexLabelBackgroundColor : k.options.indexLabelBackgroundColor ? k.options.indexLabelBackgroundColor : k.indexLabelBackgroundColor;
                                    d.indexLabelMaxWidth = h.indexLabelMaxWidth ? h.indexLabelMaxWidth : k.indexLabelMaxWidth;
                                    d.indexLabelWrap = "undefined" !== typeof h.indexLabelWrap ? h.indexLabelWrap : k.indexLabelWrap;
                                    d.indexLabelTextAlign = h.indexLabelTextAlign ? h.indexLabelTextAlign : k.indexLabelTextAlign ? k.indexLabelTextAlign : "left";
                                    d.startAngle = 0 === e ? k.startAngle ? k.startAngle / 180 * Math.PI : 0 : g[e - 1].endAngle;
                                    d.startAngle = (d.startAngle + 2 * Math.PI) % (2 * Math.PI);
                                    d.endAngle = d.startAngle + 2 * Math.PI / t * Math.abs(h.y);
                                    h = (d.endAngle + d.startAngle) / 2;
                                    h = (h + 2 * Math.PI) % (2 * Math.PI);
                                    d.midAngle = h;
                                    if (d.midAngle > Math.PI / 2 - s && d.midAngle < Math.PI / 2 + s) {
                                        if (0 === a || g[c].midAngle > d.midAngle) c = e;
                                        a++;
                                    } else if (d.midAngle > 3 * Math.PI / 2 - s && d.midAngle < 3 * Math.PI / 2 + s) {
                                        if (0 === b || g[f].midAngle > d.midAngle) f = e;
                                        b++;
                                    }
                                    d.hemisphere = h > Math.PI / 2 && h <= 3 * Math.PI / 2 ? "left" : "right";
                                    d.indexLabelTextBlock = new ka(l.plotArea.ctx, {
                                        fontSize: d.indexLabelFontSize,
                                        fontFamily: d.indexLabelFontFamily,
                                        fontColor: d.indexLabelFontColor,
                                        fontStyle: d.indexLabelFontStyle,
                                        fontWeight: d.indexLabelFontWeight,
                                        textAlign: d.indexLabelTextAlign,
                                        backgroundColor: d.indexLabelBackgroundColor,
                                        maxWidth: d.indexLabelMaxWidth,
                                        maxHeight: d.indexLabelWrap ? 5 * d.indexLabelFontSize : 1.5 * d.indexLabelFontSize,
                                        text: d.indexLabelText,
                                        padding: 0,
                                        textBaseline: "middle"
                                    });
                                    d.indexLabelTextBlock.measureText();
                                }
                                r = h = 0;
                                q = !1;
                                for (e = 0; e < m.length; e++) d = g[(c + e) % m.length], 1 < a && d.midAngle > Math.PI / 2 - s && d.midAngle < Math.PI / 2 + s && (h <= a / 2 && !q ? (d.hemisphere = "right", 
                                h++) : (d.hemisphere = "left", q = !0));
                                q = !1;
                                for (e = 0; e < m.length; e++) d = g[(f + e) % m.length], 1 < b && d.midAngle > 3 * Math.PI / 2 - s && d.midAngle < 3 * Math.PI / 2 + s && (r <= b / 2 && !q ? (d.hemisphere = "left", 
                                r++) : (d.hemisphere = "right", q = !0));
                            }
                        }
                        function c(a, b) {
                            var c = l.plotArea.ctx;
                            c.clearRect(n.x1, n.y1, n.width, n.height);
                            c.fillStyle = l.backgroundColor;
                            c.fillRect(n.x1, n.y1, n.width, n.height);
                            for (c = 0; c < m.length; c++) {
                                var e = g[c].startAngle, f = g[c].endAngle;
                                if (f > e) {
                                    var h = .07 * A * Math.cos(g[c].midAngle), d = .07 * A * Math.sin(g[c].midAngle), r = !1;
                                    if (m[c].exploded) {
                                        if (1e-9 < Math.abs(g[c].center.x - (u.x + h)) || 1e-9 < Math.abs(g[c].center.y - (u.y + d))) g[c].center.x = u.x + h * a, 
                                        g[c].center.y = u.y + d * a, r = !0;
                                    } else if (0 < Math.abs(g[c].center.x - u.x) || 0 < Math.abs(g[c].center.y - u.y)) g[c].center.x = u.x + h * (1 - a), 
                                    g[c].center.y = u.y + d * (1 - a), r = !0;
                                    r && b && (h = {}, h.dataSeries = k, h.dataPoint = k.dataPoints[c], h.index = c, 
                                    l.toolTip.highlightObjects([ h ]));
                                    ra(l.plotArea.ctx, g[c].center, g[c].radius, m[c].color ? m[c].color : k._colorSet[c % k._colorSet.length], k.type, e, f, k.fillOpacity, g[c].percentInnerRadius);
                                }
                            }
                            c = l.plotArea.ctx;
                            c.save();
                            c.fillStyle = "black";
                            c.strokeStyle = "grey";
                            c.textBaseline = "middle";
                            c.lineJoin = "round";
                            for (e = e = 0; e < m.length; e++) f = g[e], f.indexLabelText && (f.indexLabelTextBlock.y -= f.indexLabelTextBlock.height / 2 - f.indexLabelTextBlock.fontSize / 2, 
                            h = 0, h = "left" === f.hemisphere ? "inside" !== k.indexLabelPlacement ? -(f.indexLabelTextBlock.width + q) : -f.indexLabelTextBlock.width / 2 : "inside" !== k.indexLabelPlacement ? q : -f.indexLabelTextBlock.width / 2, 
                            f.indexLabelTextBlock.x += h, f.indexLabelTextBlock.render(!0), f.indexLabelTextBlock.x -= h, 
                            f.indexLabelTextBlock.y += f.indexLabelTextBlock.height / 2 - f.indexLabelTextBlock.fontSize / 2, 
                            "inside" !== f.indexLabelPlacement && 0 < f.indexLabelLineThickness && (h = f.center.x + A * Math.cos(f.midAngle), 
                            d = f.center.y + A * Math.sin(f.midAngle), c.strokeStyle = f.indexLabelLineColor, 
                            c.lineWidth = f.indexLabelLineThickness, c.setLineDash && c.setLineDash(H(f.indexLabelLineDashType, f.indexLabelLineThickness)), 
                            c.beginPath(), c.moveTo(h, d), c.lineTo(f.indexLabelTextBlock.x, f.indexLabelTextBlock.y), 
                            c.lineTo(f.indexLabelTextBlock.x + ("left" === f.hemisphere ? -q : q), f.indexLabelTextBlock.y), 
                            c.stroke()), c.lineJoin = "miter");
                            c.save();
                        }
                        function b(a, b) {
                            var c = 0, f = (c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2, 
                            a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2), g = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height / 2, e = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2;
                            return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? g - f : c - e;
                        }
                        function f(a) {
                            for (var c = null, f = 1; f < m.length; f++) if (c = (a + f + g.length) % g.length, 
                            g[c].hemisphere !== g[a].hemisphere) {
                                c = null;
                                break;
                            } else if (g[c].indexLabelText && c !== a && (0 > b(g[c], g[a]) || ("right" === g[a].hemisphere ? g[c].indexLabelTextBlock.y >= g[a].indexLabelTextBlock.y : g[c].indexLabelTextBlock.y <= g[a].indexLabelTextBlock.y))) break; else c = null;
                            return c;
                        }
                        function h(a, c, e) {
                            e = (e || 0) + 1;
                            if (1e3 < e) return 0;
                            c = c || 0;
                            var d = 0, r = u.y - 1 * w, k = u.y + 1 * w;
                            if (0 <= a && a < m.length) {
                                var n = g[a];
                                if (0 > c && n.indexLabelTextBlock.y < r || 0 < c && n.indexLabelTextBlock.y > k) return 0;
                                var q = 0, p = 0;
                                p = q = q = 0;
                                0 > c ? n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 > r && n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 + c < r && (c = -(r - (n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 + c))) : n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2 < r && n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2 + c > k && (c = n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2 + c - k);
                                c = n.indexLabelTextBlock.y + c;
                                r = 0;
                                r = "right" === n.hemisphere ? u.x + Math.sqrt(Math.pow(w, 2) - Math.pow(c - u.y, 2)) : u.x - Math.sqrt(Math.pow(w, 2) - Math.pow(c - u.y, 2));
                                p = u.x + A * Math.cos(n.midAngle);
                                q = u.y + A * Math.sin(n.midAngle);
                                q = Math.sqrt(Math.pow(r - p, 2) + Math.pow(c - q, 2));
                                p = Math.acos(A / w);
                                q = Math.acos((w * w + A * A - q * q) / (2 * A * w));
                                c = q < p ? c - n.indexLabelTextBlock.y : 0;
                                r = null;
                                for (k = 1; k < m.length; k++) if (r = (a - k + g.length) % g.length, g[r].hemisphere !== g[a].hemisphere) {
                                    r = null;
                                    break;
                                } else if (g[r].indexLabelText && g[r].hemisphere === g[a].hemisphere && r !== a && (0 > b(g[r], g[a]) || ("right" === g[a].hemisphere ? g[r].indexLabelTextBlock.y <= g[a].indexLabelTextBlock.y : g[r].indexLabelTextBlock.y >= g[a].indexLabelTextBlock.y))) break; else r = null;
                                p = r;
                                q = f(a);
                                k = r = 0;
                                0 > c ? (k = "right" === n.hemisphere ? p : q, d = c, null !== k && (p = -c, c = n.indexLabelTextBlock.y - n.indexLabelTextBlock.height / 2 - (g[k].indexLabelTextBlock.y + g[k].indexLabelTextBlock.height / 2), 
                                c - p < v && (r = -p, k = h(k, r, e + 1), +k.toFixed(z) > +r.toFixed(z) && (d = c > v ? -(c - v) : -(p - (k - r)))))) : 0 < c && (k = "right" === n.hemisphere ? q : p, 
                                d = c, null !== k && (p = c, c = g[k].indexLabelTextBlock.y - g[k].indexLabelTextBlock.height / 2 - (n.indexLabelTextBlock.y + n.indexLabelTextBlock.height / 2), 
                                c - p < v && (r = p, k = h(k, r, e + 1), +k.toFixed(z) < +r.toFixed(z) && (d = c > v ? c - v : p - (r - k)))));
                                d && (e = n.indexLabelTextBlock.y + d, c = 0, c = "right" === n.hemisphere ? u.x + Math.sqrt(Math.pow(w, 2) - Math.pow(e - u.y, 2)) : u.x - Math.sqrt(Math.pow(w, 2) - Math.pow(e - u.y, 2)), 
                                n.midAngle > Math.PI / 2 - s && n.midAngle < Math.PI / 2 + s ? (r = (a - 1 + g.length) % g.length, 
                                r = g[r], a = g[(a + 1 + g.length) % g.length], "left" === n.hemisphere && "right" === r.hemisphere && c > r.indexLabelTextBlock.x ? c = r.indexLabelTextBlock.x - 15 : "right" === n.hemisphere && "left" === a.hemisphere && c < a.indexLabelTextBlock.x && (c = a.indexLabelTextBlock.x + 15)) : n.midAngle > 3 * Math.PI / 2 - s && n.midAngle < 3 * Math.PI / 2 + s && (r = (a - 1 + g.length) % g.length, 
                                r = g[r], a = g[(a + 1 + g.length) % g.length], "right" === n.hemisphere && "left" === r.hemisphere && c < r.indexLabelTextBlock.x ? c = r.indexLabelTextBlock.x + 15 : "left" === n.hemisphere && "right" === a.hemisphere && c > a.indexLabelTextBlock.x && (c = a.indexLabelTextBlock.x - 15)), 
                                n.indexLabelTextBlock.y = e, n.indexLabelTextBlock.x = c, n.indexLabelAngle = Math.atan2(n.indexLabelTextBlock.y - u.y, n.indexLabelTextBlock.x - u.x));
                            }
                            return d;
                        }
                        function r() {
                            var a = l.plotArea.ctx;
                            a.fillStyle = "grey";
                            a.strokeStyle = "grey";
                            a.font = "16px Arial";
                            a.textBaseline = "middle";
                            var c = a = 0, e = 0, r = !0;
                            for (c = 0; 10 > c && (1 > c || 0 < e); c++) {
                                if (k.radius || !k.radius && "undefined" !== typeof k.innerRadius && null !== k.innerRadius && A - e <= B) r = !1;
                                r && (A -= e);
                                e = 0;
                                if ("inside" !== k.indexLabelPlacement) {
                                    w = A * y;
                                    for (a = 0; a < m.length; a++) {
                                        var d = g[a];
                                        d.indexLabelTextBlock.x = u.x + w * Math.cos(d.midAngle);
                                        d.indexLabelTextBlock.y = u.y + w * Math.sin(d.midAngle);
                                        d.indexLabelAngle = d.midAngle;
                                        d.radius = A;
                                        d.percentInnerRadius = D;
                                    }
                                    var p, s;
                                    for (a = 0; a < m.length; a++) {
                                        d = g[a];
                                        var x = f(a);
                                        if (null !== x) {
                                            p = g[a];
                                            s = g[x];
                                            var t = 0;
                                            t = b(p, s) - v;
                                            if (0 > t) {
                                                for (var C = s = 0, E = 0; E < m.length; E++) E !== a && g[E].hemisphere === d.hemisphere && (g[E].indexLabelTextBlock.y < d.indexLabelTextBlock.y ? s++ : C++);
                                                s = t / (s + C || 1) * C;
                                                C = -1 * (t - s);
                                                var H = E = 0;
                                                "right" === d.hemisphere ? (E = h(a, s), C = -1 * (t - E), H = h(x, C), +H.toFixed(z) < +C.toFixed(z) && +E.toFixed(z) <= +s.toFixed(z) && h(a, -(C - H))) : (E = h(x, s), 
                                                C = -1 * (t - E), H = h(a, C), +H.toFixed(z) < +C.toFixed(z) && +E.toFixed(z) <= +s.toFixed(z) && h(x, -(C - H)));
                                            }
                                        }
                                    }
                                } else for (a = 0; a < m.length; a++) d = g[a], w = "pie" === k.type ? .7 * A : .85 * A, 
                                x = u.x + w * Math.cos(d.midAngle), s = u.y + w * Math.sin(d.midAngle), d.indexLabelTextBlock.x = x, 
                                d.indexLabelTextBlock.y = s;
                                for (a = 0; a < m.length; a++) if (d = g[a], x = d.indexLabelTextBlock.measureText(), 
                                0 !== x.height && 0 !== x.width) x = x = 0, "right" === d.hemisphere ? (x = n.x2 - (d.indexLabelTextBlock.x + d.indexLabelTextBlock.width + q), 
                                x *= -1) : x = n.x1 - (d.indexLabelTextBlock.x - d.indexLabelTextBlock.width - q), 
                                0 < x && (!r && d.indexLabelText && (s = "right" === d.hemisphere ? n.x2 - d.indexLabelTextBlock.x : d.indexLabelTextBlock.x - n.x1, 
                                .3 * d.indexLabelTextBlock.maxWidth > s ? d.indexLabelText = "" : d.indexLabelTextBlock.maxWidth = .85 * s, 
                                .3 * d.indexLabelTextBlock.maxWidth < s && (d.indexLabelTextBlock.x -= "right" === d.hemisphere ? 2 : -2)), 
                                Math.abs(d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 - u.y) < A || Math.abs(d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 - u.y) < A) && (x /= Math.abs(Math.cos(d.indexLabelAngle)), 
                                9 < x && (x *= .3), x > e && (e = x)), x = x = 0, 0 < d.indexLabelAngle && d.indexLabelAngle < Math.PI ? (x = n.y2 - (d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 + 5), 
                                x *= -1) : x = n.y1 - (d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 - 5), 
                                0 < x && (!r && d.indexLabelText && (s = 0 < d.indexLabelAngle && d.indexLabelAngle < Math.PI ? -1 : 1, 
                                0 === h(a, x * s) && h(a, 2 * s)), Math.abs(d.indexLabelTextBlock.x - u.x) < A && (x /= Math.abs(Math.sin(d.indexLabelAngle)), 
                                9 < x && (x *= .3), x > e && (e = x)));
                                var M = function(a, b, c) {
                                    for (var f = [], e = 0; f.push(g[b]), b !== c; b = (b + 1 + m.length) % m.length) ;
                                    f.sort((function(a, b) {
                                        return a.y - b.y;
                                    }));
                                    for (b = 0; b < f.length; b++) if (c = f[b], e < .7 * a) e += c.indexLabelTextBlock.height, 
                                    c.indexLabelTextBlock.text = "", c.indexLabelText = "", c.indexLabelTextBlock.measureText(); else break;
                                };
                                (function() {
                                    for (var a = -1, c = -1, e = 0, h = !1, d = 0; d < m.length; d++) if (h = !1, p = g[d], 
                                    p.indexLabelText) {
                                        var r = f(d);
                                        if (null !== r) {
                                            var k = g[r];
                                            t = 0;
                                            t = b(p, k);
                                            var n;
                                            if (n = 0 > t) {
                                                n = p.indexLabelTextBlock.x;
                                                var l = p.indexLabelTextBlock.y - p.indexLabelTextBlock.height / 2, x = p.indexLabelTextBlock.y + p.indexLabelTextBlock.height / 2, s = k.indexLabelTextBlock.y - k.indexLabelTextBlock.height / 2, u = k.indexLabelTextBlock.x + k.indexLabelTextBlock.width, w = k.indexLabelTextBlock.y + k.indexLabelTextBlock.height / 2;
                                                n = p.indexLabelTextBlock.x + p.indexLabelTextBlock.width < k.indexLabelTextBlock.x - q || n > u + q || l > w + q || x < s - q ? !1 : !0;
                                            }
                                            n ? (0 > a && (a = d), r !== a && (c = r, e += -t), 0 === d % Math.max(m.length / 10, 3) && (h = !0)) : h = !0;
                                            h && 0 < e && 0 <= a && 0 <= c && (M(e, a, c), c = a = -1, e = 0);
                                        }
                                    }
                                    0 < e && M(e, a, c);
                                })();
                            }
                        }
                        function d() {
                            l.plotArea.layoutManager.reset();
                            l.title && (l.title.dockInsidePlotArea || "center" === l.title.horizontalAlign && "center" === l.title.verticalAlign) && l.title.render();
                            if (l.subtitles) for (var a = 0; a < l.subtitles.length; a++) {
                                var b = l.subtitles[a];
                                (b.dockInsidePlotArea || "center" === b.horizontalAlign && "center" === b.verticalAlign) && b.render();
                            }
                            l.legend && (l.legend.dockInsidePlotArea || "center" === l.legend.horizontalAlign && "center" === l.legend.verticalAlign) && (l.legend.setLayout(), 
                            l.legend.render());
                        }
                        var l = this;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            var w, k = this.data[a.dataSeriesIndexes[0]], m = k.dataPoints, q = 10, n = this.plotArea, g = k.dataPointEOs, v = 2, y = 1.3, s = 20 / 180 * Math.PI, z = 6, u = {
                                x: (n.x2 + n.x1) / 2,
                                y: (n.y2 + n.y1) / 2
                            }, t = 0;
                            a = !1;
                            for (var C = 0; C < m.length; C++) t += Math.abs(m[C].y), !a && "undefined" !== typeof m[C].indexLabel && null !== m[C].indexLabel && 0 < m[C].indexLabel.toString().length && (a = !0), 
                            !a && "undefined" !== typeof m[C].label && null !== m[C].label && 0 < m[C].label.toString().length && (a = !0);
                            if (0 !== t) {
                                a = a || "undefined" !== typeof k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length;
                                var A = "inside" !== k.indexLabelPlacement && a ? .75 * Math.min(n.width, n.height) / 2 : .92 * Math.min(n.width, n.height) / 2;
                                k.radius && (A = Ua(k.radius, A));
                                var B = "undefined" !== typeof k.innerRadius && null !== k.innerRadius ? Ua(k.innerRadius, A) : .7 * A;
                                k.radius = A;
                                "doughnut" === k.type && (k.innerRadius = B);
                                var D = Math.min(B / A, (A - 1) / A);
                                this.pieDoughnutClickHandler = function(a) {
                                    l.isAnimating || !p(a.dataSeries.explodeOnClick) && !a.dataSeries.explodeOnClick || (a = a.dataPoint, 
                                    a.exploded = a.exploded ? !1 : !0, 1 < this.dataPoints.length && l._animator.animate(0, 500, (function(a) {
                                        c(a, !0);
                                        d();
                                        l.dispatchEvent("dataAnimationIterationEnd", {
                                            chart: l
                                        });
                                        l.dispatchEvent("dataAnimationEnd", {
                                            chart: l
                                        });
                                    })));
                                };
                                e();
                                r();
                                r();
                                r();
                                r();
                                this.disableToolTip = !0;
                                this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, (function(a) {
                                    var b = l.plotArea.ctx;
                                    b.clearRect(n.x1, n.y1, n.width, n.height);
                                    b.fillStyle = l.backgroundColor;
                                    b.fillRect(n.x1, n.y1, n.width, n.height);
                                    b = g[0].startAngle + 2 * Math.PI * a;
                                    for (var c = 0; c < m.length; c++) {
                                        var e = 0 === c ? g[c].startAngle : f, f = e + (g[c].endAngle - g[c].startAngle), h = !1;
                                        f > b && (f = b, h = !0);
                                        var r = m[c].color ? m[c].color : k._colorSet[c % k._colorSet.length];
                                        f > e && ra(l.plotArea.ctx, g[c].center, g[c].radius, r, k.type, e, f, k.fillOpacity, g[c].percentInnerRadius);
                                        if (h) break;
                                    }
                                    d();
                                    l.dispatchEvent("dataAnimationIterationEnd", {
                                        chart: l
                                    });
                                    1 <= a && l.dispatchEvent("dataAnimationEnd", {
                                        chart: l
                                    });
                                }), (function() {
                                    l.disableToolTip = !1;
                                    l._animator.animate(0, l.animatedRender ? 500 : 0, (function(a) {
                                        c(a, !1);
                                        d();
                                        l.dispatchEvent("dataAnimationIterationEnd", {
                                            chart: l
                                        });
                                    }));
                                    l.dispatchEvent("dataAnimationEnd", {
                                        chart: l
                                    });
                                }));
                            }
                        }
                    };
                    var ta = function(a, e, c, b) {
                        "undefined" === typeof c && (c = 1);
                        0 >= Math.round(e.y4 - e.y1) || (a.save(), a.globalAlpha = c, a.beginPath(), a.moveTo(Math.round(e.x1), Math.round(e.y1)), 
                        a.lineTo(Math.round(e.x2), Math.round(e.y2)), a.lineTo(Math.round(e.x3), Math.round(e.y3)), 
                        a.lineTo(Math.round(e.x4), Math.round(e.y4)), "undefined" !== e.x5 && (a.lineTo(Math.round(e.x5), Math.round(e.y5)), 
                        a.lineTo(Math.round(e.x6), Math.round(e.y6))), a.closePath(), a.fillStyle = b ? b : e.color, 
                        a.fill(), a.globalAplha = 1, a.restore());
                    };
                    l.prototype.renderFunnel = function(a) {
                        function e() {
                            for (var a = 0, b = [], c = 0; c < z.length; c++) {
                                if ("undefined" === typeof z[c].y) return -1;
                                z[c].y = "number" === typeof z[c].y ? z[c].y : 0;
                                a += Math.abs(z[c].y);
                            }
                            if (0 === a) return -1;
                            for (c = b[0] = 0; c < z.length; c++) b.push(Math.abs(z[c].y) * D / a);
                            return b;
                        }
                        function c() {
                            var f, g, a = U, b = X, c = M, e = Z;
                            f = O;
                            g = S - Q;
                            e = Math.abs((g - f) * (b - a + (e - c)) / 2);
                            c = Z - M;
                            f = g - f;
                            g = c * (g - S);
                            g = Math.abs(g);
                            g = e + g;
                            e = [];
                            for (var h = 0, d = 0; d < z.length; d++) {
                                if ("undefined" === typeof z[d].y) return -1;
                                z[d].y = "number" === typeof z[d].y ? z[d].y : 0;
                                h += Math.abs(z[d].y);
                            }
                            if (0 === h) return -1;
                            var m, n, r = e[0] = 0, k = 0;
                            for (b = b - a, r = !1, d = 0; d < z.length; d++) a = Math.abs(z[d].y) * g / h, 
                            r ? m = 0 == Number(c.toFixed(3)) ? 0 : a / c : (n = ca * ca * b * b - 4 * Math.abs(ca) * a, 
                            0 > n ? (n = c, r = (b + n) * (f - k) / 2, a -= r, m = f - k, k += f - k, m += 0 == n ? 0 : a / n, 
                            k += a / n, r = !0) : (m = (Math.abs(ca) * b - Math.sqrt(n)) / 2, n = b - 2 * m / Math.abs(ca), 
                            k += m, k > f && (k -= m, n = c, r = (b + n) * (f - k) / 2, a -= r, m = f - k, k += f - k, 
                            m += a / n, k += a / n, r = !0), b = n)), e.push(m);
                            return e;
                        }
                        function b() {
                            if (s && z) {
                                for (var a, b, c, f, e, h, d, r, k, m, n, q, l, x, u, w = [], t = [], J = {
                                    percent: null,
                                    total: null
                                }, C = null, A = 0; A < z.length; A++) u = R[A], u = "undefined" !== typeof u.x5 ? (u.y2 + u.y4) / 2 : (u.y2 + u.y3) / 2, 
                                u = g(u).x2 + 1, w[A] = K - u - Y;
                                u = .5 * Y;
                                A = 0;
                                for (var E = z.length - 1; A < z.length || 0 <= E; A++, E--) {
                                    b = s.reversed ? z[E] : z[A];
                                    a = b.color ? b.color : s.reversed ? s._colorSet[(z.length - 1 - A) % s._colorSet.length] : s._colorSet[A % s._colorSet.length];
                                    c = b.indexLabelPlacement || s.indexLabelPlacement || "outside";
                                    x = b.indexLabelTextAlign || s.indexLabelTextAlign || "left";
                                    f = b.indexLabelBackgroundColor || s.indexLabelBackgroundColor || (v ? "transparent" : null);
                                    e = b.indexLabelFontColor || s.indexLabelFontColor || "#979797";
                                    h = p(b.indexLabelFontSize) ? s.indexLabelFontSize : b.indexLabelFontSize;
                                    d = b.indexLabelFontStyle || s.indexLabelFontStyle || "normal";
                                    r = b.indexLabelFontFamily || s.indexLabelFontFamily || "arial";
                                    k = b.indexLabelFontWeight || s.indexLabelFontWeight || "normal";
                                    a = b.indexLabelLineColor || s.options.indexLabelLineColor || a;
                                    m = "number" === typeof b.indexLabelLineThickness ? b.indexLabelLineThickness : "number" === typeof s.indexLabelLineThickness ? s.indexLabelLineThickness : 2;
                                    n = b.indexLabelLineDashType || s.indexLabelLineDashType || "solid";
                                    q = "undefined" !== typeof b.indexLabelWrap ? b.indexLabelWrap : "undefined" !== typeof s.indexLabelWrap ? s.indexLabelWrap : !0;
                                    l = s.dataPointIds[A];
                                    y._eventManager.objectMap[l] = {
                                        id: l,
                                        objectType: "dataPoint",
                                        dataPointIndex: A,
                                        dataSeriesIndex: 0,
                                        funnelSection: R[s.reversed ? z.length - 1 - A : A]
                                    };
                                    "inside" === s.indexLabelPlacement && (w[A] = A !== da ? s.reversed ? R[A].x2 - R[A].x1 : R[A].x3 - R[A].x4 : R[A].x3 - R[A].x6, 
                                    20 > w[A] && (w[A] = A !== da ? s.reversed ? R[A].x3 - R[A].x4 : R[A].x2 - R[A].x1 : R[A].x2 - R[A].x1, 
                                    w[A] /= 2));
                                    l = b.indexLabelMaxWidth ? b.indexLabelMaxWidth : s.options.indexLabelMaxWidth ? s.indexLabelMaxWidth : w[A];
                                    if (l > w[A] || 0 > l) l = w[A];
                                    t[A] = "inside" === s.indexLabelPlacement ? q ? Math.max(R[A].height, h) : 1.5 * h : !1;
                                    J = y.getPercentAndTotal(s, b);
                                    if (s.indexLabelFormatter || b.indexLabelFormatter) C = {
                                        chart: y.options,
                                        dataSeries: s,
                                        dataPoint: b,
                                        total: J.total,
                                        percent: J.percent
                                    };
                                    b = b.indexLabelFormatter ? b.indexLabelFormatter(C) : b.indexLabel ? y.replaceKeywordsWithValue(b.indexLabel, b, s, A) : s.indexLabelFormatter ? s.indexLabelFormatter(C) : s.indexLabel ? y.replaceKeywordsWithValue(s.indexLabel, b, s, A) : b.label ? b.label : "";
                                    0 >= m && (m = 0);
                                    1e3 > l && 1e3 - l < u && (l += 1e3 - l);
                                    p(s.options.indexLabelMaxWidth) && (s.indexLabelMaxWidth = p(s.indexLabelMaxWidth) ? l : Math.max(l, s.indexLabelMaxWidth));
                                    P.roundRect || Aa(P);
                                    c = new ka(P, {
                                        fontSize: h,
                                        fontFamily: r,
                                        fontColor: e,
                                        fontStyle: d,
                                        fontWeight: k,
                                        horizontalAlign: c,
                                        textAlign: x,
                                        backgroundColor: f,
                                        maxWidth: l,
                                        maxHeight: !1 === t[A] ? q ? 4.28571429 * h : 1.5 * h : t[A],
                                        text: b,
                                        padding: ea,
                                        textBaseline: "middle"
                                    });
                                    c.measureText();
                                    c.height = c.height === 2 * c.padding ? 0 : c.height;
                                    c.width = c.width === 2 * c.padding ? 0 : c.width;
                                    G.push({
                                        textBlock: c,
                                        id: s.reversed ? E : A,
                                        isDirty: !1,
                                        lineColor: a,
                                        lineThickness: m,
                                        lineDashType: n,
                                        height: c.height < c.maxHeight ? c.height : c.maxHeight,
                                        width: c.width < c.maxWidth ? c.width : c.maxWidth
                                    });
                                }
                            }
                        }
                        function f() {
                            var a, b, c, f, e, g = [];
                            e = !1;
                            c = 0;
                            for (var h, d = K - X - Y / 2, r = (d = s.options.indexLabelMaxWidth ? s.indexLabelMaxWidth > d ? d : s.indexLabelMaxWidth : d, 
                            G.length - 1); 0 <= r; r--) {
                                h = z[G[r].id];
                                c = G[r];
                                f = c.textBlock;
                                b = (a = n(r) < R.length ? G[n(r)] : null) ? a.textBlock : null;
                                c = c.height;
                                a && f.y + c + ea > b.y && (e = !0);
                                c = h.indexLabelMaxWidth || d;
                                if (c > d || 0 > c) c = d;
                                g.push(c);
                            }
                            if (e) for (r = G.length - 1; 0 <= r; r--) a = R[r], G[r].textBlock.maxWidth = g[g.length - (r + 1)], 
                            G[r].textBlock.measureText(), G[r].textBlock.height = G[r].textBlock.height === 2 * G[r].textBlock.padding ? 0 : G[r].textBlock.height, 
                            G[r].textBlock.width = G[r].textBlock.width === 2 * G[r].textBlock.padding ? 0 : G[r].textBlock.width, 
                            G[r].textBlock.x = K - d, c = G[r].textBlock.height < G[r].textBlock.maxHeight ? G[r].textBlock.height : G[r].textBlock.maxHeight, 
                            e = G[r].textBlock.width < G[r].textBlock.maxWidth ? G[r].textBlock.width : G[r].textBlock.maxWidth, 
                            G[r].height = c, G[r].width = e, c = "undefined" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, 
                            G[r].textBlock.y = c - G[r].height / 2, s.reversed ? (G[r].textBlock.y + G[r].height > V + E && (G[r].textBlock.y = V + E - G[r].height), 
                            G[r].textBlock.y < va - E && (G[r].textBlock.y = va - E)) : (G[r].textBlock.y < V - E && (G[r].textBlock.y = V - E), 
                            G[r].textBlock.y + G[r].height > va + E && (G[r].textBlock.y = va + E - G[r].height));
                        }
                        function h() {
                            var a, b, c, f;
                            if ("inside" !== s.indexLabelPlacement) for (var e = 0; e < R.length; e++) 0 == G[e].textBlock.text.length ? G[e].isDirty = !0 : (a = R[e], 
                            c = "undefined" !== typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, b = s.reversed ? "undefined" !== typeof a.x5 ? c > W ? g(c).x2 + 1 : (a.x2 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1 : "undefined" !== typeof a.x5 ? c < W ? g(c).x2 + 1 : (a.x4 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1, 
                            G[e].textBlock.x = b + Y, G[e].textBlock.y = c - G[e].height / 2, s.reversed ? (G[e].textBlock.y + G[e].height > V + E && (G[e].textBlock.y = V + E - G[e].height), 
                            G[e].textBlock.y < va - E && (G[e].textBlock.y = va - E)) : (G[e].textBlock.y < V - E && (G[e].textBlock.y = V - E), 
                            G[e].textBlock.y + G[e].height > va + E && (G[e].textBlock.y = va + E - G[e].height))); else for (e = 0; e < R.length; e++) 0 == G[e].textBlock.text.length ? G[e].isDirty = !0 : (a = R[e], 
                            b = a.height, c = G[e].height, f = G[e].width, b >= c ? (b = e != da ? (a.x4 + a.x3) / 2 - f / 2 : (a.x5 + a.x4) / 2 - f / 2, 
                            c = e != da ? (a.y1 + a.y3) / 2 - c / 2 : (a.y1 + a.y4) / 2 - c / 2, G[e].textBlock.x = b, 
                            G[e].textBlock.y = c) : G[e].isDirty = !0);
                        }
                        function d() {
                            function a(b, c) {
                                var e;
                                if (0 > b || b >= G.length) return 0;
                                var f, g = G[b].textBlock;
                                if (0 > c) {
                                    c *= -1;
                                    f = q(b);
                                    e = l(f, b);
                                    if (e >= c) return g.y -= c, c;
                                    if (0 == b) return 0 < e && (g.y -= e), e;
                                    e += a(f, -(c - e));
                                    0 < e && (g.y -= e);
                                    return e;
                                }
                                f = n(b);
                                e = l(b, f);
                                if (e >= c) return g.y += c, c;
                                if (b == R.length - 1) return 0 < e && (g.y += e), e;
                                e += a(f, c - e);
                                0 < e && (g.y += e);
                                return e;
                            }
                            function b() {
                                var a, e, f, g, d, h = 0;
                                g = (S - O + 2 * E) / m;
                                d = m;
                                for (var r, k = 1; k < d; k++) {
                                    f = k * g;
                                    for (var p = G.length - 1; 0 <= p; p--) !G[p].isDirty && G[p].textBlock.y < f && G[p].textBlock.y + G[p].height > f && (r = n(p), 
                                    !(r >= G.length - 1) && G[p].textBlock.y + G[p].height + ea > G[r].textBlock.y && (G[p].textBlock.y = G[p].textBlock.y + G[p].height - f > f - G[p].textBlock.y ? f + 1 : f - G[p].height - 1));
                                }
                                for (r = R.length - 1; 0 < r; r--) if (!G[r].isDirty) {
                                    f = q(r);
                                    if (0 > f && (f = 0, G[f].isDirty)) break;
                                    if (G[r].textBlock.y < G[f].textBlock.y + G[f].height) {
                                        e = e || r;
                                        g = r;
                                        for (d = 0; G[g].textBlock.y < G[f].textBlock.y + G[f].height + ea; ) {
                                            a = a || G[g].textBlock.y + G[g].height;
                                            d += G[g].height;
                                            d += ea;
                                            g = f;
                                            if (0 >= g) {
                                                g = 0;
                                                d += G[g].height;
                                                break;
                                            }
                                            f = q(g);
                                            if (0 > f) {
                                                g = 0;
                                                d += G[g].height;
                                                break;
                                            }
                                        }
                                        if (g != r) {
                                            h = G[g].textBlock.y;
                                            a -= h;
                                            a = d - a;
                                            h = c(a, e, g);
                                            break;
                                        }
                                    }
                                }
                                return h;
                            }
                            function c(a, b, e) {
                                var f = [], g = 0, h = 0;
                                for (a = Math.abs(a); e <= b; e++) f.push(R[e]);
                                f.sort((function(a, b) {
                                    return a.height - b.height;
                                }));
                                for (e = 0; e < f.length; e++) if (b = f[e], g < a) h++, g += G[b.id].height + ea, 
                                G[b.id].textBlock.text = "", G[b.id].indexLabelText = "", G[b.id].isDirty = !0, 
                                G[b.id].textBlock.measureText(); else break;
                                return h;
                            }
                            for (var e, f, g, h, r, k, m = 1, p = 0; p < 2 * m; p++) {
                                for (var s = G.length - 1; 0 <= s && !(0 <= q(s) && q(s), g = G[s], h = g.textBlock, 
                                k = (r = n(s) < R.length ? G[n(s)] : null) ? r.textBlock : null, e = +g.height.toFixed(6), 
                                f = +h.y.toFixed(6), !g.isDirty && r && f + e + ea > +k.y.toFixed(6) && (e = h.y + e + ea - k.y, 
                                f = a(s, -e), f < e && (0 < f && (e -= f), f = a(n(s), e), f != e))); s--) ;
                                b();
                            }
                        }
                        function l(a, b) {
                            return (b < R.length ? G[b].textBlock.y : s.reversed ? V + E : va + E) - (0 > a ? s.reversed ? va - E : V - E : G[a].textBlock.y + G[a].height + ea);
                        }
                        function t(a, b, c) {
                            var e, f, g, d = [], r = E, n = [];
                            -1 !== b && (0 <= $.indexOf(b) ? (f = $.indexOf(b), $.splice(f, 1)) : ($.push(b), 
                            $ = $.sort((function(a, b) {
                                return a - b;
                            }))));
                            if (0 === $.length) d = ja; else {
                                f = E * (1 != $.length || 0 != $[0] && $[0] != R.length - 1 ? 2 : 1) / k();
                                for (var q = 0; q < R.length; q++) {
                                    if (1 == $.length && 0 == $[0]) {
                                        if (0 === q) {
                                            d.push(ja[q]);
                                            e = r;
                                            continue;
                                        }
                                    } else 0 === q && (e = -1 * r);
                                    d.push(ja[q] + e);
                                    if (0 <= $.indexOf(q) || q < R.length && 0 <= $.indexOf(q + 1)) e += f;
                                }
                            }
                            g = function() {
                                for (var a = [], b = 0; b < R.length; b++) a.push(d[b] - R[b].y1);
                                return a;
                            }();
                            var p = {
                                startTime: (new Date).getTime(),
                                duration: c || 500,
                                easingFunction: function(a, b, c, e) {
                                    return N.easing.easeOutQuart(a, b, c, e);
                                },
                                changeSection: function(a) {
                                    for (var b, c, e = 0; e < R.length; e++) b = g[e], c = R[e], b *= a, "undefined" === typeof n[e] && (n[e] = 0), 
                                    0 > n && (n *= -1), c.y1 += b - n[e], c.y2 += b - n[e], c.y3 += b - n[e], c.y4 += b - n[e], 
                                    c.y5 && (c.y5 += b - n[e], c.y6 += b - n[e]), n[e] = b;
                                }
                            };
                            a._animator.animate(0, c, (function(c) {
                                var e = a.plotArea.ctx || a.ctx;
                                ia = !0;
                                e.clearRect(u.x1, u.y1, u.x2 - u.x1, u.y2 - u.y1);
                                e.fillStyle = a.backgroundColor;
                                e.fillRect(u.x1, u.y1, u.width, u.height);
                                p.changeSection(c, b);
                                var f = {};
                                f.dataSeries = s;
                                f.dataPoint = s.reversed ? s.dataPoints[z.length - 1 - b] : s.dataPoints[b];
                                f.index = s.reversed ? z.length - 1 - b : b;
                                a.toolTip.highlightObjects([ f ]);
                                for (f = 0; f < R.length; f++) ta(e, R[f], s.fillOpacity);
                                w(e);
                                L && ("inside" !== s.indexLabelPlacement ? m(e) : h(), B(e));
                                1 <= c && (ia = !1);
                            }), null, N.easing.easeOutQuart);
                        }
                        function k() {
                            for (var a = 0, b = 0; b < R.length - 1; b++) (0 <= $.indexOf(b) || 0 <= $.indexOf(b + 1)) && a++;
                            return a;
                        }
                        function m(a) {
                            for (var b, c, e, f, h = 0; h < R.length; h++) f = 1 === G[h].lineThickness % 2 ? .5 : 0, 
                            c = ((R[h].y2 + R[h].y4) / 2 << 0) + f, b = g(c).x2 - 1, e = G[h].textBlock.x, f = (G[h].textBlock.y + G[h].height / 2 << 0) + f, 
                            G[h].isDirty || 0 == G[h].lineThickness || (a.strokeStyle = G[h].lineColor, a.lineWidth = G[h].lineThickness, 
                            a.setLineDash && a.setLineDash(H(G[h].lineDashType, G[h].lineThickness)), a.beginPath(), 
                            a.moveTo(b, c), a.lineTo(e, f), a.stroke());
                        }
                        function q(a) {
                            for (a -= 1; -1 <= a && -1 != a && G[a].isDirty; a--) ;
                            return a;
                        }
                        function n(a) {
                            for (a += 1; a <= R.length && a != R.length && G[a].isDirty; a++) ;
                            return a;
                        }
                        function g(a) {
                            for (var b, c = 0; c < z.length; c++) if (R[c].y1 < a && R[c].y4 > a) {
                                b = R[c];
                                break;
                            }
                            return b ? (a = b.y6 ? a > b.y6 ? b.x3 + (b.x4 - b.x3) / (b.y4 - b.y3) * (a - b.y3) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2), 
                            {
                                x1: a,
                                x2: a
                            }) : -1;
                        }
                        function B(a) {
                            for (var b = 0; b < R.length; b++) G[b].isDirty || (a && (G[b].textBlock.ctx = a), 
                            G[b].textBlock.y += G[b].textBlock._lineHeight / 2, G[b].textBlock.render(!0), G[b].textBlock.y -= G[b].textBlock._lineHeight / 2);
                        }
                        function w(a) {
                            y.plotArea.layoutManager.reset();
                            a.roundRect || Aa(a);
                            y.title && (y.title.dockInsidePlotArea || "center" === y.title.horizontalAlign && "center" === y.title.verticalAlign) && (y.title.ctx = a, 
                            y.title.render());
                            if (y.subtitles) for (var b = 0; b < y.subtitles.length; b++) {
                                var c = y.subtitles[b];
                                if (c.dockInsidePlotArea || "center" === c.horizontalAlign && "center" === c.verticalAlign) y.subtitles.ctx = a, 
                                c.render();
                            }
                            y.legend && (y.legend.dockInsidePlotArea || "center" === y.legend.horizontalAlign && "center" === y.legend.verticalAlign) && (y.legend.ctx = a, 
                            y.legend.setLayout(), y.legend.render());
                            xa.fNg && xa.fNg(y);
                        }
                        var y = this;
                        if (!(0 >= a.dataSeriesIndexes.length)) {
                            for (var s = this.data[a.dataSeriesIndexes[0]], z = s.dataPoints, u = this.plotArea, E = .025 * u.width, C = .01 * u.width, A = 0, D = u.height - 2 * E, I = Math.min(u.width - 2 * C, 2.8 * u.height), L = !1, T = 0; T < z.length; T++) if (!L && "undefined" !== typeof z[T].indexLabel && null !== z[T].indexLabel && 0 < z[T].indexLabel.toString().length && (L = !0), 
                            !L && "undefined" !== typeof z[T].label && null !== z[T].label && 0 < z[T].label.toString().length && (L = !0), 
                            !L && "function" === typeof s.indexLabelFormatter || "function" === typeof z[T].indexLabelFormatter) L = !0;
                            L = L || "undefined" !== typeof s.indexLabel && null !== s.indexLabel && 0 < s.indexLabel.toString().length;
                            "inside" !== s.indexLabelPlacement && L || (C = (u.width - .75 * I) / 2);
                            T = u.x1 + C;
                            var K = u.x2 - C, O = u.y1 + E, S = u.y2 - E, P = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;
                            if (0 != s.length && s.dataPoints && s.visible && 0 !== z.length) {
                                var Q, F;
                                a = 75 * I / 100;
                                var Y = 30 * (K - a) / 100;
                                "funnel" === s.type ? (Q = p(s.options.neckHeight) ? .35 * D : s.neckHeight, F = p(s.options.neckWidth) ? .25 * a : s.neckWidth, 
                                "string" === typeof Q && Q.match(/%$/) ? (Q = parseInt(Q), Q = Q * D / 100) : Q = parseInt(Q), 
                                "string" === typeof F && F.match(/%$/) ? (F = parseInt(F), F = F * a / 100) : F = parseInt(F), 
                                Q > D ? Q = D : 0 >= Q && (Q = 0), F > a ? F = a - .5 : 0 >= F && (F = 0)) : "pyramid" === s.type && (F = Q = 0, 
                                s.reversed = s.reversed ? !1 : !0);
                                C = T + a / 2;
                                var U = T, X = T + a, V = s.reversed ? S : O, M = C - F / 2, Z = C + F / 2, W = s.reversed ? O + Q : S - Q, va = s.reversed ? O : S;
                                a = [];
                                C = [];
                                var da, R = [], aa = (I = [], O), ca = (W - V) / (M - U), fa = -ca;
                                T = "area" === (s.valueRepresents ? s.valueRepresents : "height") ? c() : e();
                                if (-1 !== T) {
                                    if (s.reversed) for (I.push(aa), F = T.length - 1; 0 < F; F--) aa += T[F], I.push(aa); else for (F = 0; F < T.length; F++) aa += T[F], 
                                    I.push(aa);
                                    if (s.reversed) for (F = 0; F < T.length; F++) I[F] < W ? (a.push(M), C.push(Z), 
                                    da = F) : (a.push((I[F] - V + ca * U) / ca), C.push((I[F] - V + fa * X) / fa)); else for (F = 0; F < T.length; F++) I[F] < W ? (a.push((I[F] - V + ca * U) / ca), 
                                    C.push((I[F] - V + fa * X) / fa), da = F) : (a.push(M), C.push(Z));
                                    for (F = 0; F < T.length - 1; F++) aa = s.reversed ? z[z.length - 1 - F].color ? z[z.length - 1 - F].color : s._colorSet[(z.length - 1 - F) % s._colorSet.length] : z[F].color ? z[F].color : s._colorSet[F % s._colorSet.length], 
                                    F === da ? R.push({
                                        x1: a[F],
                                        y1: I[F],
                                        x2: C[F],
                                        y2: I[F],
                                        x3: Z,
                                        y3: W,
                                        x4: C[F + 1],
                                        y4: I[F + 1],
                                        x5: a[F + 1],
                                        y5: I[F + 1],
                                        x6: M,
                                        y6: W,
                                        id: F,
                                        height: I[F + 1] - I[F],
                                        color: aa
                                    }) : R.push({
                                        x1: a[F],
                                        y1: I[F],
                                        x2: C[F],
                                        y2: I[F],
                                        x3: C[F + 1],
                                        y3: I[F + 1],
                                        x4: a[F + 1],
                                        y4: I[F + 1],
                                        id: F,
                                        height: I[F + 1] - I[F],
                                        color: aa
                                    });
                                    var ea = 2, G = [], ia = !1, $ = [], ja = [];
                                    T = !1;
                                    a = a = 0;
                                    Ea($);
                                    for (F = 0; F < z.length; F++) z[F].exploded && (T = !0, s.reversed ? $.push(z.length - 1 - F) : $.push(F));
                                    P.clearRect(u.x1, u.y1, u.width, u.height);
                                    P.fillStyle = y.backgroundColor;
                                    P.fillRect(u.x1, u.y1, u.width, u.height);
                                    if (L && s.visible && (b(), h(), "inside" !== s.indexLabelPlacement)) {
                                        f();
                                        d();
                                        for (F = 0; F < z.length; F++) G[F].isDirty || (a = G[F].textBlock.x + G[F].width, 
                                        a = (K - a) / 2, 0 == F && (A = a), A > a && (A = a));
                                        for (F = 0; F < R.length; F++) R[F].x1 += A, R[F].x2 += A, R[F].x3 += A, R[F].x4 += A, 
                                        R[F].x5 && (R[F].x5 += A, R[F].x6 += A), G[F].textBlock.x += A;
                                    }
                                    for (F = 0; F < R.length; F++) A = R[F], ta(P, A, s.fillOpacity), ja.push(A.y1);
                                    w(P);
                                    L && s.visible && ("inside" === s.indexLabelPlacement || y.animationEnabled || m(P), 
                                    y.animationEnabled || B());
                                    if (!L) for (F = 0; F < z.length; F++) A = s.dataPointIds[F], a = {
                                        id: A,
                                        objectType: "dataPoint",
                                        dataPointIndex: F,
                                        dataSeriesIndex: 0,
                                        funnelSection: R[s.reversed ? z.length - 1 - F : F]
                                    }, y._eventManager.objectMap[A] = a;
                                    !y.animationEnabled && T ? t(y, -1, 0) : y.animationEnabled && !y.animatedRender && t(y, -1, 0);
                                    this.funnelPyramidClickHandler = function(a) {
                                        var b = -1;
                                        if (!ia && !y.isAnimating && (p(a.dataSeries.explodeOnClick) || a.dataSeries.explodeOnClick) && (b = s.reversed ? z.length - 1 - a.dataPointIndex : a.dataPointIndex, 
                                        0 <= b)) {
                                            a = b;
                                            if ("funnel" === s.type || "pyramid" === s.type) s.reversed ? z[z.length - 1 - a].exploded = z[z.length - 1 - a].exploded ? !1 : !0 : z[a].exploded = z[a].exploded ? !1 : !0;
                                            t(y, b, 500);
                                        }
                                    };
                                    return {
                                        source: P,
                                        dest: this.plotArea.ctx,
                                        animationCallback: function(a, b) {
                                            N.fadeInAnimation(a, b);
                                            1 <= a && (t(y, -1, 500), w(y.plotArea.ctx || y.ctx));
                                        },
                                        easingFunction: N.easing.easeInQuad,
                                        animationBase: 0
                                    };
                                }
                            }
                        }
                    };
                    l.prototype.requestAnimFrame = function() {
                        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
                            window.setTimeout(a, 1e3 / 60);
                        };
                    }();
                    l.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
                    l.prototype.set = function(a, e, c) {
                        c = "undefined" === typeof c ? !0 : c;
                        "options" === a ? (this.options = e, c && this.render()) : l.base.set.call(this, a, e, c);
                    };
                    l.prototype.exportChart = function(a) {
                        a = "undefined" === typeof a ? {} : a;
                        var e = a.format ? a.format : "png", c = a.fileName ? a.fileName : this.exportFileName;
                        if (a.toDataURL) return this.canvas.toDataURL("image/" + e);
                        var b = this.canvas;
                        if (b && e && c) {
                            c = c + "." + e;
                            a = "image/" + e;
                            b = b.toDataURL(a);
                            var f = !1, h = document.createElement("a");
                            h.download = c;
                            h.href = b;
                            if ("undefined" !== typeof Blob && new Blob) {
                                for (var d = b.replace(/^data:[a-z\/]*;base64,/, ""), p = (d = atob(d), new ArrayBuffer(d.length)), l = (p = new Uint8Array(p), 
                                0); l < d.length; l++) p[l] = d.charCodeAt(l);
                                e = new Blob([ p.buffer ], {
                                    type: "image/" + e
                                });
                                try {
                                    window.navigator.msSaveBlob(e, c), f = !0;
                                } catch (k) {
                                    h.dataset.downloadurl = [ a, h.download, h.href ].join(":"), h.href = window.URL.createObjectURL(e);
                                }
                            }
                            if (!f) try {
                                event = document.createEvent("MouseEvents"), event.initMouseEvent("click", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), 
                                h.dispatchEvent ? h.dispatchEvent(event) : h.fireEvent && h.fireEvent("onclick");
                            } catch (m) {
                                e = window.open(), e.document.write("<img src='" + b + "'></img><div>Please right click on the image and save it to your device</div>"), 
                                e.document.close();
                            }
                        }
                    };
                    l.prototype.print = function() {
                        var a = this.exportChart({
                            toDataURL: !0
                        }), e = document.createElement("iframe");
                        e.setAttribute("class", "canvasjs-chart-print-frame");
                        X(e, {
                            position: "absolute",
                            width: "100%",
                            border: "0px",
                            margin: "0px 0px 0px 0px",
                            padding: "0px 0px 0px 0px"
                        });
                        e.style.height = this.height + "px";
                        this._canvasJSContainer.appendChild(e);
                        var c = this, b = e.contentWindow || e.contentDocument.document || e.contentDocument;
                        b.document.open();
                        b.document.write('<!DOCTYPE HTML>\n<html><body><img src="' + a + '"/><body/></html>');
                        b.document.body && b.document.body.style && (b.document.body.style.margin = "0px 0px 0px 0px", 
                        b.document.body.style.padding = "0px 0px 0px 0px");
                        b.document.close();
                        setTimeout((function() {
                            b.focus();
                            b.print();
                            setTimeout((function() {
                                c._canvasJSContainer.removeChild(e);
                            }), 1e3);
                        }), 500);
                    };
                    l.prototype.getPercentAndTotal = function(a, e) {
                        var c = null, b = null, f = c = null;
                        if (0 <= a.type.indexOf("stacked")) b = 0, c = e.x.getTime ? e.x.getTime() : e.x, 
                        c in a.plotUnit.yTotals && (b = a.plotUnit.yTotals[c], c = a.plotUnit.yAbsTotals[c], 
                        f = isNaN(e.y) ? 0 : 0 === c ? 0 : 100 * (e.y / c)); else if ("pie" === a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type) {
                            for (c = b = 0; c < a.dataPoints.length; c++) isNaN(a.dataPoints[c].y) || (b += a.dataPoints[c].y);
                            f = isNaN(e.y) ? 0 : 100 * (e.y / b);
                        }
                        return {
                            percent: f,
                            total: b
                        };
                    };
                    l.prototype.replaceKeywordsWithValue = function(a, e, c, b, f) {
                        var h = this;
                        f = "undefined" === typeof f ? 0 : f;
                        if ((0 <= c.type.indexOf("stacked") || "pie" === c.type || "doughnut" === c.type || "funnel" === c.type || "pyramid" === c.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) {
                            var d = "#percent", p = "#total", l = this.getPercentAndTotal(c, e);
                            p = isNaN(l.total) ? p : l.total, d = isNaN(l.percent) ? d : l.percent;
                            do {
                                l = "";
                                if (c.percentFormatString) l = c.percentFormatString; else {
                                    l = "#,##0.";
                                    var k = Math.max(Math.ceil(Math.log(1 / Math.abs(d)) / Math.LN10), 2);
                                    if (isNaN(k) || !isFinite(k)) k = 2;
                                    for (var m = 0; m < k; m++) l += "#";
                                    c.percentFormatString = l;
                                }
                                a = a.replace("#percent", fa(d, l, h._cultureInfo));
                                a = a.replace("#total", fa(p, c.yValueFormatString ? c.yValueFormatString : "#,##0.########", h._cultureInfo));
                            } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"));
                        }
                        return a.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, (function(a) {
                            if ('"' === a[0] && '"' === a[a.length - 1] || "'" === a[0] && "'" === a[a.length - 1]) return a.slice(1, a.length - 1);
                            a = Ha(a.slice(1, a.length - 1));
                            a = a.replace("#index", f);
                            var d = null;
                            try {
                                var g = a.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
                                g && 0 < g.length && (d = Ha(g[2]), a = Ha(g[1]));
                            } catch (r) {}
                            g = null;
                            if ("color" === a) return "waterfall" === c.type ? e.color ? e.color : 0 < e.y ? c.risingColor : c.fallingColor : "error" === c.type ? c.color ? c.color : c._colorSet[d % c._colorSet.length] : e.color ? e.color : c.color ? c.color : c._colorSet[b % c._colorSet.length];
                            if (e.hasOwnProperty(a)) g = e; else if (c.hasOwnProperty(a)) g = c; else return "";
                            g = g[a];
                            null !== d && (g = g[d]);
                            return "x" === a ? (c.axisX && "dateTime" === c.axisX.valueType || "dateTime" === c.xValueType || e.x && e.x.getTime) && !c.axisX.logarithmic ? Da(g, e.xValueFormatString ? e.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : c.xValueFormatString = h.axisX && h.axisX.autoValueFormatString ? h.axisX.autoValueFormatString : "DD MMM YY", h._cultureInfo) : fa(g, e.xValueFormatString ? e.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : c.xValueFormatString = "#,##0.########", h._cultureInfo) : "y" === a ? fa(g, e.yValueFormatString ? e.yValueFormatString : c.yValueFormatString ? c.yValueFormatString : c.yValueFormatString = "#,##0.########", h._cultureInfo) : "z" === a ? fa(g, e.zValueFormatString ? e.zValueFormatString : c.zValueFormatString ? c.zValueFormatString : c.zValueFormatString = "#,##0.########", h._cultureInfo) : g;
                        }));
                    };
                    qa(I, K);
                    I.prototype.setLayout = function() {
                        var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, e = a.layoutManager.getFreeSpace(), c = null, b = 0, f = 0, h = 0, d = 0, l = this.markerMargin = this.chart.options.legend && !p(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : .3 * this.fontSize;
                        this.height = 0;
                        var v = [], k = [];
                        if ("top" === this.verticalAlign || "bottom" === this.verticalAlign) this.orientation = "horizontal", 
                        c = this.verticalAlign, h = this.maxWidth = null !== this.maxWidth ? this.maxWidth : e.width, 
                        d = this.maxHeight = null !== this.maxHeight ? this.maxHeight : .5 * e.height; else if ("center" === this.verticalAlign) {
                            this.orientation = "vertical";
                            if ("left" === this.horizontalAlign || "center" === this.horizontalAlign || "right" === this.horizontalAlign) c = this.horizontalAlign;
                            h = this.maxWidth = null !== this.maxWidth ? this.maxWidth : .5 * e.width;
                            d = this.maxHeight = null !== this.maxHeight ? this.maxHeight : e.height;
                        }
                        this.errorMarkerColor = [];
                        for (var m = 0; m < this.dataSeries.length; m++) {
                            var q = this.dataSeries[m];
                            if (q.dataPoints && q.dataPoints.length) if ("pie" !== q.type && "doughnut" !== q.type && "funnel" !== q.type && "pyramid" !== q.type) {
                                var n = q.legendMarkerType = q.legendMarkerType ? q.legendMarkerType : "line" !== q.type && "stepLine" !== q.type && "spline" !== q.type && "scatter" !== q.type && "bubble" !== q.type || !q.markerType ? "error" === q.type && q._linkedSeries ? q._linkedSeries.legendMarkerType ? q._linkedSeries.legendMarkerType : Q.getDefaultLegendMarker(q._linkedSeries.type) : Q.getDefaultLegendMarker(q.type) : q.markerType, g = q.legendText ? q.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                                    chart: this.chart,
                                    legend: this.options,
                                    dataSeries: q,
                                    dataPoint: null
                                }) : q.name, t = q.legendMarkerColor = q.legendMarkerColor ? q.legendMarkerColor : q.markerColor ? q.markerColor : "error" === q.type ? p(q.whiskerColor) ? q._colorSet[0] : q.whiskerColor : q._colorSet[0], w = q.markerSize || "line" !== q.type && "stepLine" !== q.type && "spline" !== q.type ? .75 * this.lineHeight : 0, y = q.legendMarkerBorderColor ? q.legendMarkerBorderColor : q.markerBorderColor, s = q.legendMarkerBorderThickness ? q.legendMarkerBorderThickness : q.markerBorderThickness ? Math.max(1, Math.round(.2 * w)) : 0;
                                "error" === q.type && this.errorMarkerColor.push(t);
                                g = this.chart.replaceKeywordsWithValue(g, q.dataPoints[0], q, m);
                                n = {
                                    markerType: n,
                                    markerColor: t,
                                    text: g,
                                    textBlock: null,
                                    chartType: q.type,
                                    markerSize: w,
                                    lineColor: q._colorSet[0],
                                    dataSeriesIndex: q.index,
                                    dataPointIndex: null,
                                    markerBorderColor: y,
                                    markerBorderThickness: s
                                };
                                v.push(n);
                            } else for (var z = 0; z < q.dataPoints.length; z++) {
                                var u = q.dataPoints[z];
                                n = u.legendMarkerType ? u.legendMarkerType : q.legendMarkerType ? q.legendMarkerType : Q.getDefaultLegendMarker(q.type), 
                                g = u.legendText ? u.legendText : q.legendText ? q.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                                    chart: this.chart,
                                    legend: this.options,
                                    dataSeries: q,
                                    dataPoint: u
                                }) : u.name ? u.name : "DataPoint: " + (z + 1), t = u.legendMarkerColor ? u.legendMarkerColor : q.legendMarkerColor ? q.legendMarkerColor : u.color ? u.color : q.color ? q.color : q._colorSet[z % q._colorSet.length], 
                                w = .75 * this.lineHeight, y = u.legendMarkerBorderColor ? u.legendMarkerBorderColor : q.legendMarkerBorderColor ? q.legendMarkerBorderColor : u.markerBorderColor ? u.markerBorderColor : q.markerBorderColor, 
                                s = u.legendMarkerBorderThickness ? u.legendMarkerBorderThickness : q.legendMarkerBorderThickness ? q.legendMarkerBorderThickness : u.markerBorderThickness || q.markerBorderThickness ? Math.max(1, Math.round(.2 * w)) : 0, 
                                g = this.chart.replaceKeywordsWithValue(g, u, q, z), n = {
                                    markerType: n,
                                    markerColor: t,
                                    text: g,
                                    textBlock: null,
                                    chartType: q.type,
                                    markerSize: w,
                                    dataSeriesIndex: m,
                                    dataPointIndex: z,
                                    markerBorderColor: y,
                                    markerBorderThickness: s
                                };
                                (u.showInLegend || q.showInLegend && !1 !== u.showInLegend) && v.push(n);
                            }
                        }
                        !0 === this.reversed && v.reverse();
                        if (0 < v.length) {
                            q = null;
                            g = u = z = 0;
                            u = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, h) : this.itemMaxWidth = Math.min(this.itemWidth, h) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, h) : this.itemMaxWidth = h;
                            w = 0 === w ? .75 * this.lineHeight : w;
                            u = (this.itemMaxWidth ? this.itemMaxWidth : u) - (w + l);
                            for (m = 0; m < v.length; m++) {
                                n = v[m];
                                t = u;
                                if ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType) t -= 2 * .1 * this.lineHeight;
                                if (!(0 >= d || "undefined" === typeof d || 0 >= t || "undefined" === typeof t)) if ("horizontal" === this.orientation) {
                                    n.textBlock = new ka(this.ctx, {
                                        x: 0,
                                        y: 0,
                                        maxWidth: t,
                                        maxHeight: this.itemWrap ? d : this.lineHeight,
                                        angle: 0,
                                        text: n.text,
                                        horizontalAlign: "left",
                                        fontSize: this.fontSize,
                                        fontFamily: this.fontFamily,
                                        fontWeight: this.fontWeight,
                                        fontColor: this.fontColor,
                                        fontStyle: this.fontStyle,
                                        textBaseline: "middle"
                                    });
                                    n.textBlock.measureText();
                                    null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (w + l + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * .1 * this.lineHeight : 0)));
                                    if (!q || q.width + Math.round(n.textBlock.width + w + l + (0 === q.width ? 0 : this.horizontalSpacing) + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * .1 * this.lineHeight : 0)) > h) q = {
                                        items: [],
                                        width: 0
                                    }, k.push(q), this.height += g, g = 0;
                                    g = Math.max(g, n.textBlock.height ? n.textBlock.height : this.lineHeight);
                                    n.textBlock.x = q.width;
                                    n.textBlock.y = 0;
                                    q.width += Math.round(n.textBlock.width + w + l + (0 === q.width ? 0 : this.horizontalSpacing) + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * .1 * this.lineHeight : 0));
                                    q.items.push(n);
                                    this.width = Math.max(q.width, this.width);
                                } else n.textBlock = new ka(this.ctx, {
                                    x: 0,
                                    y: 0,
                                    maxWidth: u,
                                    maxHeight: !0 === this.itemWrap ? d : 1.5 * this.fontSize,
                                    angle: 0,
                                    text: n.text,
                                    horizontalAlign: "left",
                                    fontSize: this.fontSize,
                                    fontFamily: this.fontFamily,
                                    fontWeight: this.fontWeight,
                                    fontColor: this.fontColor,
                                    fontStyle: this.fontStyle,
                                    textBaseline: "middle"
                                }), n.textBlock.measureText(), null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (w + l + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * .1 * this.lineHeight : 0))), 
                                this.height < d - this.lineHeight ? (q = {
                                    items: [],
                                    width: 0
                                }, k.push(q)) : (q = k[z], z = (z + 1) % k.length), q && (this.height += n.textBlock.height ? n.textBlock.height : this.lineHeight, 
                                n.textBlock.x = q.width, n.textBlock.y = 0, q.width += Math.round(n.textBlock.width + w + l + (0 === q.width ? 0 : this.horizontalSpacing) + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? 2 * .1 * this.lineHeight : 0)), 
                                q.items.push(n), this.width = Math.max(q.width, this.width));
                            }
                            this.height = !1 === this.itemWrap ? k.length * this.lineHeight : this.height + g;
                            this.height = Math.min(d, this.height);
                            this.width = Math.min(h, this.width);
                        }
                        "top" === this.verticalAlign ? (f = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, 
                        b = e.y1) : "center" === this.verticalAlign ? (f = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, 
                        b = e.y1 + e.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (f = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, 
                        b = e.y2 - this.height);
                        this.items = v;
                        for (m = 0; m < this.items.length; m++) n = v[m], n.id = ++this.chart._eventManager.lastObjectId, 
                        this.chart._eventManager.objectMap[n.id] = {
                            id: n.id,
                            objectType: "legendItem",
                            legendItemIndex: m,
                            dataSeriesIndex: n.dataSeriesIndex,
                            dataPointIndex: n.dataPointIndex
                        };
                        this.markerSize = w;
                        this.rows = k;
                        0 < v.length && a.layoutManager.registerSpace(c, {
                            width: this.width + 2 + 2,
                            height: this.height + 5 + 5
                        });
                        this.bounds = {
                            x1: f,
                            y1: b,
                            x2: f + this.width,
                            y2: b + this.height
                        };
                    };
                    I.prototype.render = function() {
                        var a = this.bounds.x1, e = this.bounds.y1, c = this.markerMargin, b = this.maxWidth, f = this.maxHeight, h = this.markerSize, d = this.rows;
                        (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(a, e, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
                        for (var p = 0, l = 0; l < d.length; l++) {
                            for (var k = d[l], m = 0, q = 0; q < k.items.length; q++) {
                                var n = k.items[q], g = n.textBlock.x + a + (0 === q ? .2 * h : this.horizontalSpacing), v = e + p, w = g;
                                this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = .5);
                                this.ctx.save();
                                this.ctx.beginPath();
                                this.ctx.rect(a, e, b, Math.max(f - f % this.lineHeight, 0));
                                this.ctx.clip();
                                if ("line" === n.chartType || "stepLine" === n.chartType || "spline" === n.chartType) this.ctx.strokeStyle = n.lineColor, 
                                this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(g - .1 * this.lineHeight, v + this.lineHeight / 2), 
                                this.ctx.lineTo(g + .85 * this.lineHeight, v + this.lineHeight / 2), this.ctx.stroke(), 
                                w -= .1 * this.lineHeight;
                                if ("error" === n.chartType) {
                                    this.ctx.strokeStyle = this.errorMarkerColor[0];
                                    this.ctx.lineWidth = h / 8;
                                    this.ctx.beginPath();
                                    var y = g - .08 * this.lineHeight + .1 * this.lineHeight, s = v + .15 * this.lineHeight, z = .7 * this.lineHeight, u = z + .02 * this.lineHeight;
                                    this.ctx.moveTo(y, s);
                                    this.ctx.lineTo(y + z, s);
                                    this.ctx.stroke();
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(y + z / 2, s);
                                    this.ctx.lineTo(y + z / 2, s + u);
                                    this.ctx.stroke();
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(y, s + u);
                                    this.ctx.lineTo(y + z, s + u);
                                    this.ctx.stroke();
                                    this.errorMarkerColor.shift();
                                }
                                W.drawMarker(g + h / 2, v + this.lineHeight / 2, this.ctx, n.markerType, "error" === n.chartType || "line" === n.chartType || "spline" === n.chartType ? n.markerSize / 2 : n.markerSize, n.markerColor, n.markerBorderColor, n.markerBorderThickness);
                                n.textBlock.x = g + c + h;
                                if ("line" === n.chartType || "stepLine" === n.chartType || "spline" === n.chartType) n.textBlock.x += .1 * this.lineHeight;
                                n.textBlock.y = Math.round(v + this.lineHeight / 2);
                                n.textBlock.render(!0);
                                this.ctx.restore();
                                m = 0 < q ? Math.max(m, n.textBlock.height ? n.textBlock.height : this.lineHeight) : n.textBlock.height ? n.textBlock.height : this.lineHeight;
                                this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);
                                g = Y(n.id);
                                this.ghostCtx.fillStyle = g;
                                this.ghostCtx.beginPath();
                                this.ghostCtx.fillRect(w, n.textBlock.y - this.lineHeight / 2, n.textBlock.x + n.textBlock.width - w, n.textBlock.height ? n.textBlock.height : this.lineHeight);
                                n.x1 = this.chart._eventManager.objectMap[n.id].x1 = w;
                                n.y1 = this.chart._eventManager.objectMap[n.id].y1 = n.textBlock.y - this.lineHeight / 2;
                                n.x2 = this.chart._eventManager.objectMap[n.id].x2 = n.textBlock.x + n.textBlock.width;
                                n.y2 = this.chart._eventManager.objectMap[n.id].y2 = n.textBlock.y + (n.textBlock.height ? n.textBlock.height : this.lineHeight) - this.lineHeight / 2;
                            }
                            p += m;
                        }
                    };
                    qa(Q, K);
                    Q.prototype.getDefaultAxisPlacement = function() {
                        var a = this.type;
                        if ("column" === a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "normal";
                        if ("bar" === a || "stackedBar" === a || "stackedBar100" === a || "rangeBar" === a) return "xySwapped";
                        if ("pie" === a || "doughnut" === a || "funnel" === a || "pyramid" === a) return "none";
                        "error" !== a && window.console.log("Unknown Chart Type: " + a);
                        return null;
                    };
                    Q.getDefaultLegendMarker = function(a) {
                        if ("column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "square";
                        if ("line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a) return "circle";
                        if ("area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a || "funnel" === a || "pyramid" === a) return "triangle";
                        if ("error" === a) return "none";
                        window.console.log("Unknown Chart Type: " + a);
                        return null;
                    };
                    Q.prototype.getDataPointAtX = function(a, e) {
                        if (!this.dataPoints || 0 === this.dataPoints.length) return null;
                        var c = {
                            dataPoint: null,
                            distance: 1 / 0,
                            index: NaN
                        }, b = null, f = 0, h = 0, d = 1, p = 1 / 0, l = 0, k = 0, m = 0;
                        "none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (m = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), 
                        m = 1 < m ? Math.min(Math.max((this.dataPoints.length - 1) / m * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (m = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, 
                        m = 0 < m ? Math.min(Math.max((this.dataPoints.length - 1) / m * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));
                        for (;;) {
                            h = 0 < d ? m + f : m - f;
                            if (0 <= h && h < this.dataPoints.length) {
                                b = this.dataPoints[h];
                                var q = this.axisX.logarithmic ? b.x > a ? b.x / a : a / b.x : Math.abs(b.x - a);
                                q < c.distance && (c.dataPoint = b, c.distance = q, c.index = h);
                                b = q;
                                b <= p ? p = b : 0 < d ? l++ : k++;
                                if (1e3 < l && 1e3 < k) break;
                            } else if (0 > m - f && m + f >= this.dataPoints.length) break;
                            -1 === d ? (f++, d = 1) : d = -1;
                        }
                        return e || (c.dataPoint.x.getTime ? c.dataPoint.x.getTime() : c.dataPoint.x) !== (a.getTime ? a.getTime() : a) ? e && null !== c.dataPoint ? c : null : c;
                    };
                    Q.prototype.getDataPointAtXY = function(a, e, c) {
                        if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || e < this.chart.plotArea.y1 || e > this.chart.plotArea.y2) return null;
                        c = c || !1;
                        var b = [], f = 0, h = 0, d = 1, l = !1, v = 1 / 0, k = 0, m = 0, q = 0;
                        if ("none" !== this.chart.plotInfo.axisPlacement) if (q = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({
                            x: a,
                            y: e
                        }), this.axisX.logarithmic) {
                            var n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x);
                            q = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(q / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
                        } else n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, 
                        q = 0 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * (q - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
                        for (;;) {
                            h = 0 < d ? q + f : q - f;
                            if (0 <= h && h < this.dataPoints.length) {
                                n = this.chart._eventManager.objectMap[this.dataPointIds[h]];
                                var g = this.dataPoints[h], t = null;
                                if (n) {
                                    switch (this.type) {
                                      case "column":
                                      case "stackedColumn":
                                      case "stackedColumn100":
                                      case "bar":
                                      case "stackedBar":
                                      case "stackedBar100":
                                      case "rangeColumn":
                                      case "rangeBar":
                                      case "waterfall":
                                      case "error":
                                        a >= n.x1 && a <= n.x2 && e >= n.y1 && e <= n.y2 && (b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y1 - e), Math.abs(n.y2 - e))
                                        }), l = !0);
                                        break;

                                      case "line":
                                      case "stepLine":
                                      case "spline":
                                      case "area":
                                      case "stepArea":
                                      case "stackedArea":
                                      case "stackedArea100":
                                      case "splineArea":
                                      case "scatter":
                                        var w = oa("markerSize", g, this) || 4, y = c ? 20 : w;
                                        t = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - e, 2));
                                        t <= y && b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: t
                                        });
                                        n = Math.abs(n.x1 - a);
                                        n <= v ? v = n : 0 < d ? k++ : m++;
                                        t <= w / 2 && (l = !0);
                                        break;

                                      case "rangeArea":
                                      case "rangeSplineArea":
                                        w = oa("markerSize", g, this) || 4;
                                        y = c ? 20 : w;
                                        t = Math.min(Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - e, 2)), Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y2 - e, 2)));
                                        t <= y && b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: t
                                        });
                                        n = Math.abs(n.x1 - a);
                                        n <= v ? v = n : 0 < d ? k++ : m++;
                                        t <= w / 2 && (l = !0);
                                        break;

                                      case "bubble":
                                        w = n.size;
                                        t = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - e, 2));
                                        t <= w / 2 && (b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: t
                                        }), l = !0);
                                        break;

                                      case "pie":
                                      case "doughnut":
                                        w = n.center;
                                        y = "doughnut" === this.type ? n.percentInnerRadius * n.radius : 0;
                                        t = Math.sqrt(Math.pow(w.x - a, 2) + Math.pow(w.y - e, 2));
                                        t < n.radius && t > y && (t = Math.atan2(e - w.y, a - w.x), 0 > t && (t += 2 * Math.PI), 
                                        t = Number(((180 * (t / Math.PI) % 360 + 360) % 360).toFixed(12)), w = Number(((180 * (n.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 
                                        y = Number(((180 * (n.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === y && 1 < n.endAngle && (y = 360), 
                                        w >= y && 0 !== g.y && !p(g.y) && (y += 360, t < w && (t += 360)), t > w && t < y && (b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: 0
                                        }), l = !0));
                                        break;

                                      case "funnel":
                                      case "pyramid":
                                        t = n.funnelSection;
                                        e > t.y1 && e < t.y4 && (t.y6 ? e > t.y6 ? (h = t.x6 + (t.x5 - t.x6) / (t.y5 - t.y6) * (e - t.y6), 
                                        t = t.x3 + (t.x4 - t.x3) / (t.y4 - t.y3) * (e - t.y3)) : (h = t.x1 + (t.x6 - t.x1) / (t.y6 - t.y1) * (e - t.y1), 
                                        t = t.x2 + (t.x3 - t.x2) / (t.y3 - t.y2) * (e - t.y2)) : (h = t.x1 + (t.x4 - t.x1) / (t.y4 - t.y1) * (e - t.y1), 
                                        t = t.x2 + (t.x3 - t.x2) / (t.y3 - t.y2) * (e - t.y2)), a > h && a < t && (b.push({
                                            dataPoint: g,
                                            dataPointIndex: n.dataPointIndex,
                                            dataSeries: this,
                                            distance: 0
                                        }), l = !0));
                                        break;

                                      case "boxAndWhisker":
                                        if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && e >= n.y4 - n.borderThickness / 2 && e <= n.y1 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && e >= n.y1 && e <= n.y4) b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - e), Math.abs(n.y3 - e))
                                        }), l = !0;
                                        break;

                                      case "candlestick":
                                        if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && e >= n.y2 - n.borderThickness / 2 && e <= n.y3 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && e >= n.y1 && e <= n.y4) b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - e), Math.abs(n.y3 - e))
                                        }), l = !0;
                                        break;

                                      case "ohlc":
                                        if (Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && e >= n.y2 && e <= n.y3 || a >= n.x1 && a <= (n.x2 + n.x1) / 2 && e >= n.y1 - n.borderThickness / 2 && e <= n.y1 + n.borderThickness / 2 || a >= (n.x1 + n.x2) / 2 && a <= n.x2 && e >= n.y4 - n.borderThickness / 2 && e <= n.y4 + n.borderThickness / 2) b.push({
                                            dataPoint: g,
                                            dataPointIndex: h,
                                            dataSeries: this,
                                            distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - e), Math.abs(n.y3 - e))
                                        }), l = !0;
                                    }
                                    if (l || 1e3 < k && 1e3 < m) break;
                                }
                            } else if (0 > q - f && q + f >= this.dataPoints.length) break;
                            -1 === d ? (f++, d = 1) : d = -1;
                        }
                        a = null;
                        for (e = 0; e < b.length; e++) a ? b[e].distance <= a.distance && (a = b[e]) : a = b[e];
                        return a;
                    };
                    Q.prototype.getMarkerProperties = function(a, e, c, b) {
                        var f = this.dataPoints, h = f[a].markerColor ? f[a].markerColor : this.markerColor ? this.markerColor : f[a].color ? f[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], d = f[a].markerBorderColor ? f[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, l = p(f[a].markerBorderThickness) ? this.markerBorderThickness ? this.markerBorderThickness : null : f[a].markerBorderThickness, t = f[a].markerType ? f[a].markerType : this.markerType;
                        a = p(f[a].markerSize) ? this.markerSize : f[a].markerSize;
                        return {
                            x: e,
                            y: c,
                            ctx: b,
                            type: t,
                            size: a,
                            color: h,
                            borderColor: d,
                            borderThickness: l
                        };
                    };
                    qa(D, K);
                    D.prototype.createExtraLabelsForLog = function(a) {
                        a = (a || 0) + 1;
                        if (!(5 < a)) {
                            var e = this.logLabelValues[0] || this.intervalStartPosition;
                            if (Math.log(this.range) / Math.log(e / this.viewportMinimum) < this.noTicks - 1) {
                                for (var c = D.getNiceNumber((e - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), b = Math.ceil(this.viewportMinimum / c) * c; b < e; b += c) b < this.viewportMinimum || this.logLabelValues.push(b);
                                this.logLabelValues.sort(Sa);
                                this.createExtraLabelsForLog(a);
                            }
                        }
                    };
                    D.prototype.createLabels = function() {
                        var a, e, f, t, m, c = 0, b = 0, h = 0, d = 0, l = (b = 0, b = this.interval, 0), k = .6 * this.chart.height;
                        a = !1;
                        var q = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], n = q.length ? p(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;
                        if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
                            f = this.viewportMaximum;
                            if (this.labels) {
                                a = Math.ceil(b);
                                b = Math.ceil(this.intervalStartPosition);
                                var g = !1;
                                for (c = b; c < this.viewportMaximum; c += a) if (this.labels[c]) g = !0; else {
                                    g = !1;
                                    break;
                                }
                                g && (this.interval = a, this.intervalStartPosition = b);
                            }
                            if (this.logarithmic && !this.equidistantInterval) for (this.logLabelValues || (this.logLabelValues = [], 
                            this.createExtraLabelsForLog()), b = 0, g = n; b < this.logLabelValues.length; b++) if (c = this.logLabelValues[b], 
                            c < this.viewportMinimum) b++; else {
                                for (;g < q.length && c > q[g].endValue; g++) ;
                                a = g < q.length && c >= q[g].startValue && c <= q[g].endValue;
                                m = c;
                                a || (a = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.options,
                                    value: m,
                                    label: this.labels[m] ? this.labels[m] : null
                                }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : fa(m, this.valueFormatString, this.chart._cultureInfo), 
                                a = new ka(this.ctx, {
                                    x: 0,
                                    y: 0,
                                    maxWidth: h,
                                    maxHeight: d,
                                    angle: this.labelAngle,
                                    text: this.prefix + a + this.suffix,
                                    backgroundColor: this.labelBackgroundColor,
                                    borderColor: this.labelBorderColor,
                                    cornerRadius: this.labelCornerRadius,
                                    textAlign: this.labelTextAlign,
                                    fontSize: this.labelFontSize,
                                    fontFamily: this.labelFontFamily,
                                    fontWeight: this.labelFontWeight,
                                    fontColor: this.labelFontColor,
                                    fontStyle: this.labelFontStyle,
                                    textBaseline: "middle",
                                    borderThickness: 0
                                }), this._labels.push({
                                    position: m,
                                    textBlock: a,
                                    effectiveHeight: null
                                }));
                            }
                            g = n;
                            for (c = this.intervalStartPosition; c <= f; c = parseFloat(1e-12 > this.interval ? this.logarithmic && this.equidistantInterval ? c * Math.pow(this.logarithmBase, this.interval) : c + this.interval : (this.logarithmic && this.equidistantInterval ? c * Math.pow(this.logarithmBase, this.interval) : c + this.interval).toFixed(12))) {
                                for (;g < q.length && c > q[g].endValue; g++) ;
                                a = g < q.length && c >= q[g].startValue && c <= q[g].endValue;
                                m = c;
                                a || (a = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.options,
                                    value: m,
                                    label: this.labels[m] ? this.labels[m] : null
                                }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : fa(m, this.valueFormatString, this.chart._cultureInfo), 
                                a = new ka(this.ctx, {
                                    x: 0,
                                    y: 0,
                                    maxWidth: h,
                                    maxHeight: d,
                                    angle: this.labelAngle,
                                    text: this.prefix + a + this.suffix,
                                    textAlign: this.labelTextAlign,
                                    backgroundColor: this.labelBackgroundColor,
                                    borderColor: this.labelBorderColor,
                                    borderThickness: this.labelBorderThickness,
                                    cornerRadius: this.labelCornerRadius,
                                    fontSize: this.labelFontSize,
                                    fontFamily: this.labelFontFamily,
                                    fontWeight: this.labelFontWeight,
                                    fontColor: this.labelFontColor,
                                    fontStyle: this.labelFontStyle,
                                    textBaseline: "middle"
                                }), this._labels.push({
                                    position: m,
                                    textBlock: a,
                                    effectiveHeight: null
                                }));
                            }
                        } else for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), 
                        f = Ya(new Date(this.viewportMaximum), this.interval, this.intervalType), g = n, 
                        c = this.intervalStartPosition; c < f; Ya(c, b, this.intervalType)) {
                            for (a = c.getTime(); g < q.length && a > q[g].endValue; g++) ;
                            m = a;
                            a = g < q.length && a >= q[g].startValue && a <= q[g].endValue;
                            a || (a = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.options,
                                value: new Date(m),
                                label: this.labels[m] ? this.labels[m] : null
                            }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : Da(m, this.valueFormatString, this.chart._cultureInfo), 
                            a = new ka(this.ctx, {
                                x: 0,
                                y: 0,
                                maxWidth: h,
                                backgroundColor: this.labelBackgroundColor,
                                borderColor: this.labelBorderColor,
                                borderThickness: this.labelBorderThickness,
                                cornerRadius: this.labelCornerRadius,
                                maxHeight: d,
                                angle: this.labelAngle,
                                text: this.prefix + a + this.suffix,
                                textAlign: this.labelTextAlign,
                                fontSize: this.labelFontSize,
                                fontFamily: this.labelFontFamily,
                                fontWeight: this.labelFontWeight,
                                fontColor: this.labelFontColor,
                                fontStyle: this.labelFontStyle,
                                textBaseline: "middle"
                            }), this._labels.push({
                                position: m,
                                textBlock: a,
                                effectiveHeight: null,
                                breaksLabelType: void 0
                            }));
                        }
                        if ("bottom" === this._position || "top" === this._position) l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, 
                        h = "undefined" === typeof this.options.labelMaxWidth ? .5 * this.chart.width >> 0 : this.options.labelMaxWidth, 
                        this.chart.panEnabled || (d = "undefined" === typeof this.options.labelWrap || this.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize); else if ("left" === this._position || "right" === this._position) l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, 
                        this.chart.panEnabled || (h = "undefined" === typeof this.options.labelMaxWidth ? .3 * this.chart.width >> 0 : this.options.labelMaxWidth), 
                        d = "undefined" === typeof this.options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
                        for (b = 0; b < this._labels.length; b++) {
                            a = this._labels[b].textBlock;
                            a.maxWidth = h;
                            a.maxHeight = d;
                            var B = a.measureText();
                            t = B.height;
                        }
                        f = [];
                        n = q = 0;
                        if (this.labelAutoFit || this.options.labelAutoFit) if (p(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 
                        90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), 
                        "bottom" === this._position || "top" === this._position) if (h = .9 * l >> 0, n = 0, 
                        !this.chart.panEnabled && 1 <= this._labels.length) {
                            this.sessionVariables.labelFontSize = this.labelFontSize;
                            this.sessionVariables.labelMaxWidth = h;
                            this.sessionVariables.labelMaxHeight = d;
                            this.sessionVariables.labelAngle = this.labelAngle;
                            this.sessionVariables.labelWrap = this.labelWrap;
                            for (c = 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {
                                a = this._labels[c].textBlock;
                                var w;
                                for (g = a.text.split(" "), b = 0; b < g.length; b++) m = g[b], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, 
                                m = this.ctx.measureText(m), m.width > n && (w = c, n = m.width);
                            }
                            c = 0;
                            for (c = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {
                                a = this._labels[c].textBlock;
                                B = a.measureText();
                                for (g = c + 1; g < this._labels.length; g++) if (!this._labels[g].breaksLabelType) {
                                    e = this._labels[g].textBlock;
                                    e = e.measureText();
                                    break;
                                }
                                f.push(a.height);
                                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, f);
                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                                b = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                                if (p(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle) {
                                    if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : Math.min((b - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), 
                                    m = (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), 
                                    !p(this.options.labelWrap)) this.labelWrap ? p(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, n), m), 
                                    this.sessionVariables.labelWrap = this.labelWrap, e && B.width + e.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, 
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle) : p(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, 
                                    this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = h, 
                                    e && B.width + e.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25, 
                                    this.sessionVariables.labelMaxWidth = m)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle, 
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d, 
                                    this.sessionVariables.labelWrap = this.labelWrap); else if (p(this.options.labelWrap)) if (!p(this.options.labelMaxWidth)) this.options.labelMaxWidth < h ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, 
                                    this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelAngle = -25, 
                                    this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d); else if (!p(e)) if (b = B.width + e.width >> 0, 
                                    g = this.labelFontSize, n < h) b - 2 * h > q && (q = b - 2 * h, b >= 2 * h && b < 2.2 * h ? (this.sessionVariables.labelMaxWidth = h, 
                                    p(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), a.measureText()), 
                                    this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, 
                                    this.sessionVariables.labelAngle = this.labelAngle) : b >= 2.2 * h && b < 2.8 * h ? (this.sessionVariables.labelAngle = -25, 
                                    this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = g) : b >= 2.8 * h && b < 3.2 * h ? (this.sessionVariables.labelMaxWidth = Math.max(h, n), 
                                    this.sessionVariables.labelWrap = !0, p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), 
                                    a.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, 
                                    this.sessionVariables.labelAngle = this.labelAngle) : b >= 3.2 * h && b < 3.6 * h ? (this.sessionVariables.labelAngle = -25, 
                                    this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = this.labelFontSize) : b > 3.6 * h && b < 5 * h ? (p(this.options.labelFontSize) && 12 < g && (g = Math.floor(12 / 13 * g), 
                                    a.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, 
                                    this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m) : b > 5 * h && (this.sessionVariables.labelWrap = !0, 
                                    this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelFontSize = g, 
                                    this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelAngle = this.labelAngle)); else if (w === c && (0 === w && n + this._labels[w + 1].textBlock.measureText().width - 2 * h > q || w === this._labels.length - 1 && n + this._labels[w - 1].textBlock.measureText().width - 2 * h > q || 0 < w && w < this._labels.length - 1 && n + this._labels[w + 1].textBlock.measureText().width - 2 * h > q && n + this._labels[w - 1].textBlock.measureText().width - 2 * h > q)) q = 0 === w ? n + this._labels[w + 1].textBlock.measureText().width - 2 * h : n + this._labels[w - 1].textBlock.measureText().width - 2 * h, 
                                    this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, 
                                    this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m; else if (0 === q) for (this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? g : this.options.labelFontSize, 
                                    this.sessionVariables.labelWrap = !0, b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, 
                                    a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, n), m), 
                                    B = a.measureText(), b < this._labels.length - 1 && (g = b + 1, e = this._labels[g].textBlock, 
                                    e.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, n), m), 
                                    e = e.measureText(), B.width + e.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25));
                                } else (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : Math.min((b - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), b), 
                                m = 0 != this.labelAngle ? (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : h, 
                                this.sessionVariables.labelMaxHeight = this.labelWrap ? (k - m * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, 
                                p(this.options.labelWrap)) ? p(this.options.labelWrap) && (this.labelWrap && !p(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, 
                                this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, 
                                this.sessionVariables.labelMaxHeight = d) : (this.sessionVariables.labelAngle = this.labelAngle, 
                                this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelMaxHeight = b < .9 * l ? .9 * l : b, 
                                this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, 
                                this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m) : (p(this.options.labelMaxWidth), 
                                this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, 
                                this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = d);
                            }
                            for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, 
                            a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, 
                            a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, 
                            a.measureText();
                        } else for (c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, 
                        a.maxWidth = this.labelMaxWidth = p(this.options.labelMaxWidth) ? p(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = h : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, 
                        a.fontSize = this.labelFontSize = p(this.options.labelFontSize) ? p(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, 
                        a.angle = this.labelAngle = p(this.options.labelAngle) ? p(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, 
                        a.wrap = this.labelWrap = p(this.options.labelWrap) ? p(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, 
                        a.maxHeight = p(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = d : this.sessionVariables.labelMaxHeight, 
                        a.measureText(); else if ("left" === this._position || "right" === this._position) if (h = p(this.options.labelMaxWidth) ? .3 * this.chart.width >> 0 : this.options.labelMaxWidth, 
                        d = "undefined" === typeof this.options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, 
                        !this.chart.panEnabled && 1 <= this._labels.length) {
                            this.sessionVariables.labelFontSize = this.labelFontSize;
                            this.sessionVariables.labelMaxWidth = h;
                            this.sessionVariables.labelMaxHeight = d;
                            this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
                            this.sessionVariables.labelWrap = this.labelWrap;
                            for (c = 0; c < this._labels.length; c++) if (!this._labels[c].breaksLabelType) {
                                a = this._labels[c].textBlock;
                                B = a.measureText();
                                for (g = c + 1; g < this._labels.length; g++) if (!this._labels[g].breaksLabelType) {
                                    e = this._labels[g].textBlock;
                                    e = e.measureText();
                                    break;
                                }
                                f.push(a.height);
                                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, f);
                                b = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                                p(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? p(this.options.labelWrap) ? p(this.options.labelWrap) && (p(this.options.labelMaxWidth) ? p(e) || (l = B.height + e.height >> 0, 
                                l - 2 * d > n && (n = l - 2 * d, l >= 2 * d && l < 2.4 * d ? (p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), 
                                a.measureText()), this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : l >= 2.4 * d && l < 2.8 * d ? (this.sessionVariables.labelMaxHeight = b, 
                                this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : l >= 2.8 * d && l < 3.2 * d ? (this.sessionVariables.labelMaxHeight = d, 
                                this.sessionVariables.labelWrap = !0, p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), 
                                a.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, 
                                this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l >= 3.2 * d && l < 3.6 * d ? (this.sessionVariables.labelMaxHeight = b, 
                                this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : l > 3.6 * d && l < 10 * d ? (p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), 
                                a.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, 
                                this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = d, 
                                this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l > 10 * d && l < 50 * d && (p(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), 
                                a.measureText()), this.sessionVariables.labelFontSize = p(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, 
                                this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = h, 
                                this.sessionVariables.labelAngle = p(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = d, 
                                this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : h, 
                                this.sessionVariables.labelMaxHeight = d) : (this.sessionVariables.labelAngle = this.labelAngle, 
                                this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? h : Math.min((b - d * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), d), 
                                p(this.options.labelWrap)) ? p(this.options.labelWrap) && (this.labelWrap && !p(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, 
                                this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = b) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : h, 
                                this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : b, p(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : b, 
                                this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = h) : (this.sessionVariables.labelMaxHeight = d, 
                                p(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, 
                                this.sessionVariables.labelWrap = this.labelWrap);
                            }
                            for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, 
                            a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, 
                            a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, 
                            a.measureText();
                        } else for (c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, 
                        a.maxWidth = this.labelMaxWidth = p(this.options.labelMaxWidth) ? p(this.sessionVariables.labelMaxWidth) ? this.sessionVariables.labelMaxWidth = h : this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, 
                        a.fontSize = this.labelFontSize = p(this.options.labelFontSize) ? p(this.sessionVariables.labelFontSize) ? this.sessionVariables.labelFontSize = this.labelFontSize : this.sessionVariables.labelFontSize : this.options.labelFontSize, 
                        a.angle = this.labelAngle = p(this.options.labelAngle) ? p(this.sessionVariables.labelAngle) ? this.sessionVariables.labelAngle = this.labelAngle : this.sessionVariables.labelAngle : this.labelAngle, 
                        a.wrap = this.labelWrap = p(this.options.labelWrap) ? p(this.sessionVariables.labelWrap) ? this.sessionVariables.labelWrap = this.labelWrap : this.sessionVariables.labelWrap : this.options.labelWrap, 
                        a.maxHeight = p(this.sessionVariables.labelMaxHeight) ? this.sessionVariables.labelMaxHeight = d : this.sessionVariables.labelMaxHeight, 
                        a.measureText();
                        for (c = 0; c < this.stripLines.length; c++) {
                            var y;
                            h = this.stripLines[c];
                            if ("outside" === h.labelPlacement) {
                                d = this.sessionVariables.labelMaxWidth;
                                if ("bottom" === this._position || "top" === this._position) p(h.options.labelWrap) && !p(this.sessionVariables.stripLineLabelMaxHeight) ? y = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = y = h.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
                                if ("left" === this._position || "right" === this._position) p(h.options.labelWrap) && !p(this.sessionVariables.stripLineLabelMaxHeight) ? y = this.sessionVariables.stripLineLabelMaxHeight : this.sessionVariables.stripLineLabelMaxHeight = y = h.labelWrap ? .8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;
                                p(h.labelBackgroundColor) && (h.labelBackgroundColor = "#EEEEEE");
                            } else d = "bottom" === this._position || "top" === this._position ? .9 * this.chart.width >> 0 : .9 * this.chart.height >> 0, 
                            y = p(h.options.labelWrap) || h.labelWrap ? "bottom" === this._position || "top" === this._position ? .8 * this.chart.width >> 0 : .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, 
                            p(h.labelBackgroundColor) && (p(h.startValue) && 0 !== h.startValue ? h.labelBackgroundColor = v ? "transparent" : null : h.labelBackgroundColor = "#EEEEEE");
                            a = new ka(this.ctx, {
                                x: 0,
                                y: 0,
                                backgroundColor: h.labelBackgroundColor,
                                borderColor: h.labelBorderColor,
                                borderThickness: h.labelBorderThickness,
                                cornerRadius: h.labelCornerRadius,
                                maxWidth: h.options.labelMaxWidth ? h.options.labelMaxWidth : d,
                                maxHeight: y,
                                angle: this.labelAngle,
                                text: h.labelFormatter ? h.labelFormatter({
                                    chart: this.chart,
                                    axis: this,
                                    stripLine: h
                                }) : h.label,
                                textAlign: this.labelTextAlign,
                                fontSize: "outside" === h.labelPlacement ? h.options.labelFontSize ? h.labelFontSize : this.labelFontSize : h.labelFontSize,
                                fontFamily: "outside" === h.labelPlacement ? h.options.labelFontFamily ? h.labelFontFamily : this.labelFontFamily : h.labelFontFamily,
                                fontWeight: "outside" === h.labelPlacement ? h.options.labelFontWeight ? h.labelFontWeight : this.labelFontWeight : h.labelFontWeight,
                                fontColor: h.labelFontColor || h.color,
                                fontStyle: "outside" === h.labelPlacement ? h.options.labelFontStyle ? h.labelFontStyle : this.fontWeight : h.labelFontStyle,
                                textBaseline: "middle"
                            });
                            this._stripLineLabels.push({
                                position: h.value,
                                textBlock: a,
                                effectiveHeight: null,
                                stripLine: h
                            });
                        }
                    };
                    D.prototype.createLabelsAndCalculateWidth = function() {
                        var a = 0, e = 0;
                        this._labels = [];
                        this._stripLineLabels = [];
                        var c = this.chart.isNavigator ? 0 : 5;
                        if ("left" === this._position || "right" === this._position) {
                            this.createLabels();
                            if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index) for (e = 0; e < this._labels.length; e++) {
                                var b = this._labels[e].textBlock, f = b.measureText(), h = 0;
                                h = 0 === this.labelAngle ? f.width : f.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (f.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                                a < h && (this.labelEffectiveWidth = a = h);
                                this._labels[e].effectiveWidth = h;
                            }
                            for (e = 0; e < this._stripLineLabels.length; e++) "outside" === this._stripLineLabels[e].stripLine.labelPlacement && this._stripLineLabels[e].stripLine.value >= this.viewportMinimum && this._stripLineLabels[e].stripLine.value <= this.viewportMaximum && (b = this._stripLineLabels[e].textBlock, 
                            f = b.measureText(), h = 0 === this.labelAngle ? f.width : f.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (f.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), 
                            "inside" === this.tickPlacement && (h += this.tickLength), "inside" === this.labelPlacement && (a += 0 < this._index ? h : 0), 
                            a < h && (a = h), this.stripLineLabelEffectiveWidth = this._stripLineLabels[e].effectiveWidth = h);
                        }
                        return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + ("inside" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + c;
                    };
                    D.prototype.createLabelsAndCalculateHeight = function() {
                        var a = 0;
                        this._labels = [];
                        this._stripLineLabels = [];
                        var e, c = 0, b = this.chart.isNavigator ? 0 : 5;
                        if ("bottom" === this._position || "top" === this._position) {
                            this.createLabels();
                            if ("inside" != this.labelPlacement || "inside" === this.labelPlacement && 0 < this._index) for (c = 0; c < this._labels.length; c++) {
                                e = this._labels[c].textBlock;
                                var f = e.measureText(), h = 0;
                                h = 0 === this.labelAngle ? f.height : f.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (f.height - e.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                                a < h && (this.labelEffectiveHeight = a = h);
                                this._labels[c].effectiveHeight = h;
                            }
                            for (c = 0; c < this._stripLineLabels.length; c++) "outside" === this._stripLineLabels[c].stripLine.labelPlacement && this._stripLineLabels[c].stripLine.value >= this.viewportMinimum && this._stripLineLabels[c].stripLine.value <= this.viewportMaximum && (e = this._stripLineLabels[c].textBlock, 
                            f = e.measureText(), h = 0 === this.labelAngle ? f.height : f.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (f.height - e.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), 
                            "inside" === this.tickPlacement && (h += this.tickLength), "inside" === this.labelPlacement && (a += 0 < this._index ? h : 0), 
                            a < h && (a = h), this.stripLineLabelEffectiveHeight = this._stripLineLabels[c].effectiveHeight = h);
                        }
                        return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + ("inside" === this.tickPlacement ? 0 < this._index ? this.tickLength : 0 : this.tickLength) + b;
                    };
                    D.setLayout = function(a, e, c, b, f, h) {
                        var d, l, t, k, m = a[0] ? a[0].chart : e[0].chart, q = m.isNavigator ? 0 : 10, n = m._axes;
                        if (a && 0 < a.length) for (var g = 0; g < a.length; g++) a[g] && a[g].calculateAxisParameters();
                        if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateAxisParameters();
                        if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].calculateAxisParameters();
                        if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].calculateAxisParameters();
                        for (g = 0; g < n.length; g++) if (n[g] && n[g].scaleBreaks && n[g].scaleBreaks._appliedBreaks.length) for (var v = n[g].scaleBreaks._appliedBreaks, w = 0; w < v.length && !(v[w].startValue > n[g].viewportMaximum); w++) v[w].endValue < n[g].viewportMinimum || (p(n[g].scaleBreaks.firstBreakIndex) && (n[g].scaleBreaks.firstBreakIndex = w), 
                        v[w].startValue >= n[g].viewPortMinimum && (n[g].scaleBreaks.lastBreakIndex = w));
                        var A, D, I, K, N, y = w = 0, s = 0, z = 0, u = 0, B = 0, C = 0, H = l = 0;
                        for (v = I = K = N = !1, g = 0; g < n.length; g++) n[g] && n[g].title && (n[g]._titleTextBlock = new ka(n[g].ctx, {
                            text: n[g].title,
                            horizontalAlign: "center",
                            fontSize: n[g].titleFontSize,
                            fontFamily: n[g].titleFontFamily,
                            fontWeight: n[g].titleFontWeight,
                            fontColor: n[g].titleFontColor,
                            fontStyle: n[g].titleFontStyle,
                            borderColor: n[g].titleBorderColor,
                            borderThickness: n[g].titleBorderThickness,
                            backgroundColor: n[g].titleBackgroundColor,
                            cornerRadius: n[g].titleCornerRadius,
                            textBaseline: "middle"
                        }));
                        for (g = 0; g < n.length; g++) if (n[g].title) switch (n[g]._position) {
                          case "left":
                            n[g]._titleTextBlock.maxWidth = n[g].titleMaxWidth || h.height;
                            n[g]._titleTextBlock.maxHeight = n[g].titleWrap ? .8 * h.width : 1.5 * n[g].titleFontSize;
                            n[g]._titleTextBlock.angle = -90;
                            break;

                          case "right":
                            n[g]._titleTextBlock.maxWidth = n[g].titleMaxWidth || h.height;
                            n[g]._titleTextBlock.maxHeight = n[g].titleWrap ? .8 * h.width : 1.5 * n[g].titleFontSize;
                            n[g]._titleTextBlock.angle = 90;
                            break;

                          default:
                            n[g]._titleTextBlock.maxWidth = n[g].titleMaxWidth || h.width, n[g]._titleTextBlock.maxHeight = n[g].titleWrap ? .8 * h.height : 1.5 * n[g].titleFontSize, 
                            n[g]._titleTextBlock.angle = 0;
                        }
                        if ("normal" === f) {
                            z = [], u = [], B = [], C = [];
                            for (var O = [], Q = [], P = [], S = []; 4 > w; ) {
                                var F = 0, Y = 0, U = 0, V = 0, X = f = 0, M = 0, $ = 0, W = 0, Z = 0, R = 0, aa = 0;
                                if (c && 0 < c.length) for (B = [], g = R = 0; g < c.length; g++) B.push(Math.ceil(c[g] ? c[g].createLabelsAndCalculateWidth() : 0)), 
                                R += B[g], M += c[g] && !m.isNavigator ? c[g].margin : 0; else B.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));
                                P.push(B);
                                if (b && 0 < b.length) for (C = [], g = aa = 0; g < b.length; g++) C.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateWidth() : 0)), 
                                aa += C[g], $ += b[g] ? b[g].margin : 0; else C.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));
                                S.push(C);
                                d = Math.round(h.x1 + R + M);
                                t = Math.round(h.x2 - aa - $ > m.width - q ? m.width - q : h.x2 - aa - $);
                                if (a && 0 < a.length) for (z = [], g = W = 0; g < a.length; g++) a[g] && (a[g].lineCoordinates = {}), 
                                a[g].lineCoordinates.width = Math.abs(t - d), a[g].title && (a[g]._titleTextBlock.maxWidth = 0 < a[g].titleMaxWidth && a[g].titleMaxWidth < a[g].lineCoordinates.width ? a[g].titleMaxWidth : a[g].lineCoordinates.width), 
                                z.push(Math.ceil(a[g] ? a[g].createLabelsAndCalculateHeight() : 0)), W += z[g], 
                                f += a[g] && !m.isNavigator ? a[g].margin : 0; else z.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));
                                O.push(z);
                                if (e && 0 < e.length) for (u = [], g = Z = 0; g < e.length; g++) e[g] && (e[g].lineCoordinates = {}), 
                                e[g].lineCoordinates.width = Math.abs(t - d), e[g].title && (e[g]._titleTextBlock.maxWidth = 0 < e[g].titleMaxWidth && e[g].titleMaxWidth < e[g].lineCoordinates.width ? e[g].titleMaxWidth : e[g].lineCoordinates.width), 
                                u.push(Math.ceil(e[g] ? e[g].createLabelsAndCalculateHeight() : 0)), Z += u[g], 
                                X += e[g] && !m.isNavigator ? e[g].margin : 0; else u.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateHeight() : 0));
                                Q.push(u);
                                if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g] && (a[g].lineCoordinates.x1 = d, 
                                t = Math.round(h.x2 - aa - $ > m.width - q ? m.width - q : h.x2 - aa - $), a[g]._labels && 1 < a[g]._labels.length && (l = k = 0, 
                                k = a[g]._labels[1], l = "dateTime" === a[g].valueType ? a[g]._labels[a[g]._labels.length - 2] : a[g]._labels[a[g]._labels.length - 1], 
                                y = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), 
                                s = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), 
                                !a[g] || !a[g].labelAutoFit || p(A) || p(D) || m.isNavigator || m.stockChart || (l = 0, 
                                0 < a[g].labelAngle ? D + s > t && (l += 0 < a[g].labelAngle ? D + s - t - aa : 0) : 0 > a[g].labelAngle ? A - y < d && A - y < a[g].viewportMinimum && (H = d - (M + a[g].tickLength + B + A - y + a[g].labelFontSize / 2)) : 0 === a[g].labelAngle && (D + s > t && (l = D + s / 2 - t - aa), 
                                A - y < d && A - y < a[g].viewportMinimum && (H = d - M - a[g].tickLength - B - A + y / 2)), 
                                a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 < a[g].labelAngle && 0 < l ? t -= l : a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 > a[g].labelAngle && 0 < H ? d += H : a[g].viewportMaximum === a[g].maximum && a[g].viewportMinimum === a[g].minimum && 0 === a[g].labelAngle && (0 < H && (d += H), 
                                0 < l && (t -= l))), m.panEnabled ? W = p(m.sessionVariables.axisX.height) ? m.sessionVariables.axisX.height = W : m.sessionVariables.axisX.height : m.sessionVariables.axisX.height = W, 
                                l = Math.round(h.y2 - W - f + F), k = Math.round(h.y2), a[g].lineCoordinates.x2 = t, 
                                a[g].lineCoordinates.width = t - d, a[g].lineCoordinates.y1 = l, a[g].lineCoordinates.y2 = l, 
                                "inside" === a[g].labelPlacement && 0 < g && (a[g].lineCoordinates.y1 = a[g - 1].lineCoordinates.y2 + F + (a[g].labelEffectiveHeight || 0), 
                                a[g].lineCoordinates.y2 = a[g].lineCoordinates.y1 + a[g].lineThickness / 2), "inside" === a[g].tickPlacement && 0 < g && (a[g].lineCoordinates.y1 += a[g].tickLength, 
                                a[g].lineCoordinates.y2 = a[g].lineCoordinates.y1 + a[g].lineThickness / 2), a[g].bounds = {
                                    x1: d,
                                    y1: l,
                                    x2: t,
                                    y2: k - (W + f - z[g] - F),
                                    width: t - d
                                }, a[g].bounds.height = a[g].bounds.y2 - a[g].bounds.y1), F += z[g] + a[g].margin;
                                if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].lineCoordinates.x1 = Math.round(h.x1 + R + M), 
                                e[g].lineCoordinates.x2 = Math.round(h.x2 - aa - $ > m.width - q ? m.width - q : h.x2 - aa - $), 
                                e[g].lineCoordinates.width = Math.abs(t - d), e[g]._labels && 1 < e[g]._labels.length && (k = e[g]._labels[1], 
                                l = "dateTime" === e[g].valueType ? e[g]._labels[e[g]._labels.length - 2] : e[g]._labels[e[g]._labels.length - 1], 
                                y = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), 
                                s = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), 
                                m.panEnabled ? Z = p(m.sessionVariables.axisX2.height) ? m.sessionVariables.axisX2.height = Z : m.sessionVariables.axisX2.height : m.sessionVariables.axisX2.height = Z, 
                                l = Math.round(h.y1), k = e[g].lineCoordinates.y1 = l + Z + X - Y, e[g].lineCoordinates.y2 = l, 
                                "inside" === e[g].labelPlacement && 0 < g && (e[g].lineCoordinates.y1 = e[g - 1].lineCoordinates.y1 - Y - (e[g].labelEffectiveHeight || 0)), 
                                "inside" === e[g].tickPlacement && 0 < g && (e[g].lineCoordinates.y1 -= e[g].tickLength), 
                                e[g].bounds = {
                                    x1: d,
                                    y1: l + (Z + X - u[g] - Y),
                                    x2: t,
                                    y2: k,
                                    width: t - d
                                }, e[g].bounds.height = e[g].bounds.y2 - e[g].bounds.y1, Y += u[g] + e[g].margin;
                                if (c && 0 < c.length) for (g = 0; g < c.length; g++) M = m.isNavigator ? 0 : 10, 
                                c[g] && (d = Math.round(a[0] ? a[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), 
                                M = c[g]._labels && 0 < c[g]._labels.length ? c[g]._labels[c[g]._labels.length - 1].textBlock.height / 2 : q, 
                                l = Math.round(h.y1 + Z + X < Math.max(M, q) ? Math.max(M, q) : h.y1 + Z + X), t = Math.round(a[0] ? a[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), 
                                M = 0 < a.length ? 0 : c[g]._labels && 0 < c[g]._labels.length ? c[g]._labels[0].textBlock.height / 2 : q, 
                                k = Math.round(h.y2 - W - f - M), c[g].lineCoordinates = {
                                    x1: d - U,
                                    y1: l,
                                    x2: t - U,
                                    y2: k,
                                    height: Math.abs(k - l)
                                }, "inside" === c[g].labelPlacement && 0 < g && (c[g].lineCoordinates.x1 = c[g - 1].lineCoordinates.x1 - U - (c[g].labelEffectiveWidth || 0), 
                                c[g].lineCoordinates.x2 = c[g].lineCoordinates.x1 + c[g].lineThickness / 2), "inside" === c[g].tickPlacement && 0 < g && (c[g].lineCoordinates.x1 -= c[g].tickLength, 
                                c[g].lineCoordinates.x2 = c[g].lineCoordinates.x1 + c[g].lineThickness / 2), c[g].bounds = {
                                    x1: d - (B[g] + U),
                                    y1: l,
                                    x2: t - U,
                                    y2: k,
                                    height: k - l
                                }, c[g].bounds.width = c[g].bounds.x2 - c[g].bounds.x1, c[g].title && (c[g]._titleTextBlock.maxWidth = 0 < c[g].titleMaxWidth && c[g].titleMaxWidth < c[g].lineCoordinates.height ? c[g].titleMaxWidth : c[g].lineCoordinates.height), 
                                U += B[g] + c[g].margin);
                                if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g] && (d = Math.round(a[0] ? a[0].lineCoordinates.x2 : e[0].lineCoordinates.x2), 
                                t = Math.round(d), M = b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[b[g]._labels.length - 1].textBlock.height / 2 : 0, 
                                l = Math.round(h.y1 + Z + X < Math.max(M, q) ? Math.max(M, q) : h.y1 + Z + X), M = 0 < a.length ? 0 : b[g]._labels && 0 < b[g]._labels.length ? b[g]._labels[0].textBlock.height / 2 : 0, 
                                k = Math.round(h.y2 - (W + f + M)), b[g].lineCoordinates = {
                                    x1: d + V,
                                    y1: l,
                                    x2: d + V,
                                    y2: k,
                                    height: Math.abs(k - l)
                                }, "inside" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.x1 = b[g - 1].lineCoordinates.x2 + V + (b[g].labelEffectiveWidth || 0), 
                                b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), "inside" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.x1 += b[g].tickLength, 
                                b[g].lineCoordinates.x2 = b[g].lineCoordinates.x1 + b[g].lineThickness / 2), b[g].bounds = {
                                    x1: d + V,
                                    y1: l,
                                    x2: t + (C[g] + V),
                                    y2: k,
                                    height: k - l
                                }, b[g].bounds.width = b[g].bounds.x2 - b[g].bounds.x1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.height ? b[g].titleMaxWidth : b[g].lineCoordinates.height), 
                                V += C[g] + b[g].margin);
                                if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g] && (a[g].calculateValueToPixelConversionParameters(), 
                                a[g].calculateBreaksSizeInValues(), a[g]._labels && 1 < a[g]._labels.length && (A = (a[g].logarithmic ? Math.log(a[g]._labels[1].position / a[g].viewportMinimum) / a[g].conversionParameters.lnLogarithmBase : a[g]._labels[1].position - a[g].viewportMinimum) * Math.abs(a[g].conversionParameters.pixelPerUnit) + a[g].lineCoordinates.x1, 
                                d = a[g]._labels[a[g]._labels.length - ("dateTime" === a[g].valueType ? 2 : 1)].position, 
                                d = a[g].getApparentDifference(a[g].viewportMinimum, d), D = a[g].logarithmic ? (1 < d ? Math.log(d) / a[g].conversionParameters.lnLogarithmBase * Math.abs(a[g].conversionParameters.pixelPerUnit) : 0) + a[g].lineCoordinates.x1 : (0 < d ? d * Math.abs(a[g].conversionParameters.pixelPerUnit) : 0) + a[g].lineCoordinates.x1));
                                if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateValueToPixelConversionParameters(), 
                                e[g].calculateBreaksSizeInValues(), e[g]._labels && 1 < e[g]._labels.length && (A = (e[g].logarithmic ? Math.log(e[g]._labels[1].position / e[g].viewportMinimum) / e[g].conversionParameters.lnLogarithmBase : e[g]._labels[1].position - e[g].viewportMinimum) * Math.abs(e[g].conversionParameters.pixelPerUnit) + e[g].lineCoordinates.x1, 
                                d = e[g]._labels[e[g]._labels.length - ("dateTime" === e[g].valueType ? 2 : 1)].position, 
                                d = e[g].getApparentDifference(e[g].viewportMinimum, d), D = e[g].logarithmic ? (1 < d ? Math.log(d) / e[g].conversionParameters.lnLogarithmBase * Math.abs(e[g].conversionParameters.pixelPerUnit) : 0) + e[g].lineCoordinates.x1 : (0 < d ? d * Math.abs(e[g].conversionParameters.pixelPerUnit) : 0) + e[g].lineCoordinates.x1);
                                for (g = 0; g < n.length; g++) "axisY" === n[g].type && (n[g].calculateValueToPixelConversionParameters(), 
                                n[g].calculateBreaksSizeInValues());
                                if (0 < w) {
                                    if (a && 0 < a.length) for (g = 0; g < a.length; g++) v = O[w - 1][g] === O[w][g] ? !0 : !1; else v = !0;
                                    if (e && 0 < e.length) for (g = 0; g < e.length; g++) I = Q[w - 1][g] === Q[w][g] ? !0 : !1; else I = !0;
                                    if (c && 0 < c.length) for (g = 0; g < c.length; g++) K = P[w - 1][g] === P[w][g] ? !0 : !1; else K = !0;
                                    if (b && 0 < b.length) for (g = 0; g < b.length; g++) N = S[w - 1][g] === S[w][g] ? !0 : !1; else N = !0;
                                }
                                if (v && I && K && N) break;
                                w++;
                            }
                            if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g].calculateStripLinesThicknessInValues(), 
                            a[g].calculateBreaksInPixels();
                            if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateStripLinesThicknessInValues(), 
                            e[g].calculateBreaksInPixels();
                            if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].calculateStripLinesThicknessInValues(), 
                            c[g].calculateBreaksInPixels();
                            if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].calculateStripLinesThicknessInValues(), 
                            b[g].calculateBreaksInPixels();
                        } else {
                            q = [];
                            A = [];
                            H = [];
                            y = [];
                            D = [];
                            s = [];
                            O = [];
                            for (Q = []; 4 > w; ) {
                                W = V = U = $ = M = X = f = S = P = F = Z = 0;
                                if (a && 0 < a.length) for (H = [], g = V = 0; g < a.length; g++) H.push(Math.ceil(a[g] ? a[g].createLabelsAndCalculateWidth() : 0)), 
                                V += H[g], f += a[g] && !m.isNavigator ? a[g].margin : 0; else H.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));
                                O.push(H);
                                if (e && 0 < e.length) for (y = [], g = W = 0; g < e.length; g++) y.push(Math.ceil(e[g] ? e[g].createLabelsAndCalculateWidth() : 0)), 
                                W += y[g], X += e[g] ? e[g].margin : 0; else y.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateWidth() : 0));
                                Q.push(y);
                                if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].lineCoordinates = {}, 
                                d = Math.round(h.x1 + V + f), t = Math.round(h.x2 - W - X > m.width - 10 ? m.width - 10 : h.x2 - W - X), 
                                c[g].labelAutoFit && !p(z) && (0 < !a.length && (d = 0 > c[g].labelAngle ? Math.max(d, z) : 0 === c[g].labelAngle ? Math.max(d, z / 2) : d), 
                                0 < !e.length && (t = 0 < c[g].labelAngle ? t - u / 2 : 0 === c[g].labelAngle ? t - u / 2 : t)), 
                                c[g].lineCoordinates.x1 = d, c[g].lineCoordinates.x2 = t, c[g].lineCoordinates.width = Math.abs(t - d), 
                                c[g].title && (c[g]._titleTextBlock.maxWidth = 0 < c[g].titleMaxWidth && c[g].titleMaxWidth < c[g].lineCoordinates.width ? c[g].titleMaxWidth : c[g].lineCoordinates.width);
                                if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].lineCoordinates = {}, 
                                d = Math.round(h.x1 + V + f), t = Math.round(h.x2 - W - X > b[g].chart.width - 10 ? b[g].chart.width - 10 : h.x2 - W - X), 
                                b[g] && b[g].labelAutoFit && !p(B) && (0 < !a.length && (d = 0 < b[g].labelAngle ? Math.max(d, B) : 0 === b[g].labelAngle ? Math.max(d, B / 2) : d), 
                                0 < !e.length && (t -= C / 2)), b[g].lineCoordinates.x1 = d, b[g].lineCoordinates.x2 = t, 
                                b[g].lineCoordinates.width = Math.abs(t - d), b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width);
                                if (c && 0 < c.length) for (q = [], g = U = 0; g < c.length; g++) q.push(Math.ceil(c[g] ? c[g].createLabelsAndCalculateHeight() : 0)), 
                                U += q[g] + c[g].margin, M += c[g].margin; else q.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0));
                                D.push(q);
                                if (b && 0 < b.length) for (A = [], g = 0; g < b.length; g++) A.push(Math.ceil(b[g] ? b[g].createLabelsAndCalculateHeight() : 0)), 
                                $ += b[g].margin; else A.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));
                                s.push(A);
                                if (c && 0 < c.length) for (g = 0; g < c.length; g++) 0 < c[g]._labels.length && (k = c[g]._labels[0], 
                                l = c[g]._labels[c[g]._labels.length - 1], z = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), 
                                u = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));
                                if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g] && 0 < b[g]._labels.length && (k = b[g]._labels[0], 
                                l = b[g]._labels[b[g]._labels.length - 1], B = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), 
                                C = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));
                                if (m.panEnabled) for (g = 0; g < c.length; g++) q[g] = p(m.sessionVariables.axisY[g].height) ? m.sessionVariables.axisY[g].height = q[g] : m.sessionVariables.axisY[g].height; else for (g = 0; g < c.length; g++) m.sessionVariables.axisY[g].height = q[g];
                                if (c && 0 < c.length) for (g = c.length - 1; 0 <= g; g--) l = Math.round(h.y2), 
                                k = Math.round(h.y2 > c[g].chart.height ? c[g].chart.height : h.y2), c[g].lineCoordinates.y1 = l - (q[g] + c[g].margin + Z), 
                                c[g].lineCoordinates.y2 = l - (q[g] + c[g].margin + Z), "inside" === c[g].labelPlacement && 0 < g && (c[g].lineCoordinates.y1 = c[g].lineCoordinates.y1 + q[g] - (c[g]._titleTextBlock ? c[g]._titleTextBlock.height : 0) - c[g].tickLength - (c[g].stripLineLabelEffectiveHeight || 0) - 5, 
                                c[g].lineCoordinates.y2 = c[g].lineCoordinates.y1 + c[g].lineThickness / 2), "inside" === c[g].tickPlacement && 0 < g && (c[g].lineCoordinates.y1 += c[g].tickLength, 
                                c[g].lineCoordinates.y2 = c[g].lineCoordinates.y1 + c[g].lineThickness / 2), c[g].bounds = {
                                    x1: d,
                                    y1: l - (q[g] + Z + c[g].margin),
                                    x2: t,
                                    y2: k - (Z + c[g].margin),
                                    width: t - d,
                                    height: q[g]
                                }, c[g].title && (c[g]._titleTextBlock.maxWidth = 0 < c[g].titleMaxWidth && c[g].titleMaxWidth < c[g].lineCoordinates.width ? c[g].titleMaxWidth : c[g].lineCoordinates.width), 
                                Z += q[g] + c[g].margin;
                                if (b && 0 < b.length) for (g = b.length - 1; 0 <= g; g--) b[g] && (l = Math.round(h.y1), 
                                k = Math.round(h.y1 + (A[g] + b[g].margin + F)), b[g].lineCoordinates.y1 = k, b[g].lineCoordinates.y2 = k, 
                                "inside" === b[g].labelPlacement && 0 < g && (b[g].lineCoordinates.y1 = k - A[g] + (b[g]._titleTextBlock ? b[g]._titleTextBlock.height : 0) + b[g].tickLength + (b[g].stripLineLabelEffectiveHeight || 0), 
                                b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), "inside" === b[g].tickPlacement && 0 < g && (b[g].lineCoordinates.y1 -= b[g].tickLength, 
                                b[g].lineCoordinates.y2 = b[g].lineCoordinates.y1 - b[g].lineThickness / 2), b[g].bounds = {
                                    x1: d,
                                    y1: l + (b[g].margin + F),
                                    x2: t,
                                    y2: k,
                                    width: t - d
                                }, b[g].bounds.height = b[g].bounds.y2 - b[g].bounds.y1, b[g].title && (b[g]._titleTextBlock.maxWidth = 0 < b[g].titleMaxWidth && b[g].titleMaxWidth < b[g].lineCoordinates.width ? b[g].titleMaxWidth : b[g].lineCoordinates.width), 
                                F += A[g] + b[g].margin);
                                if (a && 0 < a.length) for (g = 0; g < a.length; g++) {
                                    M = a[g]._labels && 0 < a[g]._labels.length ? a[g]._labels[0].textBlock.fontSize / 2 : 0;
                                    d = Math.round(h.x1 + f);
                                    l = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1) : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1;
                                    t = Math.round(h.x1 + V + f);
                                    k = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y1 : h.y2 - U > m.height - Math.max(M, 10) ? m.height - Math.max(M, 10) : h.y2 - U) : h.y2 > m.height - Math.max(M, 10) ? m.height - Math.max(M, 10) : h.y2;
                                    if (c && 0 < c.length) for (M = 0; M < c.length; M++) c[M] && c[M].labelAutoFit && (t = c[M].lineCoordinates.x1, 
                                    d = 0 > c[M].labelAngle || 0 === c[M].labelAngle ? t - V : d);
                                    if (b && 0 < b.length) for (M = 0; M < b.length; M++) b[M] && b[M].labelAutoFit && (t = b[M].lineCoordinates.x1, 
                                    d = t - V);
                                    a[g].lineCoordinates = {
                                        x1: t - P,
                                        y1: l,
                                        x2: t - P,
                                        y2: k,
                                        height: Math.abs(k - l)
                                    };
                                    "inside" === a[g].labelPlacement && 0 < g && (a[g].lineCoordinates.x1 = a[g].lineCoordinates.x1 - (H[g] - (a[g]._titleTextBlock ? a[g]._titleTextBlock.height : 0)) + a[g].tickLength + (a[g].stripLineLabelEffectiveWidth || 0), 
                                    a[g].lineCoordinates.x2 = a[g].lineCoordinates.x1 + a[g].lineThickness / 2);
                                    "inside" === a[g].tickPlacement && 0 < g && (a[g].lineCoordinates.x1 -= a[g].tickLength, 
                                    a[g].lineCoordinates.x2 = a[g].lineCoordinates.x1 + a[g].lineThickness / 2);
                                    a[g].bounds = {
                                        x1: t - (H[g] + P),
                                        y1: l,
                                        x2: t - P,
                                        y2: k,
                                        height: k - l
                                    };
                                    a[g].bounds.width = a[g].bounds.x2 - a[g].bounds.x1;
                                    a[g].title && (a[g]._titleTextBlock.maxWidth = 0 < a[g].titleMaxWidth && a[g].titleMaxWidth < a[g].lineCoordinates.height ? a[g].titleMaxWidth : a[g].lineCoordinates.height);
                                    a[g].calculateValueToPixelConversionParameters();
                                    a[g].calculateBreaksSizeInValues();
                                    P += H[g] + a[g].margin;
                                }
                                if (e && 0 < e.length) for (g = 0; g < e.length; g++) {
                                    M = e[g]._labels && 0 < e[g]._labels.length ? e[g]._labels[0].textBlock.fontSize / 2 : 0;
                                    d = Math.round(h.x1 - f);
                                    l = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y2 : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1) : h.y1 < Math.max(M, 10) ? Math.max(M, 10) : h.y1;
                                    t = Math.round(h.x2 - W - X);
                                    k = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y1 : h.y2 - U > m.height - Math.max(M, 10) ? m.height - Math.max(M, 10) : h.y2 - U) : h.y2 > m.height - Math.max(M, 10) ? m.height - Math.max(M, 10) : h.y2;
                                    if (c && 0 < c.length) for (M = 0; M < c.length; M++) c[M] && c[M].labelAutoFit && (t = 0 > c[M].labelAngle ? Math.max(t, z) : 0 === c[M].labelAngle ? Math.max(t, z / 2) : t, 
                                    d = 0 > c[M].labelAngle || 0 === c[M].labelAngle ? t - W : d);
                                    if (b && 0 < b.length) for (M = 0; M < b.length; M++) b[M] && b[M].labelAutoFit && (t = b[M].lineCoordinates.x2, 
                                    d = t - W);
                                    e[g].lineCoordinates = {
                                        x1: t + S,
                                        y1: l,
                                        x2: t + S,
                                        y2: k,
                                        height: Math.abs(k - l)
                                    };
                                    "inside" === e[g].labelPlacement && 0 < g && (e[g].lineCoordinates.x1 = e[g].lineCoordinates.x1 + (y[g] - (e[g]._titleTextBlock ? e[g]._titleTextBlock.height : 0) - 2) - e[g].tickLength - (e[g].stripLineLabelEffectiveWidth || 0), 
                                    e[g].lineCoordinates.x2 = e[g].lineCoordinates.x1 + e[g].lineThickness / 2);
                                    "inside" === e[g].tickPlacement && 0 < g && (e[g].lineCoordinates.x1 += e[g].tickLength, 
                                    e[g].lineCoordinates.x2 = e[g].lineCoordinates.x1 + e[g].lineThickness / 2);
                                    e[g].bounds = {
                                        x1: e[g].lineCoordinates.x1,
                                        y1: l,
                                        x2: t + y[g] + S,
                                        y2: k,
                                        width: t - d,
                                        height: k - l
                                    };
                                    e[g].bounds.width = e[g].bounds.x2 - e[g].bounds.x1;
                                    e[g].title && (e[g]._titleTextBlock.maxWidth = 0 < e[g].titleMaxWidth && e[g].titleMaxWidth < e[g].lineCoordinates.height ? e[g].titleMaxWidth : e[g].lineCoordinates.height);
                                    e[g].calculateValueToPixelConversionParameters();
                                    e[g].calculateBreaksSizeInValues();
                                    S += y[g] + e[g].margin;
                                }
                                for (g = 0; g < n.length; g++) "axisY" === n[g].type && (n[g].calculateValueToPixelConversionParameters(), 
                                n[g].calculateBreaksSizeInValues());
                                if (0 < w) {
                                    if (a && 0 < a.length) for (g = 0; g < a.length; g++) v = O[w - 1][g] === O[w][g] ? !0 : !1; else v = !0;
                                    if (e && 0 < e.length) for (g = 0; g < e.length; g++) I = Q[w - 1][g] === Q[w][g] ? !0 : !1; else I = !0;
                                    if (c && 0 < c.length) for (g = 0; g < c.length; g++) K = D[w - 1][g] === D[w][g] ? !0 : !1; else K = !0;
                                    if (b && 0 < b.length) for (g = 0; g < b.length; g++) N = s[w - 1][g] === s[w][g] ? !0 : !1; else N = !0;
                                }
                                if (v && I && K && N) break;
                                w++;
                            }
                            if (c && 0 < c.length) for (g = 0; g < c.length; g++) c[g].calculateStripLinesThicknessInValues(), 
                            c[g].calculateBreaksInPixels();
                            if (b && 0 < b.length) for (g = 0; g < b.length; g++) b[g].calculateStripLinesThicknessInValues(), 
                            b[g].calculateBreaksInPixels();
                            if (a && 0 < a.length) for (g = 0; g < a.length; g++) a[g].calculateStripLinesThicknessInValues(), 
                            a[g].calculateBreaksInPixels();
                            if (e && 0 < e.length) for (g = 0; g < e.length; g++) e[g].calculateStripLinesThicknessInValues(), 
                            e[g].calculateBreaksInPixels();
                        }
                    };
                    D.render = function(a, e, c, b, f) {
                        var h = a[0] ? a[0].chart : e[0].chart;
                        f = h.ctx;
                        h.alignVerticalAxes && h.alignVerticalAxes();
                        f.save();
                        f.beginPath();
                        a && a.length && f.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[a.length - 1].bounds.y2);
                        e && e.length && f.rect(5, e[e.length - 1].bounds.y1, e[0].chart.width - 10, e[0].bounds.y2);
                        f.clip();
                        if (a && 0 < a.length) for (var d = 0; d < a.length; d++) a[d].renderLabelsTicksAndTitle();
                        if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderLabelsTicksAndTitle();
                        f.restore();
                        if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderLabelsTicksAndTitle();
                        if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderLabelsTicksAndTitle();
                        h.preparePlotArea();
                        h = h.plotArea;
                        f.save();
                        f.beginPath();
                        f.rect(h.x1, h.y1, Math.abs(h.x2 - h.x1), Math.abs(h.y2 - h.y1));
                        f.clip();
                        if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderStripLinesOfThicknessType("value");
                        if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderStripLinesOfThicknessType("value");
                        if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderStripLinesOfThicknessType("value");
                        if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderStripLinesOfThicknessType("value");
                        if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderInterlacedColors();
                        if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderInterlacedColors();
                        if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderInterlacedColors();
                        if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderInterlacedColors();
                        f.restore();
                        if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderGrid(), v && (a[d].createMask(), 
                        a[d].renderBreaksBackground());
                        if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderGrid(), v && (e[d].createMask(), 
                        e[d].renderBreaksBackground());
                        if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderGrid(), v && (c[d].createMask(), 
                        c[d].renderBreaksBackground());
                        if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderGrid(), v && (b[d].createMask(), 
                        b[d].renderBreaksBackground());
                        if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderAxisLine();
                        if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderAxisLine();
                        if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderAxisLine();
                        if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderAxisLine();
                        if (a && 0 < a.length) for (d = 0; d < a.length; d++) a[d].renderStripLinesOfThicknessType("pixel");
                        if (e && 0 < e.length) for (d = 0; d < e.length; d++) e[d].renderStripLinesOfThicknessType("pixel");
                        if (c && 0 < c.length) for (d = 0; d < c.length; d++) c[d].renderStripLinesOfThicknessType("pixel");
                        if (b && 0 < b.length) for (d = 0; d < b.length; d++) b[d].renderStripLinesOfThicknessType("pixel");
                    };
                    D.prototype.calculateStripLinesThicknessInValues = function() {
                        for (var a = 0; a < this.stripLines.length; a++) if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {
                            var e = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue), c = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue), b = this.getApparentDifference(e, c);
                            this.stripLines[a].value = this.convertPixelToValue(Math.abs(this.convertValueToPixel(e) + this.convertValueToPixel(c)) / 2);
                            this.stripLines[a].thickness = b;
                            this.stripLines[a]._thicknessType = "value";
                        }
                    };
                    D.prototype.calculateBreaksSizeInValues = function() {
                        for (var f, a = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], c = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), b = this.scaleBreaks && !p(this.scaleBreaks.options.spacing), h = 0; h < e.length; h++) f = b || !p(e[h].options.spacing), 
                        e[h].spacing = Ua(e[h].spacing, a, 8, f ? .1 * a : 8, f ? 0 : 3) << 0, e[h].size = 0 > e[h].spacing ? 0 : Math.abs(e[h].spacing / c), 
                        this.logarithmic && (e[h].size = Math.pow(this.logarithmBase, e[h].size));
                    };
                    D.prototype.calculateBreaksInPixels = function() {
                        if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
                            var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
                            a.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);
                            for (var e = 0; e < a.length && !(a[e].startValue > this.conversionParameters.maximum); e++) a[e].endValue < this.conversionParameters.minimum || (p(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = e), 
                            a[e].startValue >= this.conversionParameters.minimum && (a[e].startPixel = this.convertValueToPixel(a[e].startValue), 
                            this.scaleBreaks.lastBreakIndex = e), a[e].endValue <= this.conversionParameters.maximum && (a[e].endPixel = this.convertValueToPixel(a[e].endValue)));
                        }
                    };
                    D.prototype.renderLabelsTicksAndTitle = function() {
                        var a = this, e = !1, c = 0, b = 0, f = 1, h = 0;
                        0 !== this.labelAngle && 360 !== this.labelAngle && (f = 1.2);
                        if ("undefined" === typeof this.options.interval) {
                            if ("bottom" === this._position || "top" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                                c = [], f = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2;
                                for (var d, l = this.viewportMaximum, p = this.lineCoordinates.width / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {
                                    q = this._labels[k];
                                    if (q.position < this.viewportMinimum) break;
                                    q.position > this.viewportMaximum || !(k === this._labels.length - 1 || d < Math.log(l / q.position) * p / f) || (c.push(q), 
                                    l = q.position, d = q.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                                }
                                this._labels = c;
                            } else {
                                for (k = 0; k < this._labels.length; k++) q = this._labels[k], q.position < this.viewportMinimum || (d = q.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), 
                                c += d);
                                c > this.lineCoordinates.width * f && this.labelAutoFit && (e = !0);
                            }
                            if ("left" === this._position || "right" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                                var m;
                                for (c = [], l = this.viewportMaximum, p = this.lineCoordinates.height / Math.log(this.range), 
                                k = this._labels.length - 1; 0 <= k; k--) {
                                    q = this._labels[k];
                                    if (q.position < this.viewportMinimum) break;
                                    q.position > this.viewportMaximum || !(k === this._labels.length - 1 || m < Math.log(l / q.position) * p) || (c.push(q), 
                                    l = q.position, m = q.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                                }
                                this._labels = c;
                            } else {
                                for (k = 0; k < this._labels.length; k++) q = this._labels[k], q.position < this.viewportMinimum || (m = q.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + q.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), 
                                b += m);
                                b > this.lineCoordinates.height * f && this.labelAutoFit && (e = !0);
                            }
                        }
                        this.logarithmic && !this.equidistantInterval && this.labelAutoFit && this._labels.sort((function(a, b) {
                            return a.position - b.position;
                        }));
                        var q, n;
                        k = 0;
                        if ("bottom" === this._position) {
                            for (k = 0; k < this._labels.length; k++) q = this._labels[k], q.position < this.viewportMinimum || q.position > this.viewportMaximum || (n = this.getPixelCoordinatesOnAxis(q.position), 
                            this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, 
                            this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + .5 : n.x << 0, 
                            this.ctx.beginPath(), this.ctx.moveTo(b, n.y << 0), this.ctx.lineTo(b, n.y + this.tickLength << 0), 
                            this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === q.textBlock.angle ? (n.x -= q.textBlock.width / 2, 
                            n.y = "inside" === this.labelPlacement ? n.y - (("inside" === this.tickPlacement ? this.tickLength : 0) + q.textBlock.height - q.textBlock.fontSize / 2) : n.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + q.textBlock.fontSize / 2 + 5) : (n.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? n.x : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x - (0 > this.labelAngle ? q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), 
                            n.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? n.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : n.y - ("inside" === this.tickPlacement ? this.tickLength : 0) - Math.abs(q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : n.y + ("inside" === this.tickPlacement ? 0 : this.tickLength) + Math.abs(0 > this.labelAngle ? q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), 
                            q.textBlock.x = n.x, q.textBlock.y = n.y));
                            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function() {
                                for (k = 0; k < a._labels.length; k++) if (q = a._labels[k], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum) && (n = a.getPixelCoordinatesOnAxis(q.position), 
                                a.tickThickness)) {
                                    a.ctx.lineWidth = a.tickThickness;
                                    a.ctx.strokeStyle = a.tickColor;
                                    var b = 1 === a.ctx.lineWidth % 2 ? (n.x << 0) + .5 : n.x << 0;
                                    a.ctx.save();
                                    a.ctx.beginPath();
                                    a.ctx.moveTo(b, n.y << 0);
                                    a.ctx.lineTo(b, n.y - a.tickLength << 0);
                                    a.ctx.stroke();
                                    a.ctx.restore();
                                }
                            }), this);
                            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, 
                            this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height + this._titleTextBlock.fontSize / 2 - 1, 
                            this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));
                        } else if ("top" === this._position) {
                            for (k = 0; k < this._labels.length; k++) q = this._labels[k], q.position < this.viewportMinimum || q.position > this.viewportMaximum || (n = this.getPixelCoordinatesOnAxis(q.position), 
                            this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, 
                            this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + .5 : n.x << 0, 
                            this.ctx.beginPath(), this.ctx.moveTo(b, n.y << 0), this.ctx.lineTo(b, n.y - this.tickLength << 0), 
                            this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === q.textBlock.angle ? (n.x -= q.textBlock.width / 2, 
                            n.y = "inside" === this.labelPlacement ? n.y + this.labelFontSize / 2 + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : n.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + q.textBlock.height - q.textBlock.fontSize / 2)) : (n.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? n.x : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x + (q.textBlock.height - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), 
                            n.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ? n.y + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : n.y - (("inside" === this.tickPlacement ? 0 : this.tickLength) + ((q.textBlock.height - q.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), 
                            q.textBlock.x = n.x, q.textBlock.y = n.y));
                            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function() {
                                for (k = 0; k < a._labels.length; k++) if (q = a._labels[k], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum) && (n = a.getPixelCoordinatesOnAxis(q.position), 
                                a.tickThickness)) {
                                    a.ctx.lineWidth = a.tickThickness;
                                    a.ctx.strokeStyle = a.tickColor;
                                    var b = 1 === a.ctx.lineWidth % 2 ? (n.x << 0) + .5 : n.x << 0;
                                    a.ctx.save();
                                    a.ctx.beginPath();
                                    a.ctx.moveTo(b, n.y << 0);
                                    a.ctx.lineTo(b, n.y + a.tickLength << 0);
                                    a.ctx.stroke();
                                    a.ctx.restore();
                                }
                            }), this);
                            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, 
                            this._titleTextBlock.y = this.bounds.y1 + this._titleTextBlock.fontSize / 2 + 1, 
                            this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));
                        } else if ("left" === this._position) {
                            for (k = 0; k < this._labels.length; k++) q = this._labels[k], q.position < this.viewportMinimum || q.position > this.viewportMaximum || (n = this.getPixelCoordinatesOnAxis(q.position), 
                            this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, 
                            this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + .5 : n.y << 0, 
                            this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, b), this.ctx.lineTo(n.x - this.tickLength << 0, b), 
                            this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (q.textBlock.y = n.y, 
                            q.textBlock.x = "inside" === this.labelPlacement ? n.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5) : (q.textBlock.y = "inside" === this.labelPlacement ? n.y : n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), 
                            q.textBlock.x = "inside" === this.labelPlacement ? n.x + ("inside" === this.tickPlacement ? this.tickLength : 0) + 5 : 0 < this.labelAngle ? n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength) - 5 : n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? 0 : this.tickLength))));
                            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function() {
                                for (k = 0; k < a._labels.length; k++) if (q = a._labels[k], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum) && (n = a.getPixelCoordinatesOnAxis(q.position), 
                                a.tickThickness)) {
                                    a.ctx.lineWidth = a.tickThickness;
                                    a.ctx.strokeStyle = a.tickColor;
                                    var b = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + .5 : n.y << 0;
                                    a.ctx.save();
                                    a.ctx.beginPath();
                                    a.ctx.moveTo(n.x << 0, b);
                                    a.ctx.lineTo(n.x + a.tickLength << 0, b);
                                    a.ctx.stroke();
                                    a.ctx.restore();
                                }
                            }), this);
                            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + this._titleTextBlock.fontSize / 2 + 1, 
                            this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, 
                            this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));
                        } else if ("right" === this._position) {
                            for (k = 0; k < this._labels.length; k++) q = this._labels[k], q.position < this.viewportMinimum || q.position > this.viewportMaximum || (n = this.getPixelCoordinatesOnAxis(q.position), 
                            this.tickThickness && "inside" != this.tickPlacement && (this.ctx.lineWidth = this.tickThickness, 
                            this.ctx.strokeStyle = this.tickColor, b = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + .5 : n.y << 0, 
                            this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, b), this.ctx.lineTo(n.x + this.tickLength << 0, b), 
                            this.ctx.stroke()), e && 0 !== h++ % 2 && this.labelAutoFit || (0 === this.labelAngle ? (q.textBlock.y = n.y, 
                            q.textBlock.x = "inside" === this.labelPlacement ? n.x - q.textBlock.width - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : n.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5) : (q.textBlock.y = "inside" === this.labelPlacement ? n.y - q.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? n.y : n.y - (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), 
                            q.textBlock.x = "inside" === this.labelPlacement ? n.x - q.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - ("inside" === this.tickPlacement ? this.tickLength : 0) - 5 : 0 < this.labelAngle ? n.x + (q.textBlock.height - q.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + ("inside" === this.tickPlacement ? 0 : this.tickLength) : n.x + ("inside" === this.tickPlacement ? 0 : this.tickLength) + 5)));
                            "inside" === this.tickPlacement && this.chart.addEventListener("dataAnimationIterationEnd", (function() {
                                for (k = 0; k < a._labels.length; k++) if (q = a._labels[k], !(q.position < a.viewportMinimum || q.position > a.viewportMaximum) && (n = a.getPixelCoordinatesOnAxis(q.position), 
                                a.tickThickness)) {
                                    a.ctx.lineWidth = a.tickThickness;
                                    a.ctx.strokeStyle = a.tickColor;
                                    var b = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + .5 : n.y << 0;
                                    a.ctx.save();
                                    a.ctx.beginPath();
                                    a.ctx.moveTo(n.x << 0, b);
                                    a.ctx.lineTo(n.x - a.tickLength << 0, b);
                                    a.ctx.stroke();
                                    a.ctx.restore();
                                }
                            }), this);
                            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - this._titleTextBlock.fontSize / 2 - 1, 
                            this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, 
                            this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0));
                        }
                        h = 0;
                        if ("inside" === this.labelPlacement) this.chart.addEventListener("dataAnimationIterationEnd", (function() {
                            for (k = 0; k < a._labels.length; k++) q = a._labels[k], q.position < a.viewportMinimum || q.position > a.viewportMaximum || e && 0 !== h++ % 2 && a.labelAutoFit || (a.ctx.save(), 
                            a.ctx.beginPath(), q.textBlock.render(!0), a.ctx.restore());
                        }), this); else for (k = 0; k < this._labels.length; k++) q = this._labels[k], q.position < this.viewportMinimum || q.position > this.viewportMaximum || e && 0 !== h++ % 2 && this.labelAutoFit || q.textBlock.render(!0);
                    };
                    D.prototype.renderInterlacedColors = function() {
                        var e, c, a = this.chart.plotArea.ctx, b = this.chart.plotArea, f = 0;
                        e = !0;
                        if (("bottom" === this._position || "top" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, 
                        f = 0; f < this._labels.length; f++) e ? (e = this.getPixelCoordinatesOnAxis(this._labels[f].position), 
                        c = f + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[f + 1].position), 
                        a.fillRect(Math.min(c.x, e.x), b.y1, Math.abs(c.x - e.x), Math.abs(b.y1 - b.y2)), 
                        e = !1) : e = !0; else if (("left" === this._position || "right" === this._position) && this.interlacedColor) for (a.fillStyle = this.interlacedColor, 
                        f = 0; f < this._labels.length; f++) e ? (c = this.getPixelCoordinatesOnAxis(this._labels[f].position), 
                        e = f + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[f + 1].position), 
                        a.fillRect(b.x1, Math.min(c.y, e.y), Math.abs(b.x1 - b.x2), Math.abs(e.y - c.y)), 
                        e = !1) : e = !0;
                        a.beginPath();
                    };
                    D.prototype.renderStripLinesOfThicknessType = function(a) {
                        if (this.stripLines && 0 < this.stripLines.length && a) {
                            var c, b, e = this, f = 0, h = 0, d = !1;
                            b = !1;
                            var l = [], t = [], k = !1;
                            for (f = 0; f < this.stripLines.length; f++) {
                                var m = this.stripLines[f];
                                m._thicknessType === a && ("pixel" === a && (m.value < this.viewportMinimum || m.value > this.viewportMaximum || p(m.value) || isNaN(this.range)) || "value" === a && (m.startValue <= this.viewportMinimum && m.endValue <= this.viewportMinimum || m.startValue >= this.viewportMaximum && m.endValue >= this.viewportMaximum || p(m.startValue) || p(m.endValue) || isNaN(this.range)) || l.push(m));
                            }
                            for (f = 0; f < this._stripLineLabels.length; f++) if (m = this.stripLines[f], c = this._stripLineLabels[f], 
                            !(c.position < this.viewportMinimum || c.position > this.viewportMaximum || isNaN(this.range))) if (b = this.getPixelCoordinatesOnAxis(c.position), 
                            "outside" === c.stripLine.labelPlacement) {
                                m && (this.ctx.strokeStyle = m.color, this.ctx.lineWidth = "pixel" === m._thicknessType ? m.thickness : this.tickThickness);
                                if ("bottom" === this._position) {
                                    var q = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + .5 : b.x << 0;
                                    this.ctx.beginPath();
                                    this.ctx.moveTo(q, b.y << 0);
                                    this.ctx.lineTo(q, b.y + this.tickLength << 0);
                                    this.ctx.stroke();
                                    0 === this.labelAngle ? (b.x -= c.textBlock.width / 2, b.y += this.tickLength + c.textBlock.fontSize / 2 + 5) : (b.x -= 0 > this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, 
                                    b.y += this.tickLength + Math.abs(0 > this.labelAngle ? c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5));
                                } else "top" === this._position ? (q = 1 === this.ctx.lineWidth % 2 ? (b.x << 0) + .5 : b.x << 0, 
                                this.ctx.beginPath(), this.ctx.moveTo(q, b.y << 0), this.ctx.lineTo(q, b.y - this.tickLength << 0), 
                                this.ctx.stroke(), 0 === this.labelAngle ? (b.x -= c.textBlock.width / 2, b.y -= this.tickLength + c.textBlock.height - c.textBlock.fontSize / 2) : (b.x += (c.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), 
                                b.y -= this.tickLength + (c.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (q = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + .5 : b.y << 0, 
                                this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, q), this.ctx.lineTo(b.x - this.tickLength << 0, q), 
                                this.ctx.stroke(), 0 === this.labelAngle ? b.x = b.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (b.y -= c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), 
                                b.x = 0 < this.labelAngle ? b.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : b.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (c.textBlock.height - c.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (q = 1 === this.ctx.lineWidth % 2 ? (b.y << 0) + .5 : b.y << 0, 
                                this.ctx.beginPath(), this.ctx.moveTo(b.x << 0, q), this.ctx.lineTo(b.x + this.tickLength << 0, q), 
                                this.ctx.stroke(), 0 === this.labelAngle ? b.x = b.x + this.tickLength + 5 : (b.y = 0 > this.labelAngle ? b.y : b.y - (c.textBlock.height - c.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), 
                                b.x = 0 < this.labelAngle ? b.x + (c.textBlock.height - c.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : b.x + this.tickLength + 5));
                                c.textBlock.x = b.x;
                                c.textBlock.y = b.y;
                                t.push(c);
                            } else m._thicknessType === a && (c.textBlock.angle = -90, "bottom" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.height - 3, 
                            c.textBlock.measureText(), b.x - c.textBlock.height - m.thickness / 2 > this.chart.plotArea.x1 ? p(m.startValue) ? b.x -= c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : (c.textBlock.angle = 90, 
                            p(m.startValue) ? b.x += c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2), 
                            b.y = -90 === c.textBlock.angle ? "near" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y1 + c.textBlock.width + 3 : "near" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - c.textBlock.width - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.height - 3, 
                            c.textBlock.measureText(), b.x - c.textBlock.height - m.thickness / 2 > this.chart.plotArea.x1 ? p(m.startValue) ? b.x -= c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : (c.textBlock.angle = 90, 
                            p(m.startValue) ? b.x += c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2), 
                            b.y = -90 === c.textBlock.angle ? "near" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + c.textBlock.width + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y2 - c.textBlock.width - 3) : "left" === this._position ? (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.width - 3, 
                            c.textBlock.angle = 0, c.textBlock.measureText(), b.y - c.textBlock.height - m.thickness / 2 > this.chart.plotArea.y1 ? p(m.startValue) ? b.y -= c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : p(m.startValue) ? b.y += c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.y += c.textBlock.height / 2 - c.textBlock.fontSize + 3, 
                            b.x = "near" === c.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x2 - c.textBlock.width - 3) : "right" === this._position && (c.textBlock.maxWidth = this.options.stripLines[f].labelMaxWidth ? this.options.stripLines[f].labelMaxWidth : this.chart.plotArea.width - 3, 
                            c.textBlock.angle = 0, c.textBlock.measureText(), b.y - c.textBlock.height - m.thickness / 2 > this.chart.plotArea.y1 ? p(m.startValue) ? b.y -= c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 : p(m.startValue) ? b.y += c.textBlock.height - c.textBlock.fontSize / 2 + m.thickness / 2 : b.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3, 
                            b.x = "near" === c.stripLine.labelAlign ? this.chart.plotArea.x2 - c.textBlock.width - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x1 + 3), 
                            c.textBlock.x = b.x, c.textBlock.y = b.y, t.push(c));
                            if (!k) {
                                b = !1;
                                this.ctx.save();
                                this.ctx.beginPath();
                                this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                                this.ctx.clip();
                                for (f = 0; f < l.length; f++) m = l[f], m.showOnTop ? d || (d = !0, this.chart.addEventListener("dataAnimationIterationEnd", (function() {
                                    this.ctx.save();
                                    this.ctx.beginPath();
                                    this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                                    this.ctx.clip();
                                    for (h = 0; h < l.length; h++) m = l[h], m.showOnTop && m.render();
                                    this.ctx.restore();
                                }), m)) : m.render();
                                for (f = 0; f < t.length; f++) c = t[f], c.stripLine.showOnTop ? b || (b = !0, this.chart.addEventListener("dataAnimationIterationEnd", (function() {
                                    for (h = 0; h < t.length; h++) c = t[h], "inside" === c.stripLine.labelPlacement && c.stripLine.showOnTop && (e.ctx.save(), 
                                    e.ctx.beginPath(), e.ctx.rect(e.chart.plotArea.x1, e.chart.plotArea.y1, e.chart.plotArea.width, e.chart.plotArea.height), 
                                    e.ctx.clip(), c.textBlock.render(!0), e.ctx.restore());
                                }), c.textBlock)) : "inside" === c.stripLine.labelPlacement && c.textBlock.render(!0);
                                this.ctx.restore();
                                k = !0;
                            }
                            if (k) for (b = !1, f = 0; f < t.length; f++) c = t[f], "outside" === c.stripLine.labelPlacement && c.textBlock.render(!0);
                        }
                    };
                    D.prototype.renderBreaksBackground = function() {
                        this.chart._breaksCanvas && this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas && (this.chart._breaksCanvasCtx.save(), 
                        this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), 
                        this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), 
                        this.chart._breaksCanvasCtx.restore());
                    };
                    D.prototype.createMask = function() {
                        if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
                            var a = this.scaleBreaks._appliedBreaks;
                            v ? (this.maskCanvas = wa(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, 
                            this.maskCtx = this.chart.plotArea.ctx);
                            this.maskCtx.save();
                            this.maskCtx.beginPath();
                            this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                            this.maskCtx.clip();
                            for (var e = 0; e < a.length; e++) a[e].endValue < this.viewportMinimum || a[e].startValue > this.viewportMaximum || isNaN(this.range) || a[e].render(this.maskCtx);
                            this.maskCtx.restore();
                        }
                    };
                    D.prototype.renderCrosshair = function(a, e) {
                        isFinite(this.minimum) && isFinite(this.maximum) && this.crosshair.render(a, e);
                    };
                    D.prototype.showCrosshair = function(a) {
                        p(a) || a < this.viewportMinimum || a > this.viewportMaximum || ("top" === this._position || "bottom" === this._position ? this.crosshair.render(this.convertValueToPixel(a), null, a) : this.crosshair.render(null, this.convertValueToPixel(a), a));
                    };
                    D.prototype.renderGrid = function() {
                        if (this.gridThickness && 0 < this.gridThickness) {
                            var a = this.chart.ctx;
                            a.save();
                            var e, c = this.chart.plotArea;
                            a.lineWidth = this.gridThickness;
                            a.strokeStyle = this.gridColor;
                            a.setLineDash && a.setLineDash(H(this.gridDashType, this.gridThickness));
                            if ("bottom" === this._position || "top" === this._position) for (b = 0; b < this._labels.length; b++) this._labels[b].position < this.viewportMinimum || this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType || (a.beginPath(), 
                            e = this.getPixelCoordinatesOnAxis(this._labels[b].position), e = 1 === a.lineWidth % 2 ? (e.x << 0) + .5 : e.x << 0, 
                            a.moveTo(e, c.y1 << 0), a.lineTo(e, c.y2 << 0), a.stroke()); else if ("left" === this._position || "right" === this._position) for (var b = 0; b < this._labels.length; b++) this._labels[b].position < this.viewportMinimum || this._labels[b].position > this.viewportMaximum || this._labels[b].breaksLabelType || (a.beginPath(), 
                            e = this.getPixelCoordinatesOnAxis(this._labels[b].position), e = 1 === a.lineWidth % 2 ? (e.y << 0) + .5 : e.y << 0, 
                            a.moveTo(c.x1 << 0, e), a.lineTo(c.x2 << 0, e), a.stroke());
                            a.restore();
                        }
                    };
                    D.prototype.renderAxisLine = function() {
                        var f, h, a = this.chart.ctx, e = v ? this.chart._preRenderCtx : a, c = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)), b = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2));
                        e.save();
                        if ("bottom" === this._position || "top" === this._position) {
                            if (this.lineThickness) {
                                this.reversed ? (f = this.lineCoordinates.x2, h = this.lineCoordinates.x1) : (f = this.lineCoordinates.x1, 
                                h = this.lineCoordinates.x2);
                                e.lineWidth = this.lineThickness;
                                e.strokeStyle = this.lineColor ? this.lineColor : "black";
                                e.setLineDash && e.setLineDash(H(this.lineDashType, this.lineThickness));
                                var d = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + .5 : this.lineCoordinates.y1 << 0;
                                e.beginPath();
                                if (this.scaleBreaks && !p(this.scaleBreaks.firstBreakIndex)) if (p(this.scaleBreaks.lastBreakIndex)) f = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b; else for (var l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++) e.moveTo(f, d), 
                                e.lineTo(this.scaleBreaks._appliedBreaks[l].startPixel + c, d), f = this.scaleBreaks._appliedBreaks[l].endPixel + b;
                                f && (e.moveTo(f, d), e.lineTo(h, d));
                                e.stroke();
                            }
                        } else if (("left" === this._position || "right" === this._position) && this.lineThickness) {
                            this.reversed ? (f = this.lineCoordinates.y1, h = this.lineCoordinates.y2) : (f = this.lineCoordinates.y2, 
                            h = this.lineCoordinates.y1);
                            e.lineWidth = this.lineThickness;
                            e.strokeStyle = this.lineColor;
                            e.setLineDash && e.setLineDash(H(this.lineDashType, this.lineThickness));
                            d = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + .5 : this.lineCoordinates.x1 << 0;
                            e.beginPath();
                            if (this.scaleBreaks && !p(this.scaleBreaks.firstBreakIndex)) if (p(this.scaleBreaks.lastBreakIndex)) f = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c; else for (l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++) e.moveTo(d, f), 
                            e.lineTo(d, this.scaleBreaks._appliedBreaks[l].startPixel + b), f = this.scaleBreaks._appliedBreaks[l].endPixel + c;
                            f && (e.moveTo(d, f), e.lineTo(d, h));
                            e.stroke();
                        }
                        v && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), 
                        this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), 
                        e.clearRect(0, 0, this.chart.width, this.chart.height));
                        e.restore();
                    };
                    D.prototype.getPixelCoordinatesOnAxis = function(a) {
                        var e = {};
                        if ("bottom" === this._position || "top" === this._position) e.x = this.convertValueToPixel(a), 
                        e.y = this.lineCoordinates.y1;
                        if ("left" === this._position || "right" === this._position) e.y = this.convertValueToPixel(a), 
                        e.x = this.lineCoordinates.x2;
                        return e;
                    };
                    D.prototype.convertPixelToValue = function(a) {
                        if ("undefined" === typeof a) return null;
                        var b, e = 0, c = 0, f = (e = !0, this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []);
                        c = "number" === typeof a ? a : "left" === this._position || "right" === this._position ? a.y : a.x;
                        if (this.logarithmic) {
                            a = b = Math.pow(this.logarithmBase, (c - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);
                            if (c <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) {
                                for (c = 0; c < f.length; c++) if (!(f[c].endValue < this.conversionParameters.minimum)) if (e) if (f[c].startValue < this.conversionParameters.minimum) {
                                    if (1 < f[c].size && this.conversionParameters.minimum * Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size)) < f[c].endValue) {
                                        a = Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size));
                                        break;
                                    } else a *= f[c].endValue / this.conversionParameters.minimum / Math.pow(f[c].size, Math.log(f[c].endValue / this.conversionParameters.minimum) / Math.log(f[c].endValue / f[c].startValue)), 
                                    b /= Math.pow(f[c].size, Math.log(f[c].endValue / this.conversionParameters.minimum) / Math.log(f[c].endValue / f[c].startValue));
                                    e = !1;
                                } else if (b > f[c].startValue / this.conversionParameters.minimum) {
                                    b /= f[c].startValue / this.conversionParameters.minimum;
                                    if (b < f[c].size) {
                                        a *= Math.pow(f[c].endValue / f[c].startValue, 1 === f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) / b;
                                        break;
                                    } else a *= f[c].endValue / f[c].startValue / f[c].size;
                                    b /= f[c].size;
                                    e = !1;
                                } else break; else if (b > f[c].startValue / f[c - 1].endValue) {
                                    b /= f[c].startValue / f[c - 1].endValue;
                                    if (b < f[c].size) {
                                        a *= Math.pow(f[c].endValue / f[c].startValue, 1 === f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) / b;
                                        break;
                                    } else a *= f[c].endValue / f[c].startValue / f[c].size;
                                    b /= f[c].size;
                                } else break;
                            } else for (c = f.length - 1; 0 <= c; c--) if (!(f[c].startValue > this.conversionParameters.minimum)) if (e) if (f[c].endValue > this.conversionParameters.minimum) {
                                if (1 < f[c].size && this.conversionParameters.minimum * Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size)) > f[c].startValue) {
                                    a = Math.pow(f[c].endValue / f[c].startValue, Math.log(b) / Math.log(f[c].size));
                                    break;
                                } else a *= f[c].startValue / this.conversionParameters.minimum * Math.pow(f[c].size, Math.log(f[c].startValue / this.conversionParameters.minimum) / Math.log(f[c].endValue / f[c].startValue)) * b, 
                                b *= Math.pow(f[c].size, Math.log(this.conversionParameters.minimum / f[c].startValue) / Math.log(f[c].endValue / f[c].startValue));
                                e = !1;
                            } else if (b < f[c].endValue / this.conversionParameters.minimum) {
                                b /= f[c].endValue / this.conversionParameters.minimum;
                                if (b > 1 / f[c].size) {
                                    a *= Math.pow(f[c].endValue / f[c].startValue, 1 >= f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) * b;
                                    break;
                                } else a /= f[c].endValue / f[c].startValue / f[c].size;
                                b *= f[c].size;
                                e = !1;
                            } else break; else if (b < f[c].endValue / f[c + 1].startValue) {
                                b /= f[c].endValue / f[c + 1].startValue;
                                if (b > 1 / f[c].size) {
                                    a *= Math.pow(f[c].endValue / f[c].startValue, 1 >= f[c].size ? 1 : Math.log(b) / Math.log(f[c].size)) * b;
                                    break;
                                } else a /= f[c].endValue / f[c].startValue / f[c].size;
                                b *= f[c].size;
                            } else break;
                            e = a * this.viewportMinimum;
                        } else {
                            a = b = (c - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;
                            if (c <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed) {
                                for (c = 0; c < f.length; c++) if (!(f[c].endValue < this.conversionParameters.minimum)) if (e) if (f[c].startValue < this.conversionParameters.minimum) {
                                    if (f[c].size && this.conversionParameters.minimum + b * (f[c].endValue - f[c].startValue) / f[c].size < f[c].endValue) {
                                        a = 0 >= f[c].size ? 0 : b * (f[c].endValue - f[c].startValue) / f[c].size;
                                        break;
                                    } else a += f[c].endValue - this.conversionParameters.minimum - f[c].size * (f[c].endValue - this.conversionParameters.minimum) / (f[c].endValue - f[c].startValue), 
                                    b -= f[c].size * (f[c].endValue - this.conversionParameters.minimum) / (f[c].endValue - f[c].startValue);
                                    e = !1;
                                } else if (b > f[c].startValue - this.conversionParameters.minimum) {
                                    b -= f[c].startValue - this.conversionParameters.minimum;
                                    if (b < f[c].size) {
                                        a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) - b;
                                        break;
                                    } else a += f[c].endValue - f[c].startValue - f[c].size;
                                    b -= f[c].size;
                                    e = !1;
                                } else break; else if (b > f[c].startValue - f[c - 1].endValue) {
                                    b -= f[c].startValue - f[c - 1].endValue;
                                    if (b < f[c].size) {
                                        a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) - b;
                                        break;
                                    } else a += f[c].endValue - f[c].startValue - f[c].size;
                                    b -= f[c].size;
                                } else break;
                            } else for (c = f.length - 1; 0 <= c; c--) if (!(f[c].startValue > this.conversionParameters.minimum)) if (e) if (f[c].endValue > this.conversionParameters.minimum) if (f[c].size && this.conversionParameters.minimum + b * (f[c].endValue - f[c].startValue) / f[c].size > f[c].startValue) {
                                a = 0 >= f[c].size ? 0 : b * (f[c].endValue - f[c].startValue) / f[c].size;
                                break;
                            } else a += f[c].startValue - this.conversionParameters.minimum + f[c].size * (this.conversionParameters.minimum - f[c].startValue) / (f[c].endValue - f[c].startValue), 
                            b += f[c].size * (this.conversionParameters.minimum - f[c].startValue) / (f[c].endValue - f[c].startValue), 
                            e = !1; else if (b < f[c].endValue - this.conversionParameters.minimum) {
                                b -= f[c].endValue - this.conversionParameters.minimum;
                                if (b > -1 * f[c].size) {
                                    a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) + b;
                                    break;
                                } else a -= f[c].endValue - f[c].startValue - f[c].size;
                                b += f[c].size;
                                e = !1;
                            } else break; else if (b < f[c].endValue - f[c + 1].startValue) {
                                b -= f[c].endValue - f[c + 1].startValue;
                                if (b > -1 * f[c].size) {
                                    a += (f[c].endValue - f[c].startValue) * (0 === f[c].size ? 1 : b / f[c].size) + b;
                                    break;
                                } else a -= f[c].endValue - f[c].startValue - f[c].size;
                                b += f[c].size;
                            } else break;
                            e = this.conversionParameters.minimum + a;
                        }
                        return e;
                    };
                    D.prototype.convertValueToPixel = function(a) {
                        a = this.getApparentDifference(this.conversionParameters.minimum, a, a);
                        return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + .5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + .5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + .5;
                    };
                    D.prototype.getApparentDifference = function(a, e, c, b) {
                        var f = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
                        if (this.logarithmic) {
                            c = p(c) ? e / a : c;
                            for (var h = 0; h < f.length && !(e < f[h].startValue); h++) a > f[h].endValue || (a <= f[h].startValue && e >= f[h].endValue ? c = c / f[h].endValue * f[h].startValue * f[h].size : a >= f[h].startValue && e >= f[h].endValue ? c = c / f[h].endValue * a * Math.pow(f[h].size, Math.log(f[h].endValue / a) / Math.log(f[h].endValue / f[h].startValue)) : a <= f[h].startValue && e <= f[h].endValue ? c = c / e * f[h].startValue * Math.pow(f[h].size, Math.log(e / f[h].startValue) / Math.log(f[h].endValue / f[h].startValue)) : !b && a > f[h].startValue && e < f[h].endValue && (c = a * Math.pow(f[h].size, Math.log(e / a) / Math.log(f[h].endValue / f[h].startValue))));
                        } else for (c = p(c) ? Math.abs(e - a) : c, h = 0; h < f.length && !(e < f[h].startValue); h++) a > f[h].endValue || (a <= f[h].startValue && e >= f[h].endValue ? c = c - f[h].endValue + f[h].startValue + f[h].size : a > f[h].startValue && e >= f[h].endValue ? c = c - f[h].endValue + a + f[h].size * (f[h].endValue - a) / (f[h].endValue - f[h].startValue) : a <= f[h].startValue && e < f[h].endValue ? c = c - e + f[h].startValue + f[h].size * (e - f[h].startValue) / (f[h].endValue - f[h].startValue) : !b && a > f[h].startValue && e < f[h].endValue && (c = a + f[h].size * (e - a) / (f[h].endValue - f[h].startValue)));
                        return c;
                    };
                    D.prototype.setViewPortRange = function(a, e) {
                        this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, e);
                        this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, e);
                    };
                    D.prototype.getXValueAt = function(a) {
                        if (!a) return null;
                        var e = null;
                        "left" === this._position ? e = this.convertPixelToValue(a.y) : "bottom" === this._position && (e = this.convertPixelToValue(a.x));
                        return e;
                    };
                    D.prototype.calculateValueToPixelConversionParameters = function(a) {
                        a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
                        var e = {
                            pixelPerUnit: null,
                            minimum: null,
                            reference: null
                        }, c = this.lineCoordinates.width, b = this.lineCoordinates.height;
                        c = "bottom" === this._position || "top" === this._position ? c : b, b = Math.abs(this.range);
                        if (this.logarithmic) for (var f = 0; f < a.length && !(this.viewportMaximum < a[f].startValue); f++) this.viewportMinimum > a[f].endValue || (this.viewportMinimum >= a[f].startValue && this.viewportMaximum <= a[f].endValue ? c = 0 : this.viewportMinimum <= a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b / a[f].endValue * a[f].startValue, 
                        c = 0 < a[f].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[f].spacing) / 100) : c - Math.min(a[f].spacing, .1 * c)) : this.viewportMinimum > a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b / a[f].endValue * this.viewportMinimum, 
                        c = 0 < a[f].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[f].spacing) / 100 * Math.log(a[f].endValue / this.viewportMinimum) / Math.log(a[f].endValue / a[f].startValue)) : c - Math.min(a[f].spacing, .1 * c) * Math.log(a[f].endValue / this.viewportMinimum) / Math.log(a[f].endValue / a[f].startValue)) : this.viewportMinimum <= a[f].startValue && this.viewportMaximum < a[f].endValue && (b = b / this.viewportMaximum * a[f].startValue, 
                        c = 0 < a[f].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[f].spacing) / 100 * Math.log(this.viewportMaximum / a[f].startValue) / Math.log(a[f].endValue / a[f].startValue)) : c - Math.min(a[f].spacing, .1 * c) * Math.log(this.viewportMaximum / a[f].startValue) / Math.log(a[f].endValue / a[f].startValue))); else for (f = 0; f < a.length && !(this.viewportMaximum < a[f].startValue); f++) this.viewportMinimum > a[f].endValue || (this.viewportMinimum >= a[f].startValue && this.viewportMaximum <= a[f].endValue ? c = 0 : this.viewportMinimum <= a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b - a[f].endValue + a[f].startValue, 
                        c = 0 < a[f].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[f].spacing) / 100) : c - Math.min(a[f].spacing, .1 * c)) : this.viewportMinimum > a[f].startValue && this.viewportMaximum >= a[f].endValue ? (b = b - a[f].endValue + this.viewportMinimum, 
                        c = 0 < a[f].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[f].spacing) / 100 * (a[f].endValue - this.viewportMinimum) / (a[f].endValue - a[f].startValue)) : c - Math.min(a[f].spacing, .1 * c) * (a[f].endValue - this.viewportMinimum) / (a[f].endValue - a[f].startValue)) : this.viewportMinimum <= a[f].startValue && this.viewportMaximum < a[f].endValue && (b = b - this.viewportMaximum + a[f].startValue, 
                        c = 0 < a[f].spacing.toString().indexOf("%") ? c * (1 - parseFloat(a[f].spacing) / 100 * (this.viewportMaximum - a[f].startValue) / (a[f].endValue - a[f].startValue)) : c - Math.min(a[f].spacing, .1 * c) * (this.viewportMaximum - a[f].startValue) / (a[f].endValue - a[f].startValue)));
                        e.minimum = this.viewportMinimum;
                        e.maximum = this.viewportMaximum;
                        e.range = b;
                        if ("bottom" === this._position || "top" === this._position) this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), 
                        e.pixelPerUnit = (this.reversed ? -1 : 1) * c * e.lnLogarithmBase / Math.log(Math.abs(b))) : e.pixelPerUnit = (this.reversed ? -1 : 1) * c / Math.abs(b), 
                        e.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;
                        if ("left" === this._position || "right" === this._position) this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), 
                        e.pixelPerUnit = (this.reversed ? 1 : -1) * c * e.lnLogarithmBase / Math.log(Math.abs(b))) : e.pixelPerUnit = (this.reversed ? 1 : -1) * c / Math.abs(b), 
                        e.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;
                        this.conversionParameters = e;
                    };
                    D.prototype.calculateAxisParameters = function() {
                        if (this.logarithmic) this.calculateLogarithmicAxisParameters(); else {
                            var a = this.chart.layoutManager.getFreeSpace(), e = !1, c = !1;
                            "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, 
                            this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
                            a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40;
                            var b = 4;
                            "axisX" === this.type && (b = 600 > this.maxWidth ? 8 : 6);
                            var f, h, d;
                            a = Math.max(b, Math.floor(this.maxWidth / a)), b = 0;
                            !p(this.options.viewportMinimum) && !p(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum && (this.viewportMinimum = this.viewportMaximum = null);
                            if (p(this.options.viewportMinimum) && !p(this.sessionVariables.newViewportMinimum) && !isNaN(this.sessionVariables.newViewportMinimum)) this.viewportMinimum = this.sessionVariables.newViewportMinimum; else if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;
                            if (p(this.options.viewportMaximum) && !p(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum)) this.viewportMaximum = this.sessionVariables.newViewportMaximum; else if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;
                            if (this.scaleBreaks) for (b = 0; b < this.scaleBreaks._appliedBreaks.length; b++) if ((!p(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue || !p(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[b].startValue || !p(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[b].startValue) && (!p(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue || !p(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[b].endValue || !p(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[b].endValue)) {
                                this.scaleBreaks._appliedBreaks.splice(b, 1);
                                break;
                            }
                            if ("axisX" === this.type) {
                                if (this.dataSeries && 0 < this.dataSeries.length) for (f = 0; f < this.dataSeries.length; f++) "dateTime" === this.dataSeries[f].xValueType && (c = !0);
                                f = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;
                                h = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax;
                                0 === h - f && (b = "undefined" === typeof this.options.interval ? .4 : this.options.interval, 
                                h += b, f -= b);
                                1 / 0 !== this.dataInfo.minDiff ? d = this.dataInfo.minDiff : 1 < h - f ? d = .5 * Math.abs(h - f) : (d = 1, 
                                c && (e = !0));
                            } else "axisY" === this.type && (f = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, 
                            h = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 
                            isFinite(f) || isFinite(h) ? isFinite(f) ? isFinite(h) || (h = f) : f = h : (h = "undefined" === typeof this.options.interval ? -1 / 0 : this.options.interval, 
                            f = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : 1 / 0), 
                            0 === f && 0 === h ? (h += 9, f = 0) : 0 === h - f ? (b = Math.min(Math.abs(.01 * Math.abs(h)), 5), 
                            h += b, f -= b) : f > h ? (b = Math.min(.01 * Math.abs(this.getApparentDifference(h, f, null, !0)), 5), 
                            0 <= h ? f = h - b : h = isFinite(f) ? f + b : 0) : (b = Math.min(.01 * Math.abs(this.getApparentDifference(f, h, null, !0)), .05), 
                            0 !== h && (h += b), 0 !== f && (f -= b)), d = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < h - f ? .5 * Math.abs(h - f) : 1, 
                            this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < f && (f = 0), 
                            this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > h && (h = 0));
                            b = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? f : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? h : this.viewportMaximum, null, !0);
                            if ("axisX" === this.type && c) {
                                this.valueType = "dateTime";
                                this.intervalType || (b / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : b / 2 <= a ? (this.interval = 2, 
                                this.intervalType = "millisecond") : b / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : b / 10 <= a ? (this.interval = 10, 
                                this.intervalType = "millisecond") : b / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : b / 50 <= a ? (this.interval = 50, 
                                this.intervalType = "millisecond") : b / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : b / 200 <= a ? (this.interval = 200, 
                                this.intervalType = "millisecond") : b / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : b / 300 <= a ? (this.interval = 300, 
                                this.intervalType = "millisecond") : b / 400 <= a ? (this.interval = 400, this.intervalType = "millisecond") : b / 500 <= a ? (this.interval = 500, 
                                this.intervalType = "millisecond") : b / (1 * U.secondDuration) <= a ? (this.interval = 1, 
                                this.intervalType = "second") : b / (2 * U.secondDuration) <= a ? (this.interval = 2, 
                                this.intervalType = "second") : b / (5 * U.secondDuration) <= a ? (this.interval = 5, 
                                this.intervalType = "second") : b / (10 * U.secondDuration) <= a ? (this.interval = 10, 
                                this.intervalType = "second") : b / (15 * U.secondDuration) <= a ? (this.interval = 15, 
                                this.intervalType = "second") : b / (20 * U.secondDuration) <= a ? (this.interval = 20, 
                                this.intervalType = "second") : b / (30 * U.secondDuration) <= a ? (this.interval = 30, 
                                this.intervalType = "second") : b / (1 * U.minuteDuration) <= a ? (this.interval = 1, 
                                this.intervalType = "minute") : b / (2 * U.minuteDuration) <= a ? (this.interval = 2, 
                                this.intervalType = "minute") : b / (5 * U.minuteDuration) <= a ? (this.interval = 5, 
                                this.intervalType = "minute") : b / (10 * U.minuteDuration) <= a ? (this.interval = 10, 
                                this.intervalType = "minute") : b / (15 * U.minuteDuration) <= a ? (this.interval = 15, 
                                this.intervalType = "minute") : b / (20 * U.minuteDuration) <= a ? (this.interval = 20, 
                                this.intervalType = "minute") : b / (30 * U.minuteDuration) <= a ? (this.interval = 30, 
                                this.intervalType = "minute") : b / (1 * U.hourDuration) <= a ? (this.interval = 1, 
                                this.intervalType = "hour") : b / (2 * U.hourDuration) <= a ? (this.interval = 2, 
                                this.intervalType = "hour") : b / (3 * U.hourDuration) <= a ? (this.interval = 3, 
                                this.intervalType = "hour") : b / (6 * U.hourDuration) <= a ? (this.interval = 6, 
                                this.intervalType = "hour") : b / (1 * U.dayDuration) <= a ? (this.interval = 1, 
                                this.intervalType = "day") : b / (2 * U.dayDuration) <= a ? (this.interval = 2, 
                                this.intervalType = "day") : b / (4 * U.dayDuration) <= a ? (this.interval = 4, 
                                this.intervalType = "day") : b / (1 * U.weekDuration) <= a ? (this.interval = 1, 
                                this.intervalType = "week") : b / (2 * U.weekDuration) <= a ? (this.interval = 2, 
                                this.intervalType = "week") : b / (3 * U.weekDuration) <= a ? (this.interval = 3, 
                                this.intervalType = "week") : b / (1 * U.monthDuration) <= a ? (this.interval = 1, 
                                this.intervalType = "month") : b / (2 * U.monthDuration) <= a ? (this.interval = 2, 
                                this.intervalType = "month") : b / (3 * U.monthDuration) <= a ? (this.interval = 3, 
                                this.intervalType = "month") : b / (6 * U.monthDuration) <= a ? (this.interval = 6, 
                                this.intervalType = "month") : (this.interval = b / (1 * U.yearDuration) <= a ? 1 : b / (2 * U.yearDuration) <= a ? 2 : b / (4 * U.yearDuration) <= a ? 4 : Math.floor(D.getNiceNumber(b / (a - 1), !0) / U.yearDuration), 
                                this.intervalType = "year"));
                                if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = f - d / 2;
                                if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = h + d / 2;
                                e ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'");
                                this.valueFormatString || (this.valueFormatString = this.autoValueFormatString);
                            } else {
                                this.intervalType = "number";
                                b = D.getNiceNumber(b, !1);
                                this.interval = this.options && 0 < this.options.interval ? this.options.interval : D.getNiceNumber(b / (a - 1), !0);
                                if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? f - d / 2 : Math.floor(f / this.interval) * this.interval;
                                if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = "axisX" === this.type ? h + d / 2 : Math.ceil(h / this.interval) * this.interval;
                                0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), 
                                this.options && "undefined" === typeof this.options.interval && (this.interval = D.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));
                            }
                            if (null === this.minimum || null === this.maximum) if ("axisX" === this.type ? (f = null !== this.minimum ? this.minimum : this.dataInfo.min, 
                            h = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === h - f && (b = "undefined" === typeof this.options.interval ? .4 : this.options.interval, 
                            h += b, f -= b), d = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < h - f ? .5 * Math.abs(h - f) : 1) : "axisY" === this.type && (f = null !== this.minimum ? this.minimum : this.dataInfo.min, 
                            h = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(f) || isFinite(h) ? 0 === f && 0 === h ? (h += 9, 
                            f = 0) : 0 === h - f ? (b = Math.min(Math.abs(.01 * Math.abs(h)), 5), h += b, f -= b) : f > h ? (b = Math.min(.01 * Math.abs(this.getApparentDifference(h, f, null, !0)), 5), 
                            0 <= h ? f = h - b : h = isFinite(f) ? f + b : 0) : (b = Math.min(.01 * Math.abs(this.getApparentDifference(f, h, null, !0)), .05), 
                            0 !== h && (h += b), 0 !== f && (f -= b)) : (h = "undefined" === typeof this.options.interval ? -1 / 0 : this.options.interval, 
                            f = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : 1 / 0), 
                            d = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < h - f ? .5 * Math.abs(h - f) : 1, 
                            this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < f && (f = 0), 
                            this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > h && (h = 0)), 
                            Math.abs(this.getApparentDifference(f, h, null, !0)), "axisX" === this.type && c) {
                                this.valueType = "dateTime";
                                if (null === this.minimum || isNaN(this.minimum)) this.minimum = f - d / 2, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? 1 / 0 : this.sessionVariables.viewportMinimum);
                                if (null === this.maximum || isNaN(this.maximum)) this.maximum = h + d / 2, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -1 / 0 : this.sessionVariables.viewportMaximum);
                            } else this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? f - d / 2 : Math.floor(f / this.interval) * this.interval, 
                            this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? 1 / 0 : this.sessionVariables.viewportMinimum)), 
                            null === this.maximum && (this.maximum = "axisX" === this.type ? h + d / 2 : Math.ceil(h / this.interval) * this.interval, 
                            this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -1 / 0 : this.sessionVariables.viewportMaximum)), 
                            0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));
                            p(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
                            p(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
                            this.range = this.viewportMaximum - this.viewportMinimum;
                            this.intervalStartPosition = "axisX" === this.type && c ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + .2 * this.interval) / this.interval) * this.interval;
                            this.valueFormatString || (this.valueFormatString = D.generateValueFormatString(this.range, 2));
                        }
                    };
                    D.prototype.calculateLogarithmicAxisParameters = function() {
                        var c, a = this.chart.layoutManager.getFreeSpace(), e = Math.log(this.logarithmBase);
                        "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, 
                        this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
                        var b, f, h, d;
                        a = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3);
                        d = 1;
                        if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;
                        if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;
                        if (this.scaleBreaks) for (d = 0; d < this.scaleBreaks._appliedBreaks.length; d++) if ((!p(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[d].startValue || !p(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[d].startValue || !p(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[d].startValue) && (!p(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[d].endValue || !p(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[d].endValue || !p(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[d].endValue)) {
                            this.scaleBreaks._appliedBreaks.splice(d, 1);
                            break;
                        }
                        "axisX" === this.type ? (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, 
                        f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 
                        1 === f / b && (d = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? .4 : this.options.interval), 
                        f *= d, b /= d), h = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, 
                        f = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 
                        0 >= b && !isFinite(f) ? (f = "undefined" === typeof this.options.interval ? 0 : this.options.interval, 
                        b = 1) : 0 >= b ? b = f : isFinite(f) || (f = b), 1 === b && 1 === f ? (f *= this.logarithmBase - 1 / this.logarithmBase, 
                        b = 1) : 1 === f / b ? (d = Math.min(f * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), 
                        f *= d, b /= d) : b > f ? (d = Math.min(b / f * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), 
                        1 <= f ? b = f / d : f = b * d) : (d = Math.min(f / b * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 
                        1 !== f && (f *= d), 1 !== b && (b /= d)), h = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, .5) : this.logarithmBase, 
                        this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < b && (b = 1), 
                        this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > f && (f = 1));
                        d = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? f : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
                        var l = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? f : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? b : this.viewportMinimum);
                        this.intervalType = "number";
                        d = Math.pow(this.logarithmBase, D.getNiceNumber(Math.abs(Math.log(d) / e), !1));
                        this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = D.getNiceExponent(Math.log(d) / e / (a - 1), !0), 
                        c = D.getNiceNumber(l / (a - 1), !0));
                        if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? b / Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / e / this.interval));
                        if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = "axisX" === this.type ? f * Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(f) / e / this.interval));
                        1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), 
                        this.options && "undefined" === typeof this.options.interval && (this.interval = D.getNiceExponent(Math.ceil(Math.log(d) / e) / (a - 1)), 
                        c = D.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)));
                        if (null === this.minimum || null === this.maximum) "axisX" === this.type ? (b = null !== this.minimum ? this.minimum : this.dataInfo.min, 
                        f = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === f / b && (d = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? .4 : this.options.interval), 
                        f *= d, b /= d), h = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (b = null !== this.minimum ? this.minimum : this.dataInfo.min, 
                        f = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(b) || isFinite(f) ? 1 === b && 1 === f ? (f *= this.logarithmBase, 
                        b /= this.logarithmBase) : 1 === f / b ? (d = Math.pow(this.logarithmBase, this.interval), 
                        f *= d, b /= d) : b > f ? (d = Math.min(.01 * (b / f), 5), 1 <= f ? b = f / d : f = b * d) : (d = Math.min(f / b * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 
                        1 !== f && (f *= d), 1 !== b && (b /= d)) : (f = "undefined" === typeof this.options.interval ? 0 : this.options.interval, 
                        b = 1), h = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : f / b > this.logarithmBase ? f / b * Math.pow(this.logarithmBase, .5) : this.logarithmBase, 
                        this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < b && (b = 1), 
                        this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > f && (f = 1)), 
                        this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? b / Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(b) / e / this.interval)), 
                        p(null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? 1 / 0 : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum) || (this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? 1 / 0 : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum))), 
                        null === this.maximum && (this.maximum = "axisX" === this.type ? f * Math.sqrt(h) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(f) / e / this.interval)), 
                        p(null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum) || (this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum))), 
                        1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));
                        this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
                        this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);
                        this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);
                        b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (e * this.interval) + .2) * this.interval);
                        this.range = this.viewportMaximum / this.viewportMinimum;
                        this.noTicks = a;
                        if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {
                            for (e = Math.floor(this.viewportMinimum / c + .5) * c; e < this.viewportMinimum; ) e += c;
                            this.equidistantInterval = !1;
                            this.intervalStartPosition = e;
                            this.interval = c;
                        } else this.options.interval || (c = Math.ceil(this.interval), this.range > this.interval && (this.interval = c, 
                        b = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (e * this.interval) + .2) * this.interval))), 
                        this.equidistantInterval = !0, this.intervalStartPosition = b;
                        if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum)) {
                            e = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;
                            if (isNaN(e) || !isFinite(e)) e = 2;
                            if (2 < e) for (d = 0; d < e - 2; d++) this.valueFormatString += "#";
                        }
                    };
                    D.generateValueFormatString = function(a, e) {
                        var c = "#,##0.", b = e;
                        1 > a && (b += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(b) || !isFinite(b)) && (b = e);
                        for (var f = 0; f < b; f++) c += "#";
                        return c;
                    };
                    D.getNiceExponent = function(a, e) {
                        var c = Math.floor(Math.log(a) / Math.LN10), b = a / Math.pow(10, c);
                        b = 0 > c ? 1 >= b ? 1 : 5 >= b ? 5 : 10 : Math.max(Math.floor(b), 1);
                        return -20 > c ? Number(b * Math.pow(10, c)) : Number((b * Math.pow(10, c)).toFixed(20));
                    };
                    D.getNiceNumber = function(a, e) {
                        var c = Math.floor(Math.log(a) / Math.LN10), b = a / Math.pow(10, c);
                        b = e ? 1.5 > b ? 1 : 3 > b ? 2 : 7 > b ? 5 : 10 : 1 >= b ? 1 : 2 >= b ? 2 : 5 >= b ? 5 : 10;
                        return -20 > c ? Number(b * Math.pow(10, c)) : Number((b * Math.pow(10, c)).toFixed(20));
                    };
                    D.prototype.getLabelStartPoint = function() {
                        var a = U[this.intervalType + "Duration"] * this.interval;
                        a = new Date(Math.floor(this.viewportMinimum / a) * a);
                        if ("millisecond" !== this.intervalType) if ("second" === this.intervalType) 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), 
                        a.setMilliseconds(0)); else if ("minute" === this.intervalType) {
                            if (0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMinutes(a.getMinutes() + 1), 
                            a.setSeconds(0), a.setMilliseconds(0);
                        } else if ("hour" === this.intervalType) {
                            if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setHours(a.getHours() + 1), 
                            a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
                        } else if ("day" === this.intervalType) {
                            if (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + 1), 
                            a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
                        } else if ("week" === this.intervalType) {
                            if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + (7 - a.getDay())), 
                            a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
                        } else if ("month" === this.intervalType) {
                            if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMonth(a.getMonth() + 1), 
                            a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0);
                        } else "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), 
                        a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));
                        return a;
                    };
                    qa(ea, K);
                    qa(ca, K);
                    ca.prototype.createUserOptions = function(a) {
                        if ("undefined" !== typeof a || this.options._isPlaceholder) {
                            var e = 0;
                            this.parent.options._isPlaceholder && this.parent.createUserOptions();
                            this.options._isPlaceholder || (Ea(this.parent[this.optionsName]), e = this.parent.options[this.optionsName].indexOf(this.options));
                            this.options = "undefined" === typeof a ? {} : a;
                            this.parent.options[this.optionsName][e] = this.options;
                        }
                    };
                    ca.prototype.render = function(a) {
                        if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {
                            var e = this.ctx, c = this.ctx.globalAlpha;
                            this.ctx = a || this.ctx;
                            this.ctx.save();
                            this.ctx.beginPath();
                            this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
                            this.ctx.clip();
                            var b = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue), f = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);
                            this.ctx.strokeStyle = this.lineColor;
                            this.ctx.fillStyle = this.color;
                            this.ctx.beginPath();
                            this.ctx.globalAlpha = 1;
                            Y(this.id);
                            var d, l, p, t, k, m;
                            a = Math.max(this.spacing, 3);
                            var q = Math.max(0, this.lineThickness);
                            this.ctx.lineWidth = q;
                            this.ctx.setLineDash && this.ctx.setLineDash(H(this.lineDashType, q));
                            if ("bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position) {
                                if (b = 1 === q % 2 ? (b.x << 0) + .5 : b.x << 0, l = 1 === q % 2 ? (f.x << 0) + .5 : f.x << 0, 
                                "top" === this.scaleBreaks.parent._position ? (f = this.chart.plotArea.y1, p = this.chart.plotArea.y2 + q / 2 + .5 << 0) : (f = this.chart.plotArea.y2, 
                                p = this.chart.plotArea.y1 - q / 2 + .5 << 0, a *= -1), this.bounds = {
                                    x1: b - q / 2,
                                    y1: f,
                                    x2: l + q / 2,
                                    y2: p
                                }, this.ctx.moveTo(b, f), "straight" === this.type || "top" === this.scaleBreaks.parent._position && 0 >= a || "bottom" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(b, p), 
                                this.ctx.lineTo(l, p), this.ctx.lineTo(l, f); else if ("wavy" === this.type) {
                                    t = b;
                                    k = f;
                                    d = .5;
                                    m = (p - k) / a / 3;
                                    for (var n = 0; n < m; n++) this.ctx.bezierCurveTo(t + d * a, k + a, t + d * a, k + 2 * a, t, k + 3 * a), 
                                    k += 3 * a, d *= -1;
                                    this.ctx.bezierCurveTo(t + d * a, k + a, t + d * a, k + 2 * a, t, k + 3 * a);
                                    t = l;
                                    d *= -1;
                                    this.ctx.lineTo(t, k);
                                    for (n = 0; n < m; n++) this.ctx.bezierCurveTo(t + d * a, k - a, t + d * a, k - 2 * a, t, k - 3 * a), 
                                    k -= 3 * a, d *= -1;
                                } else if ("zigzag" === this.type) {
                                    d = -1;
                                    k = f + a;
                                    t = b + a;
                                    m = (p - k) / a / 2;
                                    for (n = 0; n < m; n++) this.ctx.lineTo(t, k), t += 2 * d * a, k += 2 * a, d *= -1;
                                    this.ctx.lineTo(t, k);
                                    t += l - b;
                                    for (n = 0; n < m + 1; n++) this.ctx.lineTo(t, k), t += 2 * d * a, k -= 2 * a, d *= -1;
                                    this.ctx.lineTo(t + d * a, k + a);
                                }
                            } else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position) if (f = 1 === q % 2 ? (f.y << 0) + .5 : f.y << 0, 
                            p = 1 === q % 2 ? (b.y << 0) + .5 : b.y << 0, "left" === this.scaleBreaks.parent._position ? (b = this.chart.plotArea.x1, 
                            l = this.chart.plotArea.x2 + q / 2 + .5 << 0) : (b = this.chart.plotArea.x2, l = this.chart.plotArea.x1 - q / 2 + .5 << 0, 
                            a *= -1), this.bounds = {
                                x1: b,
                                y1: f - q / 2,
                                x2: l,
                                y2: p + q / 2
                            }, this.ctx.moveTo(b, f), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= a || "right" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(l, f), 
                            this.ctx.lineTo(l, p), this.ctx.lineTo(b, p); else if ("wavy" === this.type) {
                                t = b;
                                k = f;
                                d = .5;
                                m = (l - t) / a / 3;
                                for (n = 0; n < m; n++) this.ctx.bezierCurveTo(t + a, k + d * a, t + 2 * a, k + d * a, t + 3 * a, k), 
                                t += 3 * a, d *= -1;
                                this.ctx.bezierCurveTo(t + a, k + d * a, t + 2 * a, k + d * a, t + 3 * a, k);
                                k = p;
                                d *= -1;
                                this.ctx.lineTo(t, k);
                                for (n = 0; n < m; n++) this.ctx.bezierCurveTo(t - a, k + d * a, t - 2 * a, k + d * a, t - 3 * a, k), 
                                t -= 3 * a, d *= -1;
                            } else if ("zigzag" === this.type) {
                                d = 1;
                                k = f - a;
                                t = b + a;
                                m = (l - t) / a / 2;
                                for (n = 0; n < m; n++) this.ctx.lineTo(t, k), k += 2 * d * a, t += 2 * a, d *= -1;
                                this.ctx.lineTo(t, k);
                                k += p - f;
                                for (n = 0; n < m + 1; n++) this.ctx.lineTo(t, k), k += 2 * d * a, t -= 2 * a, d *= -1;
                                this.ctx.lineTo(t + a, k + d * a);
                            }
                            0 < q && this.ctx.stroke();
                            this.ctx.closePath();
                            this.ctx.globalAlpha = this.fillOpacity;
                            this.ctx.globalCompositeOperation = "destination-over";
                            this.ctx.fill();
                            this.ctx.restore();
                            this.ctx.globalAlpha = c;
                            this.ctx = e;
                        }
                    };
                    qa(O, K);
                    O.prototype.createUserOptions = function(a) {
                        if ("undefined" !== typeof a || this.options._isPlaceholder) {
                            var e = 0;
                            this.parent.options._isPlaceholder && this.parent.createUserOptions();
                            this.options._isPlaceholder || (Ea(this.parent.stripLines), e = this.parent.options.stripLines.indexOf(this.options));
                            this.options = "undefined" === typeof a ? {} : a;
                            this.parent.options.stripLines[e] = this.options;
                        }
                    };
                    O.prototype.render = function() {
                        this.ctx.save();
                        var a = this.parent.getPixelCoordinatesOnAxis(this.value), e = Math.abs("pixel" === this._thicknessType ? this.thickness : Math.abs(this.parent.convertValueToPixel(this.endValue) - this.parent.convertValueToPixel(this.startValue)));
                        if (0 < e) {
                            var c = null === this.opacity ? 1 : this.opacity;
                            this.ctx.strokeStyle = this.color;
                            this.ctx.beginPath();
                            var b = this.ctx.globalAlpha;
                            this.ctx.globalAlpha = c;
                            Y(this.id);
                            var f, d, l, p;
                            this.ctx.lineWidth = e;
                            this.ctx.setLineDash && this.ctx.setLineDash(H(this.lineDashType, e));
                            if ("bottom" === this.parent._position || "top" === this.parent._position) f = d = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + .5 : a.x << 0, 
                            l = this.chart.plotArea.y1, p = this.chart.plotArea.y2, this.bounds = {
                                x1: f - e / 2,
                                y1: l,
                                x2: d + e / 2,
                                y2: p
                            }; else if ("left" === this.parent._position || "right" === this.parent._position) l = p = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + .5 : a.y << 0, 
                            f = this.chart.plotArea.x1, d = this.chart.plotArea.x2, this.bounds = {
                                x1: f,
                                y1: l - e / 2,
                                x2: d,
                                y2: p + e / 2
                            };
                            this.ctx.moveTo(f, l);
                            this.ctx.lineTo(d, p);
                            this.ctx.stroke();
                            this.ctx.globalAlpha = b;
                        }
                        this.ctx.restore();
                    };
                    qa(da, K);
                    da.prototype.showAt = function(a) {
                        if (!this.enabled) return !1;
                        var e = this.chart, c = !1;
                        e.resetOverlayedCanvas();
                        e.clearedOverlayedCanvas = this.parent.type;
                        this.chart.renderCrosshairs(this.parent);
                        if ("xySwapped" === e.plotInfo.axisPlacement) {
                            if ("bottom" === this.parent._position) for (var b = 0; b < e.axisY.length; b++) this.parent === e.axisY[b] && (e.axisY[b]._crosshairValue = a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum ? a : null); else if ("top" === this.parent._position) for (b = 0; b < e.axisY2.length; b++) this.parent === e.axisY2[b] && (e.axisY2[b]._crosshairValue = a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum ? a : null); else if ("left" === this.parent._position) for (b = 0; b < e.axisX.length; b++) this.parent === e.axisX[b] && (e.axisX[b]._crosshairValue = a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum ? a : null); else if ("right" === this.parent._position) for (b = 0; b < e.axisX2.length; b++) this.parent === e.axisX2[b] && (e.axisX2[b]._crosshairValue = a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum ? a : null);
                        } else if ("bottom" === this.parent._position) for (b = 0; b < e.axisX.length; b++) this.parent === e.axisX[b] && (e.axisX[b]._crosshairValue = a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum ? a : null); else if ("top" === this.parent._position) for (b = 0; b < e.axisX2.length; b++) this.parent === e.axisX2[b] && (e.axisX2[b]._crosshairValue = a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum ? a : null); else if ("left" === this.parent._position) for (b = 0; b < e.axisY.length; b++) this.parent === e.axisY[b] && (e.axisY[b]._crosshairValue = a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum ? a : null); else if ("right" === this.parent._position) for (b = 0; b < e.axisY2.length; b++) this.parent === e.axisY2[b] && (e.axisY2[b]._crosshairValue = a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum ? a : null);
                        for (b = 0; b < e.axisX.length; b++) a = e.axisX[b]._crosshairValue, e.axisX[b].crosshair && e.axisX[b].crosshair.enabled && !p(a) && a >= e.axisX[b].viewportMinimum && a <= e.axisX[b].viewportMaximum && (e.axisX[b].showCrosshair(a), 
                        e.axisX[b].crosshair._updatedValue = a, this === e.axisX[b].crosshair && (c = !0));
                        for (b = 0; b < e.axisX2.length; b++) a = e.axisX2[b]._crosshairValue, e.axisX2[b].crosshair && e.axisX2[b].crosshair.enabled && !p(a) && a >= e.axisX2[b].viewportMinimum && a <= e.axisX2[b].viewportMaximum && (e.axisX2[b].showCrosshair(a), 
                        e.axisX2[b].crosshair._updatedValue = a, this === e.axisX2[b].crosshair && (c = !0));
                        for (b = 0; b < e.axisY.length; b++) a = e.axisY[b]._crosshairValue, e.axisY[b].crosshair && e.axisY[b].crosshair.enabled && !p(a) && a >= e.axisY[b].viewportMinimum && a <= e.axisY[b].viewportMaximum && (e.axisY[b].showCrosshair(a), 
                        e.axisY[b].crosshair._updatedValue = a, this === e.axisY[b].crosshair && (c = !0));
                        for (b = 0; b < e.axisY2.length; b++) a = e.axisY2[b]._crosshairValue, e.axisY2[b].crosshair && e.axisY2[b].crosshair.enabled && !p(a) && a >= e.axisY2[b].viewportMinimum && a <= e.axisY2[b].viewportMaximum && (e.axisY2[b].showCrosshair(a), 
                        e.axisY2[b].crosshair._updatedValue = a, this === e.axisY2[b].crosshair && (c = !0));
                        this.chart.toolTip && this.chart.toolTip._entries && this.chart.toolTip.highlightObjects(this.chart.toolTip._entries);
                        return c;
                    };
                    da.prototype.hide = function() {
                        this.chart.resetOverlayedCanvas();
                        this.chart.renderCrosshairs(this.parent);
                        this._hidden = !0;
                    };
                    da.prototype.render = function(a, e, c) {
                        var b, f, d, l, t = null, v = null, k = null, m = "";
                        this.valueFormatString || ("dateTime" === this.parent.valueType ? this.valueFormatString = this.parent.valueFormatString : (k = 0, 
                        k = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0), 
                        this.valueFormatString = D.generateValueFormatString(this.parent.range, k)));
                        var q = null === this.opacity ? 1 : this.opacity, n = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness), g = this.chart.overlaidCanvasCtx, B = g.globalAlpha;
                        g.beginPath();
                        g.strokeStyle = this.color;
                        g.lineWidth = n;
                        g.save();
                        this.labelFontSize = Math.abs(p(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize);
                        this.labelMaxWidth = p(this.options.labelMaxWidth) ? .3 * this.chart.width : this.labelMaxWidth;
                        this.labelMaxHeight = p(this.options.labelWrap) || this.labelWrap ? .3 * this.chart.height : 2 * this.labelFontSize;
                        0 < n && g.setLineDash && g.setLineDash(H(this.lineDashType, n));
                        k = new ka(g, {
                            x: 0,
                            y: 0,
                            padding: {
                                top: 2,
                                right: 3,
                                bottom: 2,
                                left: 4
                            },
                            backgroundColor: this.labelBackgroundColor,
                            borderColor: this.labelBorderColor,
                            borderThickness: this.labelBorderThickness,
                            cornerRadius: this.labelCornerRadius,
                            maxWidth: this.labelMaxWidth,
                            maxHeight: this.labelMaxHeight,
                            angle: this.labelAngle,
                            text: m,
                            horizontalAlign: "left",
                            fontSize: this.labelFontSize,
                            fontFamily: this.labelFontFamily,
                            fontWeight: this.labelFontWeight,
                            fontColor: this.labelFontColor,
                            fontStyle: this.labelFontStyle,
                            textBaseline: "middle"
                        });
                        if (this.snapToDataPoint) {
                            var w = 0;
                            m = [];
                            if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                                var y = null;
                                if ("bottom" === this.parent._position || "top" === this.parent._position) w = this.parent.dataSeries[0].axisX.convertPixelToValue({
                                    y: e
                                }); else if ("left" === this.parent._position || "right" === this.parent._position) w = this.parent.convertPixelToValue({
                                    y: e
                                });
                                for (var s = 0; s < this.parent.dataSeries.length; s++) (y = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= y.index && (y.dataSeries = this.parent.dataSeries[s], 
                                null !== y.dataPoint.y && y.dataSeries.visible && m.push(y));
                                y = null;
                                if (0 === m.length) return;
                                m.sort((function(a, b) {
                                    return a.distance - b.distance;
                                }));
                                var z = y = 0;
                                yPercent = cumulativeY = 0;
                                var u;
                                for (w = 1 / 0, s = 0; s < m.length; s++) {
                                    if ("rangeBar" === m[s].dataSeries.type || "error" === m[s].dataSeries.type) {
                                        if (m[s].dataPoint.y) for (var E = 0; E < m[s].dataPoint.y.length; E++) z = Math.abs(a - this.parent.convertValueToPixel(m[s].dataPoint.y[E])), 
                                        z <= w && (w = z, y = s);
                                    } else "stackedBar" === m[s].dataSeries.type ? (cumulativeY = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, 
                                    z = Math.abs(a - this.parent.convertValueToPixel(cumulativeY)), z <= w && (w = z, 
                                    y = s)) : "stackedBar100" === m[s].dataSeries.type ? (z = m[0].dataPoint.x.getTime ? m[0].dataPoint.x.getTime() : m[0].dataPoint.x, 
                                    p(u) && (u = Math.abs(a - this.parent.convertValueToPixel(100 * (m[0].dataSeries.dataPointEOs[m[0].index].cumulativeY / m[0].dataSeries.plotUnit.dataPointYSums[z])))), 
                                    cumulativeY = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, z = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, 
                                    yPercent = 100 * (cumulativeY / m[s].dataSeries.plotUnit.dataPointYSums[z]), z = Math.abs(a - this.parent.convertValueToPixel(yPercent)), 
                                    z <= u && (u = z, y = s)) : (z = Math.abs(a - this.parent.convertValueToPixel(m[s].dataPoint.y)), 
                                    z <= w && (w = z, y = s));
                                    p(u) || (w = Math.min(w, u));
                                }
                                u = m[y];
                                s = 0;
                                if ("bottom" === this.parent._position || "top" === this.parent._position) {
                                    if ("rangeBar" === u.dataSeries.type || "error" === u.dataSeries.type) {
                                        w = Math.abs(a - this.parent.convertValueToPixel(u.dataPoint.y[0]));
                                        for (m = 0; m < u.dataPoint.y.length; m++) z = Math.abs(a - this.parent.convertValueToPixel(u.dataPoint.y[m])), 
                                        z < w && (w = z, s = m);
                                        t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0) + .5 : this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0;
                                        this.value = u.dataPoint.y[s];
                                        k.text = this.labelFormatter ? this.labelFormatter({
                                            chart: this.chart,
                                            axis: this.parent.options,
                                            crosshair: this.options,
                                            value: u.dataPoint.y[s]
                                        }) : p(this.options.label) ? fa(p(c) ? u.dataPoint.y[s] : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
                                    } else "stackedBar" === u.dataSeries.type ? (w = Math.abs(a - this.parent.convertValueToPixel(m[0].dataPoint.y)), 
                                    cumulativeY = u.dataSeries.dataPointEOs[u.index].cumulativeY, t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(cumulativeY) << 0) + .5 : this.parent.convertValueToPixel(cumulativeY) << 0, 
                                    this.value = cumulativeY, k.text = this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: u.dataPoint.y
                                    }) : p(this.options.label) ? fa(p(c) ? u.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label) : "stackedBar100" === u.dataSeries.type ? (w = Math.abs(a - this.parent.convertValueToPixel(m[0].dataPoint.y)), 
                                    cumulativeY = u.dataSeries.dataPointEOs[u.index].cumulativeY, z = u.dataPoint.x.getTime ? u.dataPoint.x.getTime() : u.dataPoint.x, 
                                    yPercent = 100 * (cumulativeY / u.dataSeries.plotUnit.dataPointYSums[z]), t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(yPercent) << 0) + .5 : this.parent.convertValueToPixel(yPercent) << 0, 
                                    this.value = yPercent, k.text = this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: yPercent
                                    }) : p(this.options.label) ? fa(p(c) ? yPercent : c, this.valueFormatString, this.chart._cultureInfo) : this.label) : (t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.y) << 0) + .5 : this.parent.convertValueToPixel(u.dataPoint.y) << 0, 
                                    this.value = u.dataPoint.y, k.text = this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: u.dataPoint.y
                                    }) : p(this.options.label) ? fa(p(c) ? u.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label);
                                    b = f = t;
                                    d = this.chart.plotArea.y1;
                                    l = this.chart.plotArea.y2;
                                    this.bounds = {
                                        x1: b - n / 2,
                                        y1: d,
                                        x2: f + n / 2,
                                        y2: l
                                    };
                                    k.x = b - k.measureText().width / 2;
                                    k.x + k.width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.width : k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
                                    k.y = this.parent.lineCoordinates.y2 + ("top" === this.parent._position ? -k.height + this.parent.tickLength : k.fontSize / 2) + 2;
                                    k.y + k.height > this.chart.bounds.y2 ? k.y = this.chart.bounds.y2 - k.height : k.y < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1);
                                } else if ("left" === this.parent._position || "right" === this.parent._position) {
                                    d = l = v = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.x) << 0) + .5 : this.parent.convertValueToPixel(u.dataPoint.x) << 0;
                                    b = this.chart.plotArea.x1;
                                    f = this.chart.plotArea.x2;
                                    this.bounds = {
                                        x1: b,
                                        y1: d - n / 2,
                                        x2: f,
                                        y2: l + n / 2
                                    };
                                    s = !1;
                                    if (this.parent.labels) for (w = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += w) if (this.parent.labels[m]) s = !0; else {
                                        s = !1;
                                        break;
                                    }
                                    if (s) {
                                        if ("axisX" === this.parent.type) for (w = this.parent.convertPixelToValue({
                                            y: e
                                        }), y = null, s = 0; s < this.parent.dataSeries.length; s++) (y = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= y.index && (k.text = this.labelFormatter ? this.labelFormatter({
                                            chart: this.chart,
                                            axis: this.parent.options,
                                            crosshair: this.options,
                                            value: u.dataPoint.x
                                        }) : p(this.options.label) ? y.dataPoint.label : this.label);
                                    } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: u.dataPoint.x
                                    }) : p(this.options.label) ? fa(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: u.dataPoint.x
                                    }) : p(this.options.label) ? Da(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;
                                    this.value = u.dataPoint.x;
                                    k.y = l + k.fontSize / 2 - k.measureText().height / 2 + 2;
                                    k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
                                    "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
                                }
                            } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
                                w = this.parent.convertPixelToValue({
                                    x: a
                                });
                                for (s = 0; s < this.parent.dataSeries.length; s++) (y = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= y.index && (y.dataSeries = this.parent.dataSeries[s], 
                                null !== y.dataPoint.y && y.dataSeries.visible && m.push(y));
                                if (0 === m.length) return;
                                m.sort((function(a, b) {
                                    return a.distance - b.distance;
                                }));
                                u = m[0];
                                b = f = t = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.x) << 0) + .5 : this.parent.convertValueToPixel(u.dataPoint.x) << 0;
                                d = this.chart.plotArea.y1;
                                l = this.chart.plotArea.y2;
                                this.bounds = {
                                    x1: b - n / 2,
                                    y1: d,
                                    x2: f + n / 2,
                                    y2: l
                                };
                                s = !1;
                                if (this.parent.labels) for (w = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += w) if (this.parent.labels[m]) s = !0; else {
                                    s = !1;
                                    break;
                                }
                                if (s) {
                                    if ("axisX" === this.parent.type) for (w = this.parent.convertPixelToValue({
                                        x: a
                                    }), y = null, s = 0; s < this.parent.dataSeries.length; s++) (y = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= y.index && (k.text = this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: u.dataPoint.x
                                    }) : p(this.options.label) ? y.dataPoint.label : this.label);
                                } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: u.dataPoint.x
                                }) : p(this.options.label) ? fa(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: u.dataPoint.x
                                }) : p(this.options.label) ? Da(u.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label;
                                this.value = u.dataPoint.x;
                                k.x = b - k.measureText().width / 2;
                                k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);
                                k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
                                "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
                            } else if ("left" === this.parent._position || "right" === this.parent._position) {
                                !p(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (w = this.parent.dataSeries[0].axisX.convertPixelToValue({
                                    x: a
                                }));
                                for (s = 0; s < this.parent.dataSeries.length; s++) (y = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= y.index && (y.dataSeries = this.parent.dataSeries[s], 
                                null !== y.dataPoint.y && y.dataSeries.visible && m.push(y));
                                if (0 === m.length) return;
                                m.sort((function(a, b) {
                                    return a.distance - b.distance;
                                }));
                                z = y = 0;
                                w = 1 / 0;
                                for (s = 0; s < m.length; s++) {
                                    if ("rangeColumn" === m[s].dataSeries.type || "rangeArea" === m[s].dataSeries.type || "error" === m[s].dataSeries.type || "rangeSplineArea" === m[s].dataSeries.type || "candlestick" === m[s].dataSeries.type || "ohlc" === m[s].dataSeries.type || "boxAndWhisker" === m[s].dataSeries.type) {
                                        if (m[s].dataPoint.y) for (E = 0; E < m[s].dataPoint.y.length; E++) z = Math.abs(e - this.parent.convertValueToPixel(m[s].dataPoint.y[E])), 
                                        z <= w && (w = z, y = s);
                                    } else "stackedColumn" === m[s].dataSeries.type ? (b = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, 
                                    z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= w && (w = z, y = s)) : "stackedArea" === m[s].dataSeries.type ? (b = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, 
                                    z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= w && (w = z, y = s)) : "stackedColumn100" === m[s].dataSeries.type || "stackedArea100" === m[s].dataSeries.type ? (z = m[0].dataPoint.x.getTime ? m[0].dataPoint.x.getTime() : m[0].dataPoint.x, 
                                    p(u) && (u = Math.abs(e - this.parent.convertValueToPixel(100 * (m[0].dataSeries.dataPointEOs[m[0].index].cumulativeY / m[0].dataSeries.plotUnit.dataPointYSums[z])))), 
                                    "stackedColumn100" === m[s].dataSeries.type ? (v = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, 
                                    z = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, b = 100 * (v / m[s].dataSeries.plotUnit.dataPointYSums[z]), 
                                    z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= u && (u = z, y = s)) : "stackedArea100" === m[s].dataSeries.type && (v = m[s].dataSeries.dataPointEOs[m[s].index].cumulativeY, 
                                    z = m[s].dataPoint.x.getTime ? m[s].dataPoint.x.getTime() : m[s].dataPoint.x, b = 100 * (v / m[s].dataSeries.plotUnit.dataPointYSums[z]), 
                                    z = Math.abs(e - this.parent.convertValueToPixel(b)), z <= u && (u = z, y = s))) : "waterfall" === m[s].dataSeries.type ? (z = Math.abs(e - this.parent.convertValueToPixel(m[s].dataSeries.dataPointEOs[m[s].index].cumulativeSum)), 
                                    z <= w && (u = w = z, y = s)) : (z = Math.abs(e - this.parent.convertValueToPixel(m[s].dataPoint.y)), 
                                    z <= w && (w = z, y = s));
                                    p(u) || (w = Math.min(w, u));
                                }
                                u = m[y];
                                s = 0;
                                if ("rangeColumn" === u.dataSeries.type || "rangeArea" === u.dataSeries.type || "error" === u.dataSeries.type || "rangeSplineArea" === u.dataSeries.type || "candlestick" === u.dataSeries.type || "ohlc" === u.dataSeries.type || "boxAndWhisker" === u.dataSeries.type) {
                                    w = Math.abs(e - this.parent.convertValueToPixel(u.dataPoint.y[0]));
                                    for (m = 0; m < u.dataPoint.y.length; m++) z = Math.abs(e - this.parent.convertValueToPixel(u.dataPoint.y[m])), 
                                    z < w && (w = z, s = m);
                                    v = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0) + .5 : this.parent.convertValueToPixel(u.dataPoint.y[s]) << 0;
                                    k.text = this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: u.dataPoint.y[s]
                                    }) : p(this.options.label) ? fa(p(c) ? u.dataPoint.y[s] : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
                                    this.value = u.dataPoint.y[s];
                                } else "stackedColumn" === u.dataSeries.type ? (b = u.dataSeries.dataPointEOs[u.index].cumulativeY, 
                                v = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + .5 : this.parent.convertValueToPixel(b) << 0, 
                                k.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: u.dataPoint.y
                                }) : p(this.options.label) ? fa(p(c) ? u.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                                this.value = b) : "stackedArea" === u.dataSeries.type ? (b = u.dataSeries.dataPointEOs[u.index].cumulativeY, 
                                v = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + .5 : this.parent.convertValueToPixel(b) << 0, 
                                k.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: u.dataPoint.y
                                }) : p(this.options.label) ? fa(p(c) ? u.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                                this.value = b) : "stackedColumn100" === u.dataSeries.type ? (v = u.dataSeries.dataPointEOs[u.index].cumulativeY, 
                                z = u.dataPoint.x.getTime ? u.dataPoint.x.getTime() : u.dataPoint.x, b = 100 * (v / u.dataSeries.plotUnit.dataPointYSums[z]), 
                                v = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + .5 : this.parent.convertValueToPixel(b) << 0, 
                                k.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: b
                                }) : p(this.options.label) ? fa(p(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                                this.value = b) : "stackedArea100" === u.dataSeries.type ? (v = u.dataSeries.dataPointEOs[u.index].cumulativeY, 
                                z = u.dataPoint.x.getTime ? u.dataPoint.x.getTime() : u.dataPoint.x, b = 100 * (v / u.dataSeries.plotUnit.dataPointYSums[z]), 
                                v = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(b) << 0) + .5 : this.parent.convertValueToPixel(b) << 0, 
                                k.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: b
                                }) : p(this.options.label) ? fa(p(c) ? b : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                                this.value = b) : "waterfall" === u.dataSeries.type ? (v = 1 === g.lineWidth % 2 ? (this.parent.convertValueToPixel(u.dataSeries.dataPointEOs[u.index].cumulativeSum) << 0) + .5 : this.parent.convertValueToPixel(u.dataSeries.dataPointEOs[u.index].cumulativeSum) << 0, 
                                k.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: u.dataSeries.dataPointEOs[u.index].cumulativeSum
                                }) : p(this.options.label) ? fa(p(c) ? u.dataSeries.dataPointEOs[u.index].cumulativeSum : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                                this.value = u.dataSeries.dataPointEOs[u.index].cumulativeSum) : (v = 1 === g.lineWidth % 2 ? (p(a) ? e : this.parent.convertValueToPixel(u.dataPoint.y) << 0) + .5 : p(a) ? e : this.parent.convertValueToPixel(u.dataPoint.y) << 0, 
                                k.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: p(c) ? u.dataPoint.y : c
                                }) : p(this.options.label) ? fa(p(c) ? u.dataPoint.y : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                                this.value = u.dataPoint.y);
                                d = l = v;
                                b = this.chart.plotArea.x1;
                                f = this.chart.plotArea.x2;
                                this.bounds = {
                                    x1: b,
                                    y1: d - n / 2,
                                    x2: f,
                                    y2: l + n / 2
                                };
                                k.y = l + k.fontSize / 2 - k.measureText().height / 2 + 2;
                                k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
                                "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
                            }
                            m = null;
                            g.globalAlpha = q;
                            if ("bottom" === this.parent._position || "top" === this.parent._position) "top" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 && (k.y = this.chart.bounds.y1 + k.fontSize / 2), 
                            "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - k.fontSize / 2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2), 
                            this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < n && (g.moveTo(b, d), 
                            g.lineTo(f, l), g.stroke(), this._hidden = !1);
                            if ("left" === this.parent._position || "right" === this.parent._position) "left" === this.parent._position && k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), 
                            "right" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.measureText().width), 
                            this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && 0 < n && (g.moveTo(b, d), 
                            g.lineTo(f, l), g.stroke(), this._hidden = !1);
                        } else {
                            if ("bottom" === this.parent._position || "top" === this.parent._position) b = f = t = 1 === g.lineWidth % 2 ? (a << 0) + .5 : a << 0, 
                            d = this.chart.plotArea.y1, l = this.chart.plotArea.y2, this.bounds = {
                                x1: b - n / 2,
                                y1: d,
                                x2: f + n / 2,
                                y2: l
                            }; else if ("left" === this.parent._position || "right" === this.parent._position) d = l = v = 1 === g.lineWidth % 2 ? (e << 0) + .5 : e << 0, 
                            b = this.chart.plotArea.x1, f = this.chart.plotArea.x2, this.bounds = {
                                x1: b,
                                y1: d - n / 2,
                                x2: f,
                                y2: l + n / 2
                            };
                            if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                                if ("left" === this.parent._position || "right" === this.parent._position) {
                                    s = !1;
                                    if (this.parent.labels) for (w = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += w) if (this.parent.labels[m]) s = !0; else {
                                        s = !1;
                                        break;
                                    }
                                    if (s) {
                                        if ("axisX" === this.parent.type) for (w = this.parent.convertPixelToValue({
                                            y: e
                                        }), y = null, s = 0; s < this.parent.dataSeries.length; s++) (y = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= y.index && (k.text = this.labelFormatter ? this.labelFormatter({
                                            chart: this.chart,
                                            axis: this.parent.options,
                                            crosshair: this.options,
                                            value: p(c) ? this.parent.convertPixelToValue(a) : c
                                        }) : p(this.options.label) ? y.dataPoint.label : this.label);
                                    } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: p(c) ? this.parent.convertPixelToValue(e) : c
                                    }) : p(this.options.label) ? fa(p(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: p(c) ? this.parent.convertPixelToValue(e) : c
                                    }) : p(this.options.label) ? Da(p(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
                                    k.y = e + k.fontSize / 2 - k.measureText().height / 2 + 2;
                                    k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2);
                                    "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x1 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
                                } else if ("bottom" === this.parent._position || "top" === this.parent._position) k.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: p(c) ? this.parent.convertPixelToValue(a) : c
                                }) : p(this.options.label) ? fa(p(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                                k.x = b - k.measureText().width / 2, k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width), 
                                k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1), "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
                            } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
                                s = !1;
                                m = "";
                                if (this.parent.labels) for (w = Math.ceil(this.parent.interval), m = 0; m < this.parent.viewportMaximum; m += w) if (this.parent.labels[m]) s = !0; else {
                                    s = !1;
                                    break;
                                }
                                if (s) {
                                    if ("axisX" === this.parent.type) for (w = this.parent.convertPixelToValue({
                                        x: a
                                    }), y = null, s = 0; s < this.parent.dataSeries.length; s++) (y = this.parent.dataSeries[s].getDataPointAtX(w, !0)) && 0 <= y.index && (k.text = this.labelFormatter ? this.labelFormatter({
                                        chart: this.chart,
                                        axis: this.parent.options,
                                        crosshair: this.options,
                                        value: p(c) ? this.parent.convertPixelToValue(a) : c
                                    }) : p(this.options.label) ? p(c) ? y.dataPoint.label : c : this.label);
                                } else k.text = "dateTime" !== this.parent.valueType || this.parent.logarithmic ? this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: p(c) ? 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : "" : c
                                }) : p(this.options.label) ? fa(p(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label : this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: p(c) ? this.parent.convertPixelToValue(a) : c
                                }) : p(this.options.label) ? Da(p(c) ? this.parent.convertPixelToValue(a) : c, this.valueFormatString, this.chart._cultureInfo) : this.label;
                                k.x = b - k.measureText().width / 2;
                                k.x + k.width > this.chart.bounds.x2 && (k.x = this.chart.bounds.x2 - k.width);
                                k.x < this.chart.bounds.x1 && (k.x = this.chart.bounds.x1);
                                "bottom" === this.parent._position ? k.y = this.parent.lineCoordinates.y2 + k.fontSize / 2 + 2 : "top" === this.parent._position && (k.y = this.parent.lineCoordinates.y1 - k.height + k.fontSize / 2 + 2);
                            } else if ("left" === this.parent._position || "right" === this.parent._position) k.text = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: p(c) ? this.parent.convertPixelToValue(e) : c
                            }) : p(this.options.label) ? fa(p(c) ? this.parent.convertPixelToValue(e) : c, this.valueFormatString, this.chart._cultureInfo) : this.label, 
                            k.y = e + k.fontSize / 2 - k.measureText().height / 2 + 2, k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 + 2 : k.y + k.measureText().height - k.fontSize / 2 > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.measureText().height + k.fontSize / 2), 
                            "left" === this.parent._position ? k.x = this.parent.lineCoordinates.x2 - k.measureText().width : "right" === this.parent._position && (k.x = this.parent.lineCoordinates.x2);
                            "left" === this.parent._position && k.x < this.chart.bounds.x1 ? k.x = this.chart.bounds.x1 : "right" === this.parent._position && k.x + k.measureText().width > this.chart.bounds.x2 ? k.x = this.chart.bounds.x2 - k.measureText().width : "top" === this.parent._position && k.y - k.fontSize / 2 < this.chart.bounds.y1 ? k.y = this.chart.bounds.y1 + k.fontSize / 2 : "bottom" === this.parent._position && this.parent.lineCoordinates.y2 - k.fontSize / 2 + k.measureText().height > this.chart.bounds.y2 && (k.y = this.chart.bounds.y2 - k.height + k.fontSize / 2 + 2);
                            g.globalAlpha = q;
                            0 < n && (g.moveTo(b, d), g.lineTo(f, l), g.stroke(), this._hidden = !1);
                            this.value = "bottom" === this.parent._position || "top" === this.parent._position ? this.parent.convertPixelToValue(a) : this.parent.convertPixelToValue(e);
                        }
                        if ("bottom" === this.parent._position || "top" === this.parent._position) this._updatedValue = this.parent.convertPixelToValue(t);
                        if ("left" === this.parent._position || "right" === this.parent._position) this._updatedValue = this.parent.convertPixelToValue(v);
                        this._textBlock = k;
                        this._label = c;
                        p(c) || this.renderLabel();
                        g.restore();
                        g.globalAlpha = B;
                    };
                    da.prototype.renderLabel = function() {
                        this.value >= Math.min(this.parent.viewportMinimum, this.parent.viewportMaximum) && this.value <= Math.max(this.parent.viewportMinimum, this.parent.viewportMaximum) && (p(this._textBlock) || p(this._textBlock.text) || !("number" === typeof this._textBlock.text.valueOf() || 0 < this._textBlock.text.length) || this._hidden || this._textBlock.render(!0), 
                        p(this._label) && this.dispatchEvent("updated", {
                            chart: this.chart,
                            crosshair: this.options,
                            axis: this.parent,
                            value: this.value
                        }, this.parent));
                    };
                    qa(V, K);
                    V.prototype._initialize = function() {
                        this.updateOption("updated");
                        this.updateOption("hidden");
                        if (this.enabled) {
                            this.container = document.createElement("div");
                            this.container.setAttribute("class", "canvasjs-chart-tooltip");
                            this.container.style.position = "absolute";
                            this.container.style.height = "auto";
                            this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)";
                            this.container.style.zIndex = "1000";
                            this.container.style.pointerEvents = "none";
                            this.container.style.display = "none";
                            var a = document.createElement("div");
                            a.style.width = "auto";
                            a.style.height = "auto";
                            a.style.minWidth = "50px";
                            a.style.lineHeight = "normal";
                            a.style.margin = "0px 0px 0px 0px";
                            a.style.padding = "5px";
                            a.style.fontFamily = "Calibri, Arial, Georgia, serif";
                            a.style.fontWeight = "normal";
                            a.style.fontStyle = v ? "italic" : "normal";
                            a.style.fontSize = "14px";
                            a.style.color = "#000000";
                            a.style.textShadow = "1px 1px 1px rgba(0, 0, 0, 0.1)";
                            a.style.textAlign = "left";
                            a.style.border = "2px solid gray";
                            a.style.background = v ? "rgba(255,255,255,.9)" : "rgb(255,255,255)";
                            a.style.textIndent = "0px";
                            a.style.whiteSpace = "nowrap";
                            a.style.borderRadius = "5px";
                            a.style.MozUserSelect = "none";
                            a.style.WebkitUserSelect = "none";
                            a.style.msUserSelect = "none";
                            a.style.userSelect = "none";
                            v || (a.style.filter = "alpha(opacity = 90)", a.style.filter = "progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666')");
                            a.innerText = "Sample Tooltip";
                            this.container.appendChild(a);
                            this.contentDiv = this.container.firstChild;
                            this.container.style.borderRadius = this.contentDiv.style.borderRadius;
                            this.chart._canvasJSContainer.appendChild(this.container);
                        }
                    };
                    V.prototype.mouseMoveHandler = function(a, e) {
                        this._lastUpdated && 4 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), 
                        this.chart.resetOverlayedCanvas(), this._updateToolTip(a, e), !this._updatedEventParameters || isNaN(this._prevX) || isNaN(this._prevY) || this.dispatchEvent("updated", this._updatedEventParameters, this));
                    };
                    V.prototype._updateToolTip = function(a, e, c) {
                        c = "undefined" === typeof c ? !0 : c;
                        this.container || this._initialize();
                        this.enabled || this.hide();
                        if (!this.chart.disableToolTip) {
                            if ("undefined" === typeof a || "undefined" === typeof e) {
                                if (isNaN(this._prevX) || isNaN(this._prevY)) return;
                                a = this._prevX;
                                e = this._prevY;
                            } else this._prevX = a, this._prevY = e;
                            var b = null, f = null, d = [], l = 0;
                            if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
                                var t = [];
                                if (this.chart.axisX) for (var B = 0; B < this.chart.axisX.length; B++) {
                                    l = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX[B].convertPixelToValue({
                                        y: e
                                    }) : this.chart.axisX[B].convertPixelToValue({
                                        x: a
                                    });
                                    var k = null;
                                    for (b = 0; b < this.chart.axisX[B].dataSeries.length; b++) (k = this.chart.axisX[B].dataSeries[b].getDataPointAtX(l, c)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[B].dataSeries[b], 
                                    null !== k.dataPoint.y && k.dataSeries.visible && t.push(k));
                                    k = null;
                                }
                                if (this.chart.axisX2) for (B = 0; B < this.chart.axisX2.length; B++) {
                                    l = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX2[B].convertPixelToValue({
                                        y: e
                                    }) : this.chart.axisX2[B].convertPixelToValue({
                                        x: a
                                    });
                                    k = null;
                                    for (b = 0; b < this.chart.axisX2[B].dataSeries.length; b++) (k = this.chart.axisX2[B].dataSeries[b].getDataPointAtX(l, c)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[B].dataSeries[b], 
                                    null !== k.dataPoint.y && k.dataSeries.visible && t.push(k));
                                    k = null;
                                }
                                if (0 === t.length) return;
                                t.sort((function(a, b) {
                                    return a.distance - b.distance;
                                }));
                                c = t[0];
                                for (b = 0; b < t.length; b++) t[b].dataPoint.x.valueOf() === c.dataPoint.x.valueOf() && d.push(t[b]);
                                t = null;
                            } else {
                                if (b = this.chart.getDataPointAtXY(a, e, c)) this.currentDataPointIndex = b.dataPointIndex, 
                                this.currentSeriesIndex = b.dataSeries.index; else if (v) if (b = ab(a, e, this.chart._eventManager.ghostCtx), 
                                0 < b && "undefined" !== typeof this.chart._eventManager.objectMap[b]) {
                                    b = this.chart._eventManager.objectMap[b];
                                    if ("legendItem" === b.objectType) return;
                                    this.currentSeriesIndex = b.dataSeriesIndex;
                                    this.currentDataPointIndex = 0 <= b.dataPointIndex ? b.dataPointIndex : -1;
                                } else this.currentDataPointIndex = -1; else this.currentDataPointIndex = -1;
                                if (0 <= this.currentSeriesIndex) {
                                    f = this.chart.data[this.currentSeriesIndex];
                                    k = {};
                                    if (0 <= this.currentDataPointIndex) b = f.dataPoints[this.currentDataPointIndex], 
                                    k.dataSeries = f, k.dataPoint = b, k.index = this.currentDataPointIndex, k.distance = Math.abs(b.x - l), 
                                    "waterfall" === f.type && (k.cumulativeSumYStartValue = f.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, 
                                    k.cumulativeSum = f.dataPointEOs[this.currentDataPointIndex].cumulativeSum); else {
                                        if (!this.enabled || "line" !== f.type && "stepLine" !== f.type && "spline" !== f.type && "area" !== f.type && "stepArea" !== f.type && "splineArea" !== f.type && "stackedArea" !== f.type && "stackedArea100" !== f.type && "rangeArea" !== f.type && "rangeSplineArea" !== f.type && "candlestick" !== f.type && "ohlc" !== f.type && "boxAndWhisker" !== f.type) {
                                            "toolTip" === this.chart.clearedOverlayedCanvas && (this.chart.resetOverlayedCanvas(), 
                                            this.chart.clearedOverlayedCanvas = null);
                                            return;
                                        }
                                        l = f.axisX.convertPixelToValue({
                                            x: a
                                        });
                                        k = f.getDataPointAtX(l, c);
                                        p(k) || (k.dataSeries = f, this.currentDataPointIndex = k.index, b = k.dataPoint);
                                    }
                                    if (!p(k) && !p(k.dataPoint) && !p(k.dataPoint.y)) if (k.dataSeries.axisY) if (0 < k.dataPoint.y.length) {
                                        for (b = c = 0; b < k.dataPoint.y.length; b++) k.dataPoint.y[b] < k.dataSeries.axisY.viewportMinimum ? c-- : k.dataPoint.y[b] > k.dataSeries.axisY.viewportMaximum && c++;
                                        c < k.dataPoint.y.length && c > -k.dataPoint.y.length && d.push(k);
                                    } else "column" === f.type || "bar" === f.type ? 0 > k.dataPoint.y ? 0 > k.dataSeries.axisY.viewportMinimum && k.dataSeries.axisY.viewportMaximum >= k.dataPoint.y && d.push(k) : k.dataSeries.axisY.viewportMinimum <= k.dataPoint.y && 0 <= k.dataSeries.axisY.viewportMaximum && d.push(k) : "bubble" === f.type ? (c = this.chart._eventManager.objectMap[f.dataPointIds[k.index]].size / 2, 
                                    k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum - c && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum + c && d.push(k)) : "waterfall" === f.type ? (c = 0, 
                                    k.cumulativeSumYStartValue < k.dataSeries.axisY.viewportMinimum ? c-- : k.cumulativeSumYStartValue > k.dataSeries.axisY.viewportMaximum && c++, 
                                    k.cumulativeSum < k.dataSeries.axisY.viewportMinimum ? c-- : k.cumulativeSum > k.dataSeries.axisY.viewportMaximum && c++, 
                                    2 > c && -2 < c && d.push(k)) : (0 <= k.dataSeries.type.indexOf("100") || "stackedColumn" === f.type || "stackedBar" === f.type || k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum) && d.push(k); else d.push(k);
                                }
                            }
                            if (0 < d.length) {
                                if (this.highlightObjects(d), this.enabled) {
                                    c = "";
                                    c = this.getToolTipInnerHTML({
                                        entries: d
                                    });
                                    if (null !== c) {
                                        this.contentDiv.innerHTML = c;
                                        if (this.isToolTipDefinedInData && p(this.options.content) && p(this.options.contentFormatter)) for (l = this.contentDiv.getElementsByTagName("span"), 
                                        b = 0; b < l.length; b++) l[b] && (l[b].style.color = l[b].getAttribute("data-color"));
                                        l = !1;
                                        "none" === this.container.style.display && (l = !0, this.container.style.display = "block");
                                        try {
                                            this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : v ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", 
                                            this.borderColor = "waterfall" === d[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : d[0].dataPoint.color ? d[0].dataPoint.color : 0 < d[0].dataPoint.y ? d[0].dataSeries.risingColor : d[0].dataSeries.fallingColor : "error" === d[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : d[0].dataSeries.color ? d[0].dataSeries.color : d[0].dataSeries._colorSet[f.index % d[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : d[0].dataPoint.color ? d[0].dataPoint.color : d[0].dataSeries.color ? d[0].dataSeries.color : d[0].dataSeries._colorSet[d[0].index % d[0].dataSeries._colorSet.length], 
                                            this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", 
                                            this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", 
                                            this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", 
                                            this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", 
                                            this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", 
                                            this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : v ? "italic" : "normal";
                                        } catch (m) {}
                                        "pie" === d[0].dataSeries.type || "doughnut" === d[0].dataSeries.type || "funnel" === d[0].dataSeries.type || "pyramid" === d[0].dataSeries.type || "bar" === d[0].dataSeries.type || "rangeBar" === d[0].dataSeries.type || "stackedBar" === d[0].dataSeries.type || "stackedBar100" === d[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = d[0].dataSeries.axisX.convertValueToPixel(d[0].dataPoint.x) - this.container.clientWidth << 0, 
                                        a -= 10);
                                        0 > a && (a += this.container.clientWidth + 20);
                                        a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
                                        e = 1 !== d.length || this.shared || "line" !== d[0].dataSeries.type && "stepLine" !== d[0].dataSeries.type && "spline" !== d[0].dataSeries.type && "area" !== d[0].dataSeries.type && "stepArea" !== d[0].dataSeries.type && "splineArea" !== d[0].dataSeries.type ? "bar" === d[0].dataSeries.type || "rangeBar" === d[0].dataSeries.type || "stackedBar" === d[0].dataSeries.type || "stackedBar100" === d[0].dataSeries.type ? d[0].dataSeries.axisX.convertValueToPixel(d[0].dataPoint.x) : e : d[0].dataSeries.axisY.convertValueToPixel(d[0].dataPoint.y);
                                        e = -e + 10;
                                        0 < e + this.container.clientHeight + 5 && (e -= e + this.container.clientHeight + 5 - 0);
                                        this.fixMozTransitionDelay(a, e);
                                        !this.animationEnabled || l ? this.disableAnimation() : (this.enableAnimation(), 
                                        this.container.style.MozTransition = this.mozContainerTransition);
                                        this.positionLeft = a;
                                        this.positionBottom = e;
                                        this.container.style.left = a + "px";
                                        this.container.style.bottom = e + "px";
                                    } else this.hide(!1), this.enabled && this.dispatchEvent("hidden", {
                                        chart: this.chart,
                                        toolTip: this
                                    }, this);
                                    e = [];
                                    for (b = 0; b < d.length; b++) e.push({
                                        xValue: d[b].dataPoint.x,
                                        dataPoint: d[b].dataPoint,
                                        dataSeries: d[b].dataSeries,
                                        dataPointIndex: d[b].index,
                                        dataSeriesIndex: d[b].dataSeries._index
                                    });
                                    this._updatedEventParameters = {
                                        chart: this.chart,
                                        toolTip: this.options,
                                        content: c,
                                        entries: e
                                    };
                                    this._entries = d;
                                }
                            } else this.hide(), this.enabled && this.dispatchEvent("hidden", {
                                chart: this.chart,
                                toolTip: this
                            }, this);
                        }
                    };
                    V.prototype.highlightObjects = function(a) {
                        var e = this.chart.overlaidCanvasCtx;
                        p(this.chart.clearedOverlayedCanvas) || "toolTip" === this.chart.clearedOverlayedCanvas ? (this.chart.resetOverlayedCanvas(), 
                        e.clearRect(0, 0, this.chart.width, this.chart.height), this.chart.clearedOverlayedCanvas = "toolTip") : this.chart.clearedOverlayedCanvas = null;
                        e.save();
                        var c = this.chart.plotArea, b = 0;
                        e.beginPath();
                        e.rect(c.x1, c.y1, c.x2 - c.x1, c.y2 - c.y1);
                        e.clip();
                        for (c = 0; c < a.length; c++) {
                            var f = a[c];
                            if ((f = this.chart._eventManager.objectMap[f.dataSeries.dataPointIds[f.index]]) && f.objectType && "dataPoint" === f.objectType) {
                                b = this.chart.data[f.dataSeriesIndex];
                                var d = b.dataPoints[f.dataPointIndex], l = f.dataPointIndex;
                                !1 === d.highlightEnabled || !0 !== b.highlightEnabled && !0 !== d.highlightEnabled || ("line" === b.type || "stepLine" === b.type || "spline" === b.type || "scatter" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type ? (d = b.getMarkerProperties(l, f.x1, f.y1, this.chart.overlaidCanvasCtx), 
                                d.size = Math.max(1.5 * d.size << 0, 10), d.borderColor = d.borderColor || "#FFFFFF", 
                                d.borderThickness = d.borderThickness || Math.ceil(.1 * d.size), W.drawMarkers([ d ]), 
                                "undefined" !== typeof f.y2 && (d = b.getMarkerProperties(l, f.x1, f.y2, this.chart.overlaidCanvasCtx), 
                                d.size = Math.max(1.5 * d.size << 0, 10), d.borderColor = d.borderColor || "#FFFFFF", 
                                d.borderThickness = d.borderThickness || Math.ceil(.1 * d.size), W.drawMarkers([ d ]))) : "bubble" === b.type ? (d = b.getMarkerProperties(l, f.x1, f.y1, this.chart.overlaidCanvasCtx), 
                                d.size = f.size, d.color = "white", d.borderColor = "white", e.globalAlpha = .3, 
                                W.drawMarkers([ d ]), e.globalAlpha = 1) : "column" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "bar" === b.type || "rangeBar" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "rangeColumn" === b.type || "waterfall" === b.type ? aa(e, f.x1, f.y1, f.x2, f.y2, "white", 0, null, !1, !1, !1, !1, .3) : "pie" === b.type || "doughnut" === b.type ? ra(e, f.center, f.radius, "white", b.type, f.startAngle, f.endAngle, .3, f.percentInnerRadius) : "funnel" === b.type || "pyramid" === b.type ? ta(e, f.funnelSection, .3, "white") : "candlestick" === b.type ? (e.globalAlpha = 1, 
                                e.strokeStyle = f.color, e.lineWidth = 2 * f.borderThickness, b = 0 === e.lineWidth % 2 ? 0 : .5, 
                                e.beginPath(), e.moveTo(f.x3 - b, Math.min(f.y2, f.y3)), e.lineTo(f.x3 - b, Math.min(f.y1, f.y4)), 
                                e.stroke(), e.beginPath(), e.moveTo(f.x3 - b, Math.max(f.y1, f.y4)), e.lineTo(f.x3 - b, Math.max(f.y2, f.y3)), 
                                e.stroke(), aa(e, f.x1, Math.min(f.y1, f.y4), f.x2, Math.max(f.y1, f.y4), "transparent", 2 * f.borderThickness, f.color, !1, !1, !1, !1), 
                                e.globalAlpha = 1) : "ohlc" === b.type ? (e.globalAlpha = 1, e.strokeStyle = f.color, 
                                e.lineWidth = 2 * f.borderThickness, b = 0 === e.lineWidth % 2 ? 0 : .5, e.beginPath(), 
                                e.moveTo(f.x3 - b, f.y2), e.lineTo(f.x3 - b, f.y3), e.stroke(), e.beginPath(), e.moveTo(f.x3, f.y1), 
                                e.lineTo(f.x1, f.y1), e.stroke(), e.beginPath(), e.moveTo(f.x3, f.y4), e.lineTo(f.x2, f.y4), 
                                e.stroke(), e.globalAlpha = 1) : "boxAndWhisker" === b.type ? (e.save(), e.globalAlpha = 1, 
                                e.strokeStyle = f.stemColor, e.lineWidth = 2 * f.stemThickness, 0 < f.stemThickness && (e.beginPath(), 
                                e.moveTo(f.x3, f.y2 + f.borderThickness / 2), e.lineTo(f.x3, f.y1 + f.whiskerThickness / 2), 
                                e.stroke(), e.beginPath(), e.moveTo(f.x3, f.y4 - f.whiskerThickness / 2), e.lineTo(f.x3, f.y3 - f.borderThickness / 2), 
                                e.stroke()), e.beginPath(), aa(e, f.x1, Math.max(f.y2, f.y3), f.x2, Math.min(f.y2, f.y3), "transparent", 2 * f.borderThickness, f.color, !1, !1, !1, !1), 
                                e.globalAlpha = 1, e.strokeStyle = f.whiskerColor, e.lineWidth = 2 * f.whiskerThickness, 
                                0 < f.whiskerThickness && (e.beginPath(), e.moveTo(Math.floor(f.x3 - f.whiskerLength / 2), f.y4), 
                                e.lineTo(Math.ceil(f.x3 + f.whiskerLength / 2), f.y4), e.stroke(), e.beginPath(), 
                                e.moveTo(Math.floor(f.x3 - f.whiskerLength / 2), f.y1), e.lineTo(Math.ceil(f.x3 + f.whiskerLength / 2), f.y1), 
                                e.stroke()), e.globalAlpha = 1, e.strokeStyle = f.lineColor, e.lineWidth = 2 * f.lineThickness, 
                                0 < f.lineThickness && (e.beginPath(), e.moveTo(f.x1, f.y5), e.lineTo(f.x2, f.y5), 
                                e.stroke()), e.restore(), e.globalAlpha = 1) : "error" === b.type && B(e, f.x1, f.y1, f.x2, f.y2, "white", f.whiskerProperties, f.stemProperties, f.isXYSwapped, .3));
                            }
                        }
                        e.restore();
                        e.globalAlpha = 1;
                        e.beginPath();
                    };
                    V.prototype.getToolTipInnerHTML = function(a) {
                        a = a.entries;
                        var e = null, c = null, b = null, d = 0, h = "";
                        this.isToolTipDefinedInData = !0;
                        for (var l = 0; l < a.length; l++) if (a[l].dataSeries.toolTipContent || a[l].dataPoint.toolTipContent) {
                            this.isToolTipDefinedInData = !1;
                            break;
                        }
                        if (this.isToolTipDefinedInData && (this.content && "function" === typeof this.content || this.contentFormatter)) a = {
                            chart: this.chart,
                            toolTip: this.options,
                            entries: a
                        }, e = this.contentFormatter ? this.contentFormatter(a) : this.content(a); else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
                            var p = null, t = "";
                            for (l = 0; l < a.length; l++) {
                                c = a[l].dataSeries;
                                b = a[l].dataPoint;
                                d = a[l].index;
                                h = "";
                                if (0 === l && this.isToolTipDefinedInData && !this.content) {
                                    this.chart.axisX && 0 < this.chart.axisX.length ? t += "undefined" !== typeof this.chart.axisX[0].labels[b.x] ? this.chart.axisX[0].labels[b.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (t += "undefined" !== typeof this.chart.axisX2[0].labels[b.x] ? this.chart.axisX2[0].labels[b.x] : "{x}");
                                    t += "</br>";
                                    if (!c.visible) continue;
                                    t = this.chart.replaceKeywordsWithValue(t, b, c, d);
                                }
                                null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c.options.toolTipContent || ("line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "waterfall" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (h += p != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), 
                                h += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}", 
                                p = c.axisXIndex) : "bubble" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (h += p != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), 
                                h += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}") : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "error" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (h += p != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), 
                                h += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}") : "candlestick" === c.type || "ohlc" === c.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (h += p != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), 
                                h += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}") : "boxAndWhisker" === c.type && (this.chart.axisX && 1 < this.chart.axisX.length && (h += p != c.axisXIndex ? c.axisX.title ? c.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), 
                                h += b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>{name}:</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"), 
                                null === e && (e = ""), c.visible && (!0 === this.reversed ? (e = this.chart.replaceKeywordsWithValue(h, b, c, d) + e, 
                                l < a.length - 1 && (e = "</br>" + e)) : (e += this.chart.replaceKeywordsWithValue(h, b, c, d), 
                                l < a.length - 1 && (e += "</br>"))));
                            }
                            null !== e && (e = t + e);
                        } else {
                            c = a[0].dataSeries;
                            b = a[0].dataPoint;
                            d = a[0].index;
                            if (null === b.toolTipContent || "undefined" === typeof b.toolTipContent && null === c.options.toolTipContent) return null;
                            "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "waterfall" === c.type ? h = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>" + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === c.type ? h = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>" + (b.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === c.type || "doughnut" === c.type || "funnel" === c.type || "pyramid" === c.type ? h = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>" + (b.name ? "{name}:</span>&nbsp;&nbsp;" : b.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "error" === c.type ? h = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>" + (b.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" === c.type || "ohlc" === c.type ? h = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>" + (b.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === c.type && (h = b.toolTipContent ? b.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span data-color='\"" + (this.options.fontColor ? "" : "'{color}'") + "\"'>" + (b.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");
                            null === e && (e = "");
                            e += this.chart.replaceKeywordsWithValue(h, b, c, d);
                        }
                        return e;
                    };
                    V.prototype.enableAnimation = function() {
                        if (!this.container.style.WebkitTransition) {
                            var a = this.getContainerTransition(this.containerTransitionDuration);
                            this.container.style.WebkitTransition = a;
                            this.container.style.MsTransition = a;
                            this.container.style.transition = a;
                            this.container.style.MozTransition = this.mozContainerTransition;
                        }
                    };
                    V.prototype.disableAnimation = function() {
                        this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", 
                        this.container.style.MozTransition = "", this.container.style.MsTransition = "", 
                        this.container.style.transition = "");
                    };
                    V.prototype.hide = function(a) {
                        this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, 
                        this._prevY = this._prevX = NaN, ("undefined" === typeof a || a) && this.chart.resetOverlayedCanvas());
                    };
                    V.prototype.show = function(a, e, c) {
                        this._updateToolTip(a, e, "undefined" === typeof c ? !1 : c);
                    };
                    V.prototype.showAtIndex = function(a, e) {};
                    V.prototype.showAtX = function(a, e) {
                        if (!this.enabled) return !1;
                        this.chart.clearedOverlayedCanvas = null;
                        var c, b, d, h = [];
                        d = !1;
                        e = !p(e) && 0 <= e && e < this.chart.data.length ? e : 0;
                        if (this.shared) for (var l = 0; l < this.chart.data.length; l++) c = this.chart.data[l], 
                        (b = c.getDataPointAtX(a, !1)) && b.dataPoint && !p(b.dataPoint.y) && c.visible && (b.dataSeries = c, 
                        h.push(b)); else c = this.chart.data[e], (b = c.getDataPointAtX(a, !1)) && b.dataPoint && !p(b.dataPoint.y) && c.visible && (b.dataSeries = c, 
                        h.push(b));
                        if (0 < h.length) {
                            for (l = 0; l < h.length; l++) if (b = h[l], (this.shared || 0 <= b.dataSeries.type.indexOf("100")) && b.dataPoint.x >= b.dataSeries.axisX.viewportMinimum && b.dataPoint.x <= b.dataSeries.axisX.viewportMaximum) {
                                d = !1;
                                break;
                            } else if (b.dataPoint.x < b.dataSeries.axisX.viewportMinimum || b.dataPoint.x > b.dataSeries.axisX.viewportMaximum || b.dataPoint.y < b.dataSeries.axisY.viewportMinimum || b.dataPoint.y > b.dataSeries.axisY.viewportMaximum) d = !0; else {
                                d = !1;
                                break;
                            }
                            if (d) return this.hide(), !1;
                            this.highlightObjects(h);
                            this._entries = h;
                            l = "";
                            l = this.getToolTipInnerHTML({
                                entries: h
                            });
                            if (null !== l) {
                                this.contentDiv.innerHTML = l;
                                if (this.isToolTipDefinedInData && p(this.options.content) && p(this.options.contentFormatter)) for (b = this.contentDiv.getElementsByTagName("span"), 
                                l = 0; l < b.length; l++) b[l] && (b[l].style.color = b[l].getAttribute("data-color"));
                                l = !1;
                                "none" === this.container.style.display && (l = !0, this.container.style.display = "block");
                                try {
                                    this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : v ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", 
                                    this.borderColor = "waterfall" === h[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : h[0].dataPoint.color ? h[0].dataPoint.color : 0 < h[0].dataPoint.y ? h[0].dataSeries.risingColor : h[0].dataSeries.fallingColor : "error" === h[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : h[0].dataSeries.color ? h[0].dataSeries.color : h[0].dataSeries._colorSet[c.index % h[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : h[0].dataPoint.color ? h[0].dataPoint.color : h[0].dataSeries.color ? h[0].dataSeries.color : h[0].dataSeries._colorSet[h[0].index % h[0].dataSeries._colorSet.length], 
                                    this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", 
                                    this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", 
                                    this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", 
                                    this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", 
                                    this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", 
                                    this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : v ? "italic" : "normal";
                                } catch (t) {}
                                "pie" === h[0].dataSeries.type || "doughnut" === h[0].dataSeries.type || "funnel" === h[0].dataSeries.type || "pyramid" === h[0].dataSeries.type ? c = mouseX - 10 - this.container.clientWidth : (c = "bar" === h[0].dataSeries.type || "rangeBar" === h[0].dataSeries.type || "stackedBar" === h[0].dataSeries.type || "stackedBar100" === h[0].dataSeries.type ? h[0].dataSeries.axisY.convertValueToPixel(h[0].dataPoint.y) - this.container.clientWidth << 0 : h[0].dataSeries.axisX.convertValueToPixel(h[0].dataPoint.x) - this.container.clientWidth << 0, 
                                c -= 10);
                                0 > c && (c += this.container.clientWidth + 20);
                                c + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (c = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
                                h = 1 !== h.length || this.shared || "line" !== h[0].dataSeries.type && "stepLine" !== h[0].dataSeries.type && "spline" !== h[0].dataSeries.type && "area" !== h[0].dataSeries.type && "stepArea" !== h[0].dataSeries.type && "splineArea" !== h[0].dataSeries.type ? "bar" === h[0].dataSeries.type || "rangeBar" === h[0].dataSeries.type || "stackedBar" === h[0].dataSeries.type || "stackedBar100" === h[0].dataSeries.type ? h[0].dataSeries.axisX.convertValueToPixel(h[0].dataPoint.x) : h[0].dataSeries.axisY.convertValueToPixel(h[0].dataPoint.y) : h[0].dataSeries.axisY.convertValueToPixel(h[0].dataPoint.y);
                                h = -h + 10;
                                0 < h + this.container.clientHeight + 5 && (h -= h + this.container.clientHeight + 5 - 0);
                                this.fixMozTransitionDelay(c, h);
                                !this.animationEnabled || l ? this.disableAnimation() : (this.enableAnimation(), 
                                this.container.style.MozTransition = this.mozContainerTransition);
                                this.container.style.left = c + "px";
                                this.container.style.bottom = h + "px";
                            } else return this.hide(!1), !1;
                        } else return this.hide(), !1;
                        return !0;
                    };
                    V.prototype.fixMozTransitionDelay = function(a, e) {
                        if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition = this.getContainerTransition(0); else {
                            var c = parseFloat(this.container.style.left), b = (c = isNaN(c) ? 0 : c, parseFloat(this.container.style.bottom));
                            b = isNaN(b) ? 0 : b;
                            10 < Math.sqrt(Math.pow(c - a, 2) + Math.pow(b - e, 2)) ? this.mozContainerTransition = this.getContainerTransition(.1) : this.mozContainerTransition = this.getContainerTransition(0);
                        }
                    };
                    V.prototype.getContainerTransition = function(a) {
                        return "left " + a + "s ease-out 0s, bottom " + a + "s ease-out 0s";
                    };
                    $.prototype.reset = function() {
                        this.lastObjectId = 0;
                        this.objectMap = [];
                        this.rectangularRegionEventSubscriptions = [];
                        this.previousDataPointEventObject = null;
                        this.eventObjects = [];
                        v && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath());
                    };
                    $.prototype.getNewObjectTrackingId = function() {
                        return ++this.lastObjectId;
                    };
                    $.prototype.mouseEventHandler = function(a) {
                        if ("mousemove" === a.type || "click" === a.type) {
                            var e = [], c = Qa(a), b = null;
                            if ((b = this.chart.getObjectAtXY(c.x, c.y, !1)) && "undefined" !== typeof this.objectMap[b]) if (b = this.objectMap[b], 
                            "dataPoint" === b.objectType) {
                                var d = this.chart.data[b.dataSeriesIndex], h = d.dataPoints[b.dataPointIndex], l = b.dataPointIndex;
                                b.eventParameter = {
                                    x: c.x,
                                    y: c.y,
                                    dataPoint: h,
                                    dataSeries: d.options,
                                    dataPointIndex: l,
                                    dataSeriesIndex: d.index,
                                    chart: this.chart
                                };
                                b.eventContext = {
                                    context: h,
                                    userContext: h,
                                    mouseover: "mouseover",
                                    mousemove: "mousemove",
                                    mouseout: "mouseout",
                                    click: "click"
                                };
                                e.push(b);
                                b = this.objectMap[d.id];
                                b.eventParameter = {
                                    x: c.x,
                                    y: c.y,
                                    dataPoint: h,
                                    dataSeries: d.options,
                                    dataPointIndex: l,
                                    dataSeriesIndex: d.index,
                                    chart: this.chart
                                };
                                b.eventContext = {
                                    context: d,
                                    userContext: d.options,
                                    mouseover: "mouseover",
                                    mousemove: "mousemove",
                                    mouseout: "mouseout",
                                    click: "click"
                                };
                                e.push(this.objectMap[d.id]);
                            } else "legendItem" === b.objectType && (d = this.chart.data[b.dataSeriesIndex], 
                            h = null !== b.dataPointIndex ? d.dataPoints[b.dataPointIndex] : null, b.eventParameter = {
                                x: c.x,
                                y: c.y,
                                dataSeries: d.options,
                                dataPoint: h,
                                dataPointIndex: b.dataPointIndex,
                                dataSeriesIndex: b.dataSeriesIndex,
                                chart: this.chart
                            }, b.eventContext = {
                                context: this.chart.legend,
                                userContext: this.chart.legend.options,
                                mouseover: "itemmouseover",
                                mousemove: "itemmousemove",
                                mouseout: "itemmouseout",
                                click: "itemclick"
                            }, e.push(b));
                            d = [];
                            for (c = 0; c < this.mouseoveredObjectMaps.length; c++) {
                                h = !0;
                                for (b = 0; b < e.length; b++) if (e[b].id === this.mouseoveredObjectMaps[c].id) {
                                    h = !1;
                                    break;
                                }
                                h ? this.fireEvent(this.mouseoveredObjectMaps[c], "mouseout", a) : d.push(this.mouseoveredObjectMaps[c]);
                            }
                            this.mouseoveredObjectMaps = d;
                            for (c = 0; c < e.length; c++) {
                                d = !1;
                                for (b = 0; b < this.mouseoveredObjectMaps.length; b++) if (e[c].id === this.mouseoveredObjectMaps[b].id) {
                                    d = !0;
                                    break;
                                }
                                d || (this.fireEvent(e[c], "mouseover", a), this.mouseoveredObjectMaps.push(e[c]));
                                "click" === a.type ? this.fireEvent(e[c], "click", a) : "mousemove" === a.type && this.fireEvent(e[c], "mousemove", a);
                            }
                        }
                    };
                    $.prototype.fireEvent = function(a, e, c) {
                        if (a && e) {
                            var b = a.eventParameter, d = a.eventContext, h = a.eventContext.userContext;
                            h && d && h[d[e]] && h[d[e]].call(h, b);
                            "mouseout" !== e ? h.cursor && h.cursor !== c.target.style.cursor && (c.target.style.cursor = h.cursor) : (c.target.style.cursor = this.chart.panEnabled ? "itemmouseout" !== d.mouseout || h.dockInsidePlotArea ? "move" : this.chart._defaultCursor : this.chart._defaultCursor, 
                            delete a.eventParameter, delete a.eventContext);
                            "click" === e && "dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], b);
                            "click" === e && "dataPoint" === a.objectType && this.chart.funnelPyramidClickHandler && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], b);
                        }
                    };
                    ja.prototype.animate = function(a, d, c, b, f) {
                        var h = this;
                        this.chart.isAnimating = !0;
                        f = f || N.easing.linear;
                        c && this.animations.push({
                            startTime: (new Date).getTime() + (a ? a : 0),
                            duration: d,
                            animationCallback: c,
                            onComplete: b
                        });
                        for (a = []; 0 < this.animations.length; ) if (d = this.animations.shift(), c = (new Date).getTime(), 
                        b = 0, d.startTime <= c && (b = f(Math.min(c - d.startTime, d.duration), 0, 1, d.duration), 
                        b = Math.min(b, 1), isNaN(b) || !isFinite(b)) && (b = 1), 1 > b && a.push(d), d.animationCallback(b), 
                        1 <= b && d.onComplete) d.onComplete();
                        this.animations = a;
                        0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, (function() {
                            h.animate.call(h);
                        })) : this.chart.isAnimating = !1;
                    };
                    ja.prototype.cancelAllAnimations = function() {
                        this.animations = [];
                        this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId);
                        this.animationRequestId = null;
                        this.chart.isAnimating = !1;
                    };
                    var N = {
                        yScaleAnimation: function(a, d) {
                            if (0 !== a) {
                                var c = d.dest, b = d.source.canvas, f = d.animationBase;
                                c.drawImage(b, 0, 0, b.width, b.height, 0, f - f * a, c.canvas.width / ma, a * c.canvas.height / ma);
                            }
                        },
                        xScaleAnimation: function(a, d) {
                            if (0 !== a) {
                                var c = d.dest, b = d.source.canvas, f = d.animationBase;
                                c.drawImage(b, 0, 0, b.width, b.height, f - f * a, 0, a * c.canvas.width / ma, c.canvas.height / ma);
                            }
                        },
                        xClipAnimation: function(a, d) {
                            if (0 !== a) {
                                var c = d.dest, b = d.source.canvas;
                                c.save();
                                0 < a && c.drawImage(b, 0, 0, b.width * a, b.height, 0, 0, b.width * a / ma, b.height / ma);
                                c.restore();
                            }
                        },
                        fadeInAnimation: function(a, d) {
                            if (0 !== a) {
                                var c = d.dest, b = d.source.canvas;
                                c.save();
                                c.globalAlpha = a;
                                c.drawImage(b, 0, 0, b.width, b.height, 0, 0, c.canvas.width / ma, c.canvas.height / ma);
                                c.restore();
                            }
                        },
                        easing: {
                            linear: function(a, d, c, b) {
                                return c * a / b + d;
                            },
                            easeOutQuad: function(a, d, c, b) {
                                return -c * (a /= b) * (a - 2) + d;
                            },
                            easeOutQuart: function(a, d, c, b) {
                                return -c * ((a = a / b - 1) * a * a * a - 1) + d;
                            },
                            easeInQuad: function(a, d, c, b) {
                                return c * (a /= b) * a + d;
                            },
                            easeInQuart: function(a, d, c, b) {
                                return c * (a /= b) * a * a * a + d;
                            }
                        }
                    }, W = {
                        drawMarker: function(a, d, c, b, f, h, l, p) {
                            if (c) {
                                var t = 1;
                                c.fillStyle = h ? h : "#000000";
                                c.strokeStyle = l ? l : "#000000";
                                c.lineWidth = p ? p : 0;
                                c.setLineDash && c.setLineDash(H("solid", p));
                                "circle" === b ? (c.moveTo(a, d), c.beginPath(), c.arc(a, d, f / 2, 0, 2 * Math.PI, !1), 
                                h && c.fill(), p && (l ? c.stroke() : (t = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", 
                                c.stroke(), c.globalAlpha = t))) : "square" === b ? (c.beginPath(), c.rect(a - f / 2, d - f / 2, f, f), 
                                h && c.fill(), p && (l ? c.stroke() : (t = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", 
                                c.stroke(), c.globalAlpha = t))) : "triangle" === b ? (c.beginPath(), c.moveTo(a - f / 2, d + f / 2), 
                                c.lineTo(a + f / 2, d + f / 2), c.lineTo(a, d - f / 2), c.closePath(), h && c.fill(), 
                                p && (l ? c.stroke() : (t = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", 
                                c.stroke(), c.globalAlpha = t)), c.beginPath()) : "cross" === b && (c.strokeStyle = h, 
                                c.lineWidth = f / 4, c.beginPath(), c.moveTo(a - f / 2, d - f / 2), c.lineTo(a + f / 2, d + f / 2), 
                                c.stroke(), c.moveTo(a + f / 2, d - f / 2), c.lineTo(a - f / 2, d + f / 2), c.stroke());
                            }
                        },
                        drawMarkers: function(a) {
                            for (var d = 0; d < a.length; d++) {
                                var c = a[d];
                                W.drawMarker(c.x, c.y, c.ctx, c.type, c.size, c.color, c.borderColor, c.borderThickness);
                            }
                        }
                    };
                    return l;
                }();
                B.version = "v3.8 GA";
                window.CanvasJS && B && !window.CanvasJS.Chart && (window.CanvasJS.Chart = B);
            })();
            document.createElement("canvas").getContext || function() {
                function V() {
                    return this.context_ || (this.context_ = new C(this));
                }
                function W(a, b, c) {
                    var g = M.call(arguments, 2);
                    return function() {
                        return a.apply(b, g.concat(M.call(arguments)));
                    };
                }
                function N(a) {
                    return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
                }
                function O(a) {
                    a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML");
                    a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");
                    a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", 
                    a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}");
                }
                function X(a) {
                    var b = a.srcElement;
                    switch (a.propertyName) {
                      case "width":
                        b.getContext().clearRect();
                        b.style.width = b.attributes.width.nodeValue + "px";
                        b.firstChild.style.width = b.clientWidth + "px";
                        break;

                      case "height":
                        b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", 
                        b.firstChild.style.height = b.clientHeight + "px";
                    }
                }
                function Y(a) {
                    a = a.srcElement;
                    a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px");
                }
                function D() {
                    return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
                }
                function t(a, b) {
                    for (var c = D(), g = 0; 3 > g; g++) for (var e = 0; 3 > e; e++) {
                        for (var f = 0, d = 0; 3 > d; d++) f += a[g][d] * b[d][e];
                        c[g][e] = f;
                    }
                    return c;
                }
                function P(a, b) {
                    b.fillStyle = a.fillStyle;
                    b.lineCap = a.lineCap;
                    b.lineJoin = a.lineJoin;
                    b.lineWidth = a.lineWidth;
                    b.miterLimit = a.miterLimit;
                    b.shadowBlur = a.shadowBlur;
                    b.shadowColor = a.shadowColor;
                    b.shadowOffsetX = a.shadowOffsetX;
                    b.shadowOffsetY = a.shadowOffsetY;
                    b.strokeStyle = a.strokeStyle;
                    b.globalAlpha = a.globalAlpha;
                    b.font = a.font;
                    b.textAlign = a.textAlign;
                    b.textBaseline = a.textBaseline;
                    b.arcScaleX_ = a.arcScaleX_;
                    b.arcScaleY_ = a.arcScaleY_;
                    b.lineScale_ = a.lineScale_;
                }
                function Q(a) {
                    var b = a.indexOf("(", 3), c = a.indexOf(")", b + 1);
                    b = a.substring(b + 1, c).split(",");
                    if (4 != b.length || "a" != a.charAt(3)) b[3] = 1;
                    return b;
                }
                function E(a, b, c) {
                    return Math.min(c, Math.max(b, a));
                }
                function F(a, b, c) {
                    0 > c && c++;
                    1 < c && c--;
                    return 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a;
                }
                function G(a) {
                    if (a in H) return H[a];
                    var b, c = 1;
                    a = String(a);
                    if ("#" == a.charAt(0)) b = a; else if (/^rgb/.test(a)) {
                        c = Q(a);
                        b = "#";
                        for (var g, e = 0; 3 > e; e++) g = -1 != c[e].indexOf("%") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], 
                        b += v[E(g, 0, 255)];
                        c = +c[3];
                    } else if (/^hsl/.test(a)) {
                        e = c = Q(a);
                        b = parseFloat(e[0]) / 360 % 360;
                        0 > b && b++;
                        g = E(parseFloat(e[1]) / 100, 0, 1);
                        e = E(parseFloat(e[2]) / 100, 0, 1);
                        if (0 == g) g = e = b = e; else {
                            var f = .5 > e ? e * (1 + g) : e + g - e * g, d = 2 * e - f;
                            g = F(d, f, b + 1 / 3);
                            e = F(d, f, b);
                            b = F(d, f, b - 1 / 3);
                        }
                        b = "#" + v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];
                        c = c[3];
                    } else b = Z[a] || a;
                    return H[a] = {
                        color: b,
                        alpha: c
                    };
                }
                function C(a) {
                    this.m_ = D();
                    this.mStack_ = [];
                    this.aStack_ = [];
                    this.currentPath_ = [];
                    this.fillStyle = this.strokeStyle = "#000";
                    this.lineWidth = 1;
                    this.lineJoin = "miter";
                    this.lineCap = "butt";
                    this.miterLimit = 1 * q;
                    this.globalAlpha = 1;
                    this.font = "10px sans-serif";
                    this.textAlign = "left";
                    this.textBaseline = "alphabetic";
                    this.canvas = a;
                    var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute", c = a.ownerDocument.createElement("div");
                    c.style.cssText = b;
                    a.appendChild(c);
                    b = c.cloneNode(!1);
                    b.style.backgroundColor = "red";
                    b.style.filter = "alpha(opacity=0)";
                    a.appendChild(b);
                    this.element_ = c;
                    this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1;
                }
                function R(a, b, c, g) {
                    a.currentPath_.push({
                        type: "bezierCurveTo",
                        cp1x: b.x,
                        cp1y: b.y,
                        cp2x: c.x,
                        cp2y: c.y,
                        x: g.x,
                        y: g.y
                    });
                    a.currentX_ = g.x;
                    a.currentY_ = g.y;
                }
                function S(a, b) {
                    var c = G(a.strokeStyle), g = c.color, e = (c = c.alpha * a.globalAlpha, a.lineScale_ * a.lineWidth);
                    1 > e && (c *= e);
                    b.push("<g_vml_:stroke", ' opacity="', c, '"', ' joinstyle="', a.lineJoin, '"', ' miterlimit="', a.miterLimit, '"', ' endcap="', $[a.lineCap] || "square", '"', ' weight="', e, 'px"', ' color="', g, '" />');
                }
                function T(a, b, c, g) {
                    var e = a.fillStyle, f = a.arcScaleX_, d = a.arcScaleY_, k = g.x - c.x, n = g.y - c.y;
                    if (e instanceof w) {
                        var h = 0, l = g = 0, u = 0, m = 1;
                        if ("gradient" == e.type_) {
                            h = e.x1_ / f;
                            c = e.y1_ / d;
                            var p = s(a, e.x0_ / f, e.y0_ / d);
                            h = s(a, h, c), h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;
                            0 > h && (h += 360);
                            1e-6 > h && (h = 0);
                        } else p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k, l = (p.y - c.y) / n, k /= f * q, 
                        n /= d * q, m = x.max(k, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;
                        f = e.colors_;
                        f.sort((function(a, b) {
                            return a.offset - b.offset;
                        }));
                        d = f.length;
                        p = f[0].color;
                        c = f[d - 1].color;
                        k = f[0].alpha * a.globalAlpha;
                        a = f[d - 1].alpha * a.globalAlpha;
                        n = [];
                        for (var r = 0; r < d; r++) {
                            var t = f[r];
                            n.push(t.offset * m + u + " " + t.color);
                        }
                        b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', p, '"', ' color2="', c, '"', ' colors="', n.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', k, '"', ' angle="', h, '"', ' focusposition="', g, ",", l, '" />');
                    } else e instanceof I ? k && n && b.push("<g_vml_:fill", ' position="', -c.x / k * f * f, ",", -c.y / n * d * d, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = G(a.fillStyle), 
                    b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />'));
                }
                function s(a, b, c) {
                    a = a.m_;
                    return {
                        x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r,
                        y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r
                    };
                }
                function z(a, b, c) {
                    isFinite(b[0][0]) && isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1]) && (a.m_ = b, 
                    c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] * b[1][0]))));
                }
                function w(a) {
                    this.type_ = a;
                    this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;
                    this.colors_ = [];
                }
                function I(a, b) {
                    if (!a || 1 != a.nodeType || "IMG" != a.tagName) throw new A("TYPE_MISMATCH_ERR");
                    if ("complete" != a.readyState) throw new A("INVALID_STATE_ERR");
                    switch (b) {
                      case "repeat":
                      case null:
                      case "":
                        this.repetition_ = "repeat";
                        break;

                      case "repeat-x":
                      case "repeat-y":
                      case "no-repeat":
                        this.repetition_ = b;
                        break;

                      default:
                        throw new A("SYNTAX_ERR");
                    }
                    this.src_ = a.src;
                    this.width_ = a.width;
                    this.height_ = a.height;
                }
                function A(a) {
                    this.code = this[a];
                    this.message = a + ": DOM Exception " + this.code;
                }
                var x = Math, k = x.round, J = x.sin, K = x.cos, ba = x.abs, aa = x.sqrt, q = 10, r = q / 2;
                navigator.userAgent.match(/MSIE ([\d.]+)?/);
                var M = Array.prototype.slice;
                O(document);
                var U = {
                    init: function(a) {
                        a = a || document;
                        a.createElement("canvas");
                        a.attachEvent("onreadystatechange", W(this.init_, this, a));
                    },
                    init_: function(a) {
                        a = a.getElementsByTagName("canvas");
                        for (var b = 0; b < a.length; b++) this.initElement(a[b]);
                    },
                    initElement: function(a) {
                        if (!a.getContext) {
                            a.getContext = V;
                            O(a.ownerDocument);
                            a.innerHTML = "";
                            a.attachEvent("onpropertychange", X);
                            a.attachEvent("onresize", Y);
                            var b = a.attributes;
                            b.width && b.width.specified ? a.style.width = b.width.nodeValue + "px" : a.width = a.clientWidth;
                            b.height && b.height.specified ? a.style.height = b.height.nodeValue + "px" : a.height = a.clientHeight;
                        }
                        return a;
                    }
                };
                U.init();
                for (var v = [], d = 0; 16 > d; d++) for (var B = 0; 16 > B; B++) v[16 * d + B] = d.toString(16) + B.toString(16);
                var Z = {
                    aliceblue: "#F0F8FF",
                    antiquewhite: "#FAEBD7",
                    aquamarine: "#7FFFD4",
                    azure: "#F0FFFF",
                    beige: "#F5F5DC",
                    bisque: "#FFE4C4",
                    black: "#000000",
                    blanchedalmond: "#FFEBCD",
                    blueviolet: "#8A2BE2",
                    brown: "#A52A2A",
                    burlywood: "#DEB887",
                    cadetblue: "#5F9EA0",
                    chartreuse: "#7FFF00",
                    chocolate: "#D2691E",
                    coral: "#FF7F50",
                    cornflowerblue: "#6495ED",
                    cornsilk: "#FFF8DC",
                    crimson: "#DC143C",
                    cyan: "#00FFFF",
                    darkblue: "#00008B",
                    darkcyan: "#008B8B",
                    darkgoldenrod: "#B8860B",
                    darkgray: "#A9A9A9",
                    darkgreen: "#006400",
                    darkgrey: "#A9A9A9",
                    darkkhaki: "#BDB76B",
                    darkmagenta: "#8B008B",
                    darkolivegreen: "#556B2F",
                    darkorange: "#FF8C00",
                    darkorchid: "#9932CC",
                    darkred: "#8B0000",
                    darksalmon: "#E9967A",
                    darkseagreen: "#8FBC8F",
                    darkslateblue: "#483D8B",
                    darkslategray: "#2F4F4F",
                    darkslategrey: "#2F4F4F",
                    darkturquoise: "#00CED1",
                    darkviolet: "#9400D3",
                    deeppink: "#FF1493",
                    deepskyblue: "#00BFFF",
                    dimgray: "#696969",
                    dimgrey: "#696969",
                    dodgerblue: "#1E90FF",
                    firebrick: "#B22222",
                    floralwhite: "#FFFAF0",
                    forestgreen: "#228B22",
                    gainsboro: "#DCDCDC",
                    ghostwhite: "#F8F8FF",
                    gold: "#FFD700",
                    goldenrod: "#DAA520",
                    grey: "#808080",
                    greenyellow: "#ADFF2F",
                    honeydew: "#F0FFF0",
                    hotpink: "#FF69B4",
                    indianred: "#CD5C5C",
                    indigo: "#4B0082",
                    ivory: "#FFFFF0",
                    khaki: "#F0E68C",
                    lavender: "#E6E6FA",
                    lavenderblush: "#FFF0F5",
                    lawngreen: "#7CFC00",
                    lemonchiffon: "#FFFACD",
                    lightblue: "#ADD8E6",
                    lightcoral: "#F08080",
                    lightcyan: "#E0FFFF",
                    lightgoldenrodyellow: "#FAFAD2",
                    lightgreen: "#90EE90",
                    lightgrey: "#D3D3D3",
                    lightpink: "#FFB6C1",
                    lightsalmon: "#FFA07A",
                    lightseagreen: "#20B2AA",
                    lightskyblue: "#87CEFA",
                    lightslategray: "#778899",
                    lightslategrey: "#778899",
                    lightsteelblue: "#B0C4DE",
                    lightyellow: "#FFFFE0",
                    limegreen: "#32CD32",
                    linen: "#FAF0E6",
                    magenta: "#FF00FF",
                    mediumaquamarine: "#66CDAA",
                    mediumblue: "#0000CD",
                    mediumorchid: "#BA55D3",
                    mediumpurple: "#9370DB",
                    mediumseagreen: "#3CB371",
                    mediumslateblue: "#7B68EE",
                    mediumspringgreen: "#00FA9A",
                    mediumturquoise: "#48D1CC",
                    mediumvioletred: "#C71585",
                    midnightblue: "#191970",
                    mintcream: "#F5FFFA",
                    mistyrose: "#FFE4E1",
                    moccasin: "#FFE4B5",
                    navajowhite: "#FFDEAD",
                    oldlace: "#FDF5E6",
                    olivedrab: "#6B8E23",
                    orange: "#FFA500",
                    orangered: "#FF4500",
                    orchid: "#DA70D6",
                    palegoldenrod: "#EEE8AA",
                    palegreen: "#98FB98",
                    paleturquoise: "#AFEEEE",
                    palevioletred: "#DB7093",
                    papayawhip: "#FFEFD5",
                    peachpuff: "#FFDAB9",
                    peru: "#CD853F",
                    pink: "#FFC0CB",
                    plum: "#DDA0DD",
                    powderblue: "#B0E0E6",
                    rosybrown: "#BC8F8F",
                    royalblue: "#4169E1",
                    saddlebrown: "#8B4513",
                    salmon: "#FA8072",
                    sandybrown: "#F4A460",
                    seagreen: "#2E8B57",
                    seashell: "#FFF5EE",
                    sienna: "#A0522D",
                    skyblue: "#87CEEB",
                    slateblue: "#6A5ACD",
                    slategray: "#708090",
                    slategrey: "#708090",
                    snow: "#FFFAFA",
                    springgreen: "#00FF7F",
                    steelblue: "#4682B4",
                    tan: "#D2B48C",
                    thistle: "#D8BFD8",
                    tomato: "#FF6347",
                    turquoise: "#40E0D0",
                    violet: "#EE82EE",
                    wheat: "#F5DEB3",
                    whitesmoke: "#F5F5F5",
                    yellowgreen: "#9ACD32"
                }, H = {}, L = {}, $ = {
                    butt: "flat",
                    round: "round"
                };
                d = C.prototype;
                d.clearRect = function() {
                    this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null);
                    this.element_.innerHTML = "";
                };
                d.beginPath = function() {
                    this.currentPath_ = [];
                };
                d.moveTo = function(a, b) {
                    var c = s(this, a, b);
                    this.currentPath_.push({
                        type: "moveTo",
                        x: c.x,
                        y: c.y
                    });
                    this.currentX_ = c.x;
                    this.currentY_ = c.y;
                };
                d.lineTo = function(a, b) {
                    var c = s(this, a, b);
                    this.currentPath_.push({
                        type: "lineTo",
                        x: c.x,
                        y: c.y
                    });
                    this.currentX_ = c.x;
                    this.currentY_ = c.y;
                };
                d.bezierCurveTo = function(a, b, c, g, e, f) {
                    e = s(this, e, f);
                    a = s(this, a, b);
                    c = s(this, c, g);
                    R(this, a, c, e);
                };
                d.quadraticCurveTo = function(a, b, c, g) {
                    a = s(this, a, b);
                    c = s(this, c, g);
                    g = {
                        x: this.currentX_ + 2 / 3 * (a.x - this.currentX_),
                        y: this.currentY_ + 2 / 3 * (a.y - this.currentY_)
                    };
                    R(this, g, {
                        x: g.x + (c.x - this.currentX_) / 3,
                        y: g.y + (c.y - this.currentY_) / 3
                    }, c);
                };
                d.arc = function(a, b, c, g, e, f) {
                    c *= q;
                    var d = f ? "at" : "wa", k = a + K(g) * c - r, n = b + J(g) * c - r;
                    g = a + K(e) * c - r;
                    e = b + J(e) * c - r;
                    k != g || f || (k += .125);
                    a = s(this, a, b);
                    k = s(this, k, n);
                    g = s(this, g, e);
                    this.currentPath_.push({
                        type: d,
                        x: a.x,
                        y: a.y,
                        radius: c,
                        xStart: k.x,
                        yStart: k.y,
                        xEnd: g.x,
                        yEnd: g.y
                    });
                };
                d.rect = function(a, b, c, g) {
                    this.moveTo(a, b);
                    this.lineTo(a + c, b);
                    this.lineTo(a + c, b + g);
                    this.lineTo(a, b + g);
                    this.closePath();
                };
                d.strokeRect = function(a, b, c, g) {
                    var e = this.currentPath_;
                    this.beginPath();
                    this.moveTo(a, b);
                    this.lineTo(a + c, b);
                    this.lineTo(a + c, b + g);
                    this.lineTo(a, b + g);
                    this.closePath();
                    this.stroke();
                    this.currentPath_ = e;
                };
                d.fillRect = function(a, b, c, g) {
                    var e = this.currentPath_;
                    this.beginPath();
                    this.moveTo(a, b);
                    this.lineTo(a + c, b);
                    this.lineTo(a + c, b + g);
                    this.lineTo(a, b + g);
                    this.closePath();
                    this.fill();
                    this.currentPath_ = e;
                };
                d.createLinearGradient = function(a, b, c, g) {
                    var e = new w("gradient");
                    e.x0_ = a;
                    e.y0_ = b;
                    e.x1_ = c;
                    e.y1_ = g;
                    return e;
                };
                d.createRadialGradient = function(a, b, c, g, e, f) {
                    var d = new w("gradientradial");
                    d.x0_ = a;
                    d.y0_ = b;
                    d.r0_ = c;
                    d.x1_ = g;
                    d.y1_ = e;
                    d.r1_ = f;
                    return d;
                };
                d.drawImage = function(a, b) {
                    var c, g, e, d, r, y, n, h;
                    e = a.runtimeStyle.width;
                    d = a.runtimeStyle.height;
                    a.runtimeStyle.width = "auto";
                    a.runtimeStyle.height = "auto";
                    var l = a.width, u = a.height;
                    a.runtimeStyle.width = e;
                    a.runtimeStyle.height = d;
                    if (3 == arguments.length) c = arguments[1], g = arguments[2], r = y = 0, n = e = l, 
                    h = d = u; else if (5 == arguments.length) c = arguments[1], g = arguments[2], e = arguments[3], 
                    d = arguments[4], r = y = 0, n = l, h = u; else if (9 == arguments.length) r = arguments[1], 
                    y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], 
                    e = arguments[7], d = arguments[8]; else throw Error("Invalid number of arguments");
                    var m = s(this, c, g), p = [];
                    p.push(" <g_vml_:group", ' coordsize="', 10 * q, ",", 10 * q, '"', ' coordorigin="0,0"', ' style="width:', 10, "px;height:", 10, "px;position:absolute;");
                    if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
                        var t = [];
                        t.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k(m.x / q), ",", "Dy=", k(m.y / q), "");
                        var v = s(this, c + e, g), w = s(this, c, g + d);
                        c = s(this, c + e, g + d);
                        m.x = x.max(m.x, v.x, w.x, c.x);
                        m.y = x.max(m.y, v.y, w.y, c.y);
                        p.push("padding:0 ", k(m.x / q), "px ", k(m.y / q), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", t.join(""), ", sizingmethod='clip');");
                    } else p.push("top:", k(m.y / q), "px;left:", k(m.x / q), "px;");
                    p.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', q * e, "px;", " height:", q * d, 'px"', ' cropleft="', r / l, '"', ' croptop="', y / u, '"', ' cropright="', (l - r - n) / l, '"', ' cropbottom="', (u - y - h) / u, '"', " />", "</g_vml_:group>");
                    this.element_.insertAdjacentHTML("BeforeEnd", p.join(""));
                };
                d.stroke = function(a) {
                    var b = [];
                    b.push("<g_vml_:shape", ' filled="', !!a, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0,0"', ' coordsize="', 10 * q, ",", 10 * q, '"', ' stroked="', !a, '"', ' path="');
                    for (var c = {
                        x: null,
                        y: null
                    }, d = {
                        x: null,
                        y: null
                    }, e = 0; e < this.currentPath_.length; e++) {
                        var f = this.currentPath_[e];
                        switch (f.type) {
                          case "moveTo":
                            b.push(" m ", k(f.x), ",", k(f.y));
                            break;

                          case "lineTo":
                            b.push(" l ", k(f.x), ",", k(f.y));
                            break;

                          case "close":
                            b.push(" x ");
                            f = null;
                            break;

                          case "bezierCurveTo":
                            b.push(" c ", k(f.cp1x), ",", k(f.cp1y), ",", k(f.cp2x), ",", k(f.cp2y), ",", k(f.x), ",", k(f.y));
                            break;

                          case "at":
                          case "wa":
                            b.push(" ", f.type, " ", k(f.x - this.arcScaleX_ * f.radius), ",", k(f.y - this.arcScaleY_ * f.radius), " ", k(f.x + this.arcScaleX_ * f.radius), ",", k(f.y + this.arcScaleY_ * f.radius), " ", k(f.xStart), ",", k(f.yStart), " ", k(f.xEnd), ",", k(f.yEnd));
                        }
                        if (f) {
                            if (null == c.x || f.x < c.x) c.x = f.x;
                            if (null == d.x || f.x > d.x) d.x = f.x;
                            if (null == c.y || f.y < c.y) c.y = f.y;
                            if (null == d.y || f.y > d.y) d.y = f.y;
                        }
                    }
                    b.push(' ">');
                    a ? T(this, b, c, d) : S(this, b);
                    b.push("</g_vml_:shape>");
                    this.element_.insertAdjacentHTML("beforeEnd", b.join(""));
                };
                d.fill = function() {
                    this.stroke(!0);
                };
                d.closePath = function() {
                    this.currentPath_.push({
                        type: "close"
                    });
                };
                d.save = function() {
                    var a = {};
                    P(this, a);
                    this.aStack_.push(a);
                    this.mStack_.push(this.m_);
                    this.m_ = t(D(), this.m_);
                };
                d.restore = function() {
                    this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop());
                };
                d.translate = function(a, b) {
                    z(this, t([ [ 1, 0, 0 ], [ 0, 1, 0 ], [ a, b, 1 ] ], this.m_), !1);
                };
                d.rotate = function(a) {
                    var b = K(a);
                    a = J(a);
                    z(this, t([ [ b, a, 0 ], [ -a, b, 0 ], [ 0, 0, 1 ] ], this.m_), !1);
                };
                d.scale = function(a, b) {
                    this.arcScaleX_ *= a;
                    this.arcScaleY_ *= b;
                    z(this, t([ [ a, 0, 0 ], [ 0, b, 0 ], [ 0, 0, 1 ] ], this.m_), !0);
                };
                d.transform = function(a, b, c, d, e, f) {
                    z(this, t([ [ a, b, 0 ], [ c, d, 0 ], [ e, f, 1 ] ], this.m_), !0);
                };
                d.setTransform = function(a, b, c, d, e, f) {
                    z(this, [ [ a, b, 0 ], [ c, d, 0 ], [ e, f, 1 ] ], !0);
                };
                d.drawText_ = function(a, b, c, d, e) {
                    var f = this.m_;
                    d = 0;
                    var h, r = 1e3, t = 0, n = [];
                    h = this.font;
                    if (L[h]) h = L[h]; else {
                        var l = document.createElement("div").style;
                        try {
                            l.font = h;
                        } catch (u) {}
                        h = L[h] = {
                            style: l.fontStyle || "normal",
                            variant: l.fontVariant || "normal",
                            weight: l.fontWeight || "normal",
                            size: l.fontSize || 10,
                            family: l.fontFamily || "sans-serif"
                        };
                    }
                    l = h;
                    var m = this.element_;
                    h = {};
                    for (var p in l) h[p] = l[p];
                    p = parseFloat(m.currentStyle.fontSize);
                    m = parseFloat(l.size);
                    "number" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf("px") ? h.size = m : -1 != l.size.indexOf("em") ? h.size = p * m : -1 != l.size.indexOf("%") ? h.size = p / 100 * m : -1 != l.size.indexOf("pt") ? h.size = m / .75 : h.size = p;
                    h.size *= .981;
                    p = h.style + " " + h.variant + " " + h.weight + " " + h.size + "px " + h.family;
                    m = this.element_.currentStyle;
                    l = this.textAlign.toLowerCase();
                    switch (l) {
                      case "left":
                      case "center":
                      case "right":
                        break;

                      case "end":
                        l = "ltr" == m.direction ? "right" : "left";
                        break;

                      case "start":
                        l = "rtl" == m.direction ? "right" : "left";
                        break;

                      default:
                        l = "left";
                    }
                    switch (this.textBaseline) {
                      case "hanging":
                      case "top":
                        t = h.size / 1.75;
                        break;

                      case "middle":
                        break;

                      default:
                      case null:
                      case "alphabetic":
                      case "ideographic":
                      case "bottom":
                        t = -h.size / 2.25;
                    }
                    switch (l) {
                      case "right":
                        d = 1e3;
                        r = .05;
                        break;

                      case "center":
                        d = r = 500;
                    }
                    b = s(this, b + 0, c + t);
                    n.push('<g_vml_:line from="', -d, ' 0" to="', r, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !e, '" stroked="', !!e, '" style="position:absolute;width:1px;height:1px;">');
                    e ? S(this, n) : T(this, n, {
                        x: -d,
                        y: 0
                    }, {
                        x: r,
                        y: h.size
                    });
                    e = f[0][0].toFixed(3) + "," + f[1][0].toFixed(3) + "," + f[0][1].toFixed(3) + "," + f[1][1].toFixed(3) + ",0,0";
                    b = k(b.x / q) + "," + k(b.y / q);
                    n.push('<g_vml_:skew on="t" matrix="', e, '" ', ' offset="', b, '" origin="', d, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', N(a), '" style="v-text-align:', l, ";font:", N(p), '" /></g_vml_:line>');
                    this.element_.insertAdjacentHTML("beforeEnd", n.join(""));
                };
                d.fillText = function(a, b, c, d) {
                    this.drawText_(a, b, c, d, !1);
                };
                d.strokeText = function(a, b, c, d) {
                    this.drawText_(a, b, c, d, !0);
                };
                d.measureText = function(a) {
                    this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), 
                    this.textMeasureEl_ = this.element_.lastChild);
                    var b = this.element_.ownerDocument;
                    this.textMeasureEl_.innerHTML = "";
                    this.textMeasureEl_.style.font = this.font;
                    this.textMeasureEl_.appendChild(b.createTextNode(a));
                    return {
                        width: this.textMeasureEl_.offsetWidth
                    };
                };
                d.clip = function() {};
                d.arcTo = function() {};
                d.createPattern = function(a, b) {
                    return new I(a, b);
                };
                w.prototype.addColorStop = function(a, b) {
                    b = G(b);
                    this.colors_.push({
                        offset: a,
                        color: b.color,
                        alpha: b.alpha
                    });
                };
                d = A.prototype = Error();
                d.INDEX_SIZE_ERR = 1;
                d.DOMSTRING_SIZE_ERR = 2;
                d.HIERARCHY_REQUEST_ERR = 3;
                d.WRONG_DOCUMENT_ERR = 4;
                d.INVALID_CHARACTER_ERR = 5;
                d.NO_DATA_ALLOWED_ERR = 6;
                d.NO_MODIFICATION_ALLOWED_ERR = 7;
                d.NOT_FOUND_ERR = 8;
                d.NOT_SUPPORTED_ERR = 9;
                d.INUSE_ATTRIBUTE_ERR = 10;
                d.INVALID_STATE_ERR = 11;
                d.SYNTAX_ERR = 12;
                d.INVALID_MODIFICATION_ERR = 13;
                d.NAMESPACE_ERR = 14;
                d.INVALID_ACCESS_ERR = 15;
                d.VALIDATION_ERR = 16;
                d.TYPE_MISMATCH_ERR = 17;
                G_vmlCanvasManager = U;
                CanvasRenderingContext2D = C;
                CanvasGradient = w;
                CanvasPattern = I;
                DOMException = A;
            }();
        },
        792: function(module) {
            !function(e, t) {
                true ? module.exports = t() : 0;
            }(0, (function() {
                return function() {
                    "use strict";
                    var e = {
                        d: function(t, i) {
                            for (var s in i) e.o(i, s) && !e.o(t, s) && Object.defineProperty(t, s, {
                                enumerable: !0,
                                get: i[s]
                            });
                        },
                        o: function(e, t) {
                            return Object.prototype.hasOwnProperty.call(e, t);
                        }
                    }, t = {};
                    e.d(t, {
                        default: function() {
                            return R;
                        }
                    });
                    var i = {
                        days: "days",
                        months: "months",
                        years: "years",
                        day: "day",
                        month: "month",
                        year: "year",
                        eventChangeViewDate: "changeViewDate",
                        eventChangeCurrentView: "changeCurrentView",
                        eventChangeFocusDate: "changeFocusDate",
                        eventChangeSelectedDate: "changeSelectedDate",
                        eventChangeTime: "changeTime",
                        eventChangeLastSelectedDate: "changeLastSelectedDate",
                        actionSelectDate: "selectDate",
                        actionUnselectDate: "unselectDate",
                        cssClassWeekend: "-weekend-"
                    }, s = {
                        classes: "",
                        inline: !1,
                        locale: {
                            days: [ "Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота" ],
                            daysShort: [ "Вос", "Пон", "Вто", "Сре", "Чет", "Пят", "Суб" ],
                            daysMin: [ "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб" ],
                            months: [ "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь" ],
                            monthsShort: [ "Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек" ],
                            today: "Сегодня",
                            clear: "Очистить",
                            dateFormat: "dd.MM.yyyy",
                            timeFormat: "HH:mm",
                            firstDay: 1
                        },
                        startDate: new Date,
                        firstDay: "",
                        weekends: [ 6, 0 ],
                        dateFormat: "",
                        altField: "",
                        altFieldDateFormat: "T",
                        toggleSelected: !0,
                        keyboardNav: !0,
                        selectedDates: !1,
                        container: "",
                        isMobile: !1,
                        visible: !1,
                        position: "bottom left",
                        offset: 12,
                        view: i.days,
                        minView: i.days,
                        showOtherMonths: !0,
                        selectOtherMonths: !0,
                        moveToOtherMonthsOnSelect: !0,
                        showOtherYears: !0,
                        selectOtherYears: !0,
                        moveToOtherYearsOnSelect: !0,
                        minDate: "",
                        maxDate: "",
                        disableNavWhenOutOfRange: !0,
                        multipleDates: !1,
                        multipleDatesSeparator: ", ",
                        range: !1,
                        dynamicRange: !0,
                        buttons: !1,
                        monthsField: "monthsShort",
                        showEvent: "focus",
                        autoClose: !1,
                        fixedHeight: !1,
                        prevHtml: '<svg><path d="M 17,12 l -5,5 l 5,5"></path></svg>',
                        nextHtml: '<svg><path d="M 14,12 l 5,5 l -5,5"></path></svg>',
                        navTitles: {
                            days: "MMMM, <i>yyyy</i>",
                            months: "yyyy",
                            years: "yyyy1 - yyyy2"
                        },
                        timepicker: !1,
                        onlyTimepicker: !1,
                        dateTimeSeparator: " ",
                        timeFormat: "",
                        minHours: 0,
                        maxHours: 24,
                        minMinutes: 0,
                        maxMinutes: 59,
                        hoursStep: 1,
                        minutesStep: 1,
                        onSelect: !1,
                        onChangeViewDate: !1,
                        onChangeView: !1,
                        onRenderCell: !1,
                        onShow: !1,
                        onHide: !1,
                        onClickDayName: !1
                    };
                    function a(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
                        return "string" == typeof e ? t.querySelector(e) : e;
                    }
                    function n() {
                        let {tagName: e = "div", className: t = "", innerHtml: i = "", id: s = "", attrs: a = {}} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = document.createElement(e);
                        return t && n.classList.add(...t.split(" ")), s && (n.id = s), i && (n.innerHTML = i), 
                        a && r(n, a), n;
                    }
                    function r(e, t) {
                        for (let [i, s] of Object.entries(t)) void 0 !== s && e.setAttribute(i, s);
                        return e;
                    }
                    function o(e) {
                        return new Date(e.getFullYear(), e.getMonth() + 1, 0).getDate();
                    }
                    function h(e) {
                        let t = e.getHours(), {hours: i, dayPeriod: s} = l(t);
                        return {
                            year: e.getFullYear(),
                            month: e.getMonth(),
                            fullMonth: e.getMonth() + 1 < 10 ? "0" + (e.getMonth() + 1) : e.getMonth() + 1,
                            date: e.getDate(),
                            fullDate: e.getDate() < 10 ? "0" + e.getDate() : e.getDate(),
                            day: e.getDay(),
                            hours: t,
                            fullHours: d(t),
                            hours12: i,
                            dayPeriod: s,
                            fullHours12: d(i),
                            minutes: e.getMinutes(),
                            fullMinutes: e.getMinutes() < 10 ? "0" + e.getMinutes() : e.getMinutes()
                        };
                    }
                    function l(e) {
                        return {
                            dayPeriod: e > 11 ? "pm" : "am",
                            hours: e % 12 == 0 ? 12 : e % 12
                        };
                    }
                    function d(e) {
                        return e < 10 ? "0" + e : e;
                    }
                    function c(e) {
                        let t = 10 * Math.floor(e.getFullYear() / 10);
                        return [ t, t + 9 ];
                    }
                    function u() {
                        let e = [];
                        for (var t = arguments.length, i = new Array(t), s = 0; s < t; s++) i[s] = arguments[s];
                        return i.forEach((t => {
                            if ("object" == typeof t) for (let i in t) t[i] && e.push(i); else t && e.push(t);
                        })), e.join(" ");
                    }
                    function p(e, t) {
                        let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.days;
                        if (!e || !t) return !1;
                        let a = h(e), n = h(t);
                        return {
                            [i.days]: a.date === n.date && a.month === n.month && a.year === n.year,
                            [i.months]: a.month === n.month && a.year === n.year,
                            [i.years]: a.year === n.year
                        }[s];
                    }
                    function m(e, t, i) {
                        let s = g(e, !1).getTime(), a = g(t, !1).getTime();
                        return i ? s >= a : s > a;
                    }
                    function v(e, t) {
                        return !m(e, t, !0);
                    }
                    function g(e) {
                        let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = new Date(e.getTime());
                        return "boolean" != typeof t || t || function(e) {
                            e.setHours(0, 0, 0, 0);
                        }(i), i;
                    }
                    function D(e, t, i) {
                        e.length ? e.forEach((e => {
                            e.addEventListener(t, i);
                        })) : e.addEventListener(t, i);
                    }
                    function y(e, t) {
                        return !(!e || e === document || e instanceof DocumentFragment) && (e.matches(t) ? e : y(e.parentNode, t));
                    }
                    function f(e, t, i) {
                        return e > i ? i : e < t ? t : e;
                    }
                    function w(e) {
                        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) i[s - 1] = arguments[s];
                        return i.filter((e => e)).forEach((t => {
                            for (let [i, s] of Object.entries(t)) if (void 0 !== s && "[object Object]" === s.toString()) {
                                let t = void 0 !== e[i] ? e[i].toString() : void 0, a = s.toString(), n = Array.isArray(s) ? [] : {};
                                e[i] = e[i] ? t !== a ? n : e[i] : n, w(e[i], s);
                            } else e[i] = s;
                        })), e;
                    }
                    function b(e) {
                        let t = e;
                        return e instanceof Date || ("string" == typeof e && /^\d{4}-\d{2}-\d{2}$/.test(e) && (e += "T00:00:00"), 
                        t = new Date(e)), isNaN(t.getTime()) && (console.log(`Unable to convert value "${e}" to Date object`), 
                        t = !1), t;
                    }
                    function k(e) {
                        let t = "\\s|\\.|-|/|\\\\|,|\\$|\\!|\\?|:|;";
                        return new RegExp("(^|>|" + t + ")(" + e + ")($|<|" + t + ")", "g");
                    }
                    function $(e, t, i) {
                        return (t = function(e) {
                            var t = function(e, t) {
                                if ("object" != typeof e || null === e) return e;
                                var i = e[Symbol.toPrimitive];
                                if (void 0 !== i) {
                                    var s = i.call(e, "string");
                                    if ("object" != typeof s) return s;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e);
                            }(e);
                            return "symbol" == typeof t ? t : String(t);
                        }(t)) in e ? Object.defineProperty(e, t, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = i, e;
                    }
                    class C {
                        constructor() {
                            let {type: e, date: t, dp: i, opts: s, body: a} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            $(this, "focus", (() => {
                                this.$cell.classList.add("-focus-"), this.focused = !0;
                            })), $(this, "removeFocus", (() => {
                                this.$cell.classList.remove("-focus-"), this.focused = !1;
                            })), $(this, "select", (() => {
                                this.$cell.classList.add("-selected-"), this.selected = !0;
                            })), $(this, "removeSelect", (() => {
                                this.$cell.classList.remove("-selected-", "-range-from-", "-range-to-"), this.selected = !1;
                            })), $(this, "onChangeSelectedDate", (() => {
                                this.isDisabled || (this._handleSelectedStatus(), this.opts.range && this._handleRangeStatus());
                            })), $(this, "onChangeFocusDate", (e => {
                                if (!e) return void (this.focused && this.removeFocus());
                                let t = p(e, this.date, this.type);
                                t ? this.focus() : !t && this.focused && this.removeFocus(), this.opts.range && this._handleRangeStatus();
                            })), $(this, "render", (() => (this.$cell.innerHTML = this._getHtml(), this._handleClasses(), 
                            this.$cell))), this.type = e, this.singleType = this.type.slice(0, -1), this.date = t, 
                            this.dp = i, this.opts = s, this.body = a, this.customData = !1, this.init();
                        }
                        init() {
                            var e;
                            let {onRenderCell: t} = this.opts;
                            t && (this.customData = t({
                                date: this.date,
                                cellType: this.singleType,
                                datepicker: this.dp
                            })), this._createElement(), this._bindDatepickerEvents(), null !== (e = this.customData) && void 0 !== e && e.disabled && this.dp.disableDate(this.date);
                        }
                        _bindDatepickerEvents() {
                            this.dp.on(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.on(i.eventChangeFocusDate, this.onChangeFocusDate);
                        }
                        unbindDatepickerEvents() {
                            this.dp.off(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.off(i.eventChangeFocusDate, this.onChangeFocusDate);
                        }
                        _createElement() {
                            var e;
                            let {year: t, month: i, date: s} = h(this.date), a = (null === (e = this.customData) || void 0 === e ? void 0 : e.attrs) || {};
                            this.$cell = n({
                                attrs: {
                                    "data-year": t,
                                    "data-month": i,
                                    "data-date": s,
                                    ...a
                                }
                            }), this.$cell.adpCell = this;
                        }
                        _getClassName() {
                            var e;
                            let t = new Date, {selectOtherMonths: s, selectOtherYears: a} = this.opts, {minDate: n, maxDate: r, isDateDisabled: o} = this.dp, {day: l} = h(this.date), d = this._isOutOfMinMaxRange(), c = o(this.date), m = u("air-datepicker-cell", `-${this.singleType}-`, {
                                "-current-": p(t, this.date, this.type),
                                "-min-date-": n && p(n, this.date, this.type),
                                "-max-date-": r && p(r, this.date, this.type)
                            }), v = "";
                            switch (this.type) {
                              case i.days:
                                v = u({
                                    "-weekend-": this.dp.isWeekend(l),
                                    "-other-month-": this.isOtherMonth,
                                    "-disabled-": this.isOtherMonth && !s || d || c
                                });
                                break;

                              case i.months:
                                v = u({
                                    "-disabled-": d
                                });
                                break;

                              case i.years:
                                v = u({
                                    "-other-decade-": this.isOtherDecade,
                                    "-disabled-": d || this.isOtherDecade && !a
                                });
                            }
                            return u(m, v, null === (e = this.customData) || void 0 === e ? void 0 : e.classes).split(" ");
                        }
                        _getHtml() {
                            var e;
                            let {year: t, month: s, date: a} = h(this.date), {showOtherMonths: n, showOtherYears: r} = this.opts;
                            if (null !== (e = this.customData) && void 0 !== e && e.html) return this.customData.html;
                            switch (this.type) {
                              case i.days:
                                return !n && this.isOtherMonth ? "" : a;

                              case i.months:
                                return this.dp.locale[this.opts.monthsField][s];

                              case i.years:
                                return !r && this.isOtherDecade ? "" : t;
                            }
                        }
                        _isOutOfMinMaxRange() {
                            let {minDate: e, maxDate: t} = this.dp, {type: s, date: a} = this, {month: n, year: r, date: o} = h(a), l = s === i.days, d = s === i.years, c = !!e && new Date(r, d ? e.getMonth() : n, l ? o : e.getDate()), u = !!t && new Date(r, d ? t.getMonth() : n, l ? o : t.getDate());
                            return e && t ? v(c, e) || m(u, t) : e ? v(c, e) : t ? m(u, t) : void 0;
                        }
                        destroy() {
                            this.unbindDatepickerEvents();
                        }
                        _handleRangeStatus() {
                            const {selectedDates: e, focusDate: t, rangeDateTo: i, rangeDateFrom: s} = this.dp, a = e.length;
                            if (!a) return;
                            let n = s, r = i;
                            if (1 === a && t) {
                                const i = m(t, e[0]);
                                n = i ? e[0] : t, r = i ? t : e[0];
                            }
                            let o = u({
                                "-in-range-": n && r && (h = this.date, l = n, d = r, m(h, l) && v(h, d)),
                                "-range-from-": n && p(this.date, n, this.type),
                                "-range-to-": r && p(this.date, r, this.type)
                            });
                            var h, l, d;
                            this.$cell.classList.remove("-range-from-", "-range-to-", "-in-range-"), o && this.$cell.classList.add(...o.split(" "));
                        }
                        _handleSelectedStatus() {
                            let e = this.dp._checkIfDateIsSelected(this.date, this.type);
                            e ? this.select() : !e && this.selected && this.removeSelect();
                        }
                        _handleInitialFocusStatus() {
                            p(this.dp.focusDate, this.date, this.type) && this.focus();
                        }
                        _handleClasses() {
                            this.$cell.setAttribute("class", ""), this._handleInitialFocusStatus(), this.dp.hasSelectedDates && (this._handleSelectedStatus(), 
                            this.dp.opts.range && this._handleRangeStatus()), this.$cell.classList.add(...this._getClassName());
                        }
                        get isDisabled() {
                            return this.$cell.matches(".-disabled-");
                        }
                        get isOtherMonth() {
                            return this.dp.isOtherMonth(this.date);
                        }
                        get isOtherDecade() {
                            return this.dp.isOtherDecade(this.date);
                        }
                    }
                    function _(e, t, i) {
                        return (t = function(e) {
                            var t = function(e, t) {
                                if ("object" != typeof e || null === e) return e;
                                var i = e[Symbol.toPrimitive];
                                if (void 0 !== i) {
                                    var s = i.call(e, "string");
                                    if ("object" != typeof s) return s;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e);
                            }(e);
                            return "symbol" == typeof t ? t : String(t);
                        }(t)) in e ? Object.defineProperty(e, t, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = i, e;
                    }
                    let M = {
                        [i.days]: `<div class="air-datepicker-body--day-names"></div><div class="air-datepicker-body--cells -${i.days}-"></div>`,
                        [i.months]: `<div class="air-datepicker-body--cells -${i.months}-"></div>`,
                        [i.years]: `<div class="air-datepicker-body--cells -${i.years}-"></div>`
                    };
                    const S = ".air-datepicker-cell";
                    class T {
                        constructor(e) {
                            let {dp: t, type: s, opts: a} = e;
                            _(this, "handleClick", (e => {
                                let t = e.target.closest(S).adpCell;
                                if (t.isDisabled) return;
                                if (!this.dp.isMinViewReached) return void this.dp.down();
                                let i = this.dp._checkIfDateIsSelected(t.date, t.type);
                                i ? this.dp._handleAlreadySelectedDates(i, t.date) : this.dp.selectDate(t.date);
                            })), _(this, "handleDayNameClick", (e => {
                                let t = e.target.getAttribute("data-day-index");
                                this.opts.onClickDayName({
                                    dayIndex: Number(t),
                                    datepicker: this.dp
                                });
                            })), _(this, "onChangeCurrentView", (e => {
                                e !== this.type ? this.hide() : (this.show(), this.render());
                            })), _(this, "onMouseOverCell", (e => {
                                let t = y(e.target, S);
                                this.dp.setFocusDate(!!t && t.adpCell.date);
                            })), _(this, "onMouseOutCell", (() => {
                                this.dp.setFocusDate(!1);
                            })), _(this, "onClickBody", (e => {
                                let {onClickDayName: t} = this.opts, i = e.target;
                                i.closest(S) && this.handleClick(e), t && i.closest(".air-datepicker-body--day-name") && this.handleDayNameClick(e);
                            })), _(this, "onMouseDown", (e => {
                                this.pressed = !0;
                                let t = y(e.target, S), i = t && t.adpCell;
                                p(i.date, this.dp.rangeDateFrom) && (this.rangeFromFocused = !0), p(i.date, this.dp.rangeDateTo) && (this.rangeToFocused = !0);
                            })), _(this, "onMouseMove", (e => {
                                if (!this.pressed || !this.dp.isMinViewReached) return;
                                e.preventDefault();
                                let t = y(e.target, S), i = t && t.adpCell, {selectedDates: s, rangeDateTo: a, rangeDateFrom: n} = this.dp;
                                if (!i || i.isDisabled) return;
                                let {date: r} = i;
                                if (2 === s.length) {
                                    if (this.rangeFromFocused && !m(r, a)) {
                                        let {hours: e, minutes: t} = h(n);
                                        r.setHours(e), r.setMinutes(t), this.dp.rangeDateFrom = r, this.dp.replaceDate(n, r);
                                    }
                                    if (this.rangeToFocused && !v(r, n)) {
                                        let {hours: e, minutes: t} = h(a);
                                        r.setHours(e), r.setMinutes(t), this.dp.rangeDateTo = r, this.dp.replaceDate(a, r);
                                    }
                                }
                            })), _(this, "onMouseUp", (() => {
                                this.pressed = !1, this.rangeFromFocused = !1, this.rangeToFocused = !1;
                            })), _(this, "onChangeViewDate", ((e, t) => {
                                if (!this.isVisible) return;
                                let s = c(e), a = c(t);
                                switch (this.dp.currentView) {
                                  case i.days:
                                    if (p(e, t, i.months)) return;
                                    break;

                                  case i.months:
                                    if (p(e, t, i.years)) return;
                                    break;

                                  case i.years:
                                    if (s[0] === a[0] && s[1] === a[1]) return;
                                }
                                this.render();
                            })), _(this, "render", (() => {
                                this.destroyCells(), this._generateCells(), this.cells.forEach((e => {
                                    this.$cells.appendChild(e.render());
                                }));
                            })), this.dp = t, this.type = s, this.opts = a, this.cells = [], this.$el = "", 
                            this.pressed = !1, this.isVisible = !0, this.init();
                        }
                        init() {
                            this._buildBaseHtml(), this.type === i.days && this.renderDayNames(), this.render(), 
                            this._bindEvents(), this._bindDatepickerEvents();
                        }
                        _bindEvents() {
                            let {range: e, dynamicRange: t} = this.opts;
                            D(this.$el, "mouseover", this.onMouseOverCell), D(this.$el, "mouseout", this.onMouseOutCell), 
                            D(this.$el, "click", this.onClickBody), e && t && (D(this.$el, "mousedown", this.onMouseDown), 
                            D(this.$el, "mousemove", this.onMouseMove), D(window.document, "mouseup", this.onMouseUp));
                        }
                        _bindDatepickerEvents() {
                            this.dp.on(i.eventChangeViewDate, this.onChangeViewDate), this.dp.on(i.eventChangeCurrentView, this.onChangeCurrentView);
                        }
                        _buildBaseHtml() {
                            this.$el = n({
                                className: `air-datepicker-body -${this.type}-`,
                                innerHtml: M[this.type]
                            }), this.$names = a(".air-datepicker-body--day-names", this.$el), this.$cells = a(".air-datepicker-body--cells", this.$el);
                        }
                        _getDayNamesHtml() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dp.locale.firstDay, t = "", s = this.dp.isWeekend, {onClickDayName: a} = this.opts, n = e, r = 0;
                            for (;r < 7; ) {
                                let e = n % 7;
                                t += `<div class="${u("air-datepicker-body--day-name", {
                                    [i.cssClassWeekend]: s(e),
                                    "-clickable-": !!a
                                })}" data-day-index='${e}'>${this.dp.locale.daysMin[e]}</div>`, r++, n++;
                            }
                            return t;
                        }
                        renderDayNames() {
                            this.$names.innerHTML = this._getDayNamesHtml();
                        }
                        _generateCell(e) {
                            let {type: t, dp: i, opts: s} = this;
                            return new C({
                                type: t,
                                dp: i,
                                opts: s,
                                date: e,
                                body: this
                            });
                        }
                        _generateCells() {
                            T.getDatesFunction(this.type)(this.dp, (e => {
                                this.cells.push(this._generateCell(e));
                            }));
                        }
                        show() {
                            this.isVisible = !0, this.$el.classList.remove("-hidden-");
                        }
                        hide() {
                            this.isVisible = !1, this.$el.classList.add("-hidden-");
                        }
                        destroyCells() {
                            this.cells.forEach((e => e.destroy())), this.cells = [], this.$cells.innerHTML = "";
                        }
                        destroy() {
                            this.destroyCells(), this.dp.off(i.eventChangeViewDate, this.onChangeViewDate), 
                            this.dp.off(i.eventChangeCurrentView, this.onChangeCurrentView);
                        }
                        static getDaysDates(e, t) {
                            let {viewDate: i, opts: {fixedHeight: s}, locale: {firstDay: a}} = e, n = o(i), {year: r, month: l} = h(i), d = new Date(r, l, 1), c = new Date(r, l, n), u = d.getDay() - a, p = 6 - c.getDay() + a;
                            u = u < 0 ? u + 7 : u, p = p > 6 ? p - 7 : p;
                            let m = function(e, t) {
                                let {year: i, month: s, date: a} = h(e);
                                return new Date(i, s, a - t);
                            }(d, u), v = n + u + p, g = m.getDate(), {year: D, month: y} = h(m), f = 0;
                            s && (v = 42);
                            const w = [];
                            for (;f < v; ) {
                                let e = new Date(D, y, g + f);
                                t && t(e), w.push(e), f++;
                            }
                            return w;
                        }
                        static getMonthsDates(e, t) {
                            let {year: i} = e.parsedViewDate, s = 0, a = [];
                            for (;s < 12; ) {
                                const e = new Date(i, s);
                                a.push(e), t && t(e), s++;
                            }
                            return a;
                        }
                        static getYearsDates(e, t) {
                            let i = c(e.viewDate), s = i[0] - 1, a = i[1] + 1, n = s, r = [];
                            for (;n <= a; ) {
                                const e = new Date(n, 0);
                                r.push(e), t && t(e), n++;
                            }
                            return r;
                        }
                        static getDatesFunction() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i.days;
                            return {
                                [i.days]: T.getDaysDates,
                                [i.months]: T.getMonthsDates,
                                [i.years]: T.getYearsDates
                            }[e];
                        }
                    }
                    function F(e, t, i) {
                        return (t = function(e) {
                            var t = function(e, t) {
                                if ("object" != typeof e || null === e) return e;
                                var i = e[Symbol.toPrimitive];
                                if (void 0 !== i) {
                                    var s = i.call(e, "string");
                                    if ("object" != typeof s) return s;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e);
                            }(e);
                            return "symbol" == typeof t ? t : String(t);
                        }(t)) in e ? Object.defineProperty(e, t, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = i, e;
                    }
                    class V {
                        constructor(e) {
                            let {dp: t, opts: i} = e;
                            F(this, "onClickNav", (e => {
                                let t = y(e.target, ".air-datepicker-nav--action");
                                if (!t) return;
                                let i = t.dataset.action;
                                this.dp[i]();
                            })), F(this, "onChangeViewDate", (() => {
                                this.render(), this._resetNavStatus(), this.handleNavStatus();
                            })), F(this, "onChangeCurrentView", (() => {
                                this.render(), this._resetNavStatus(), this.handleNavStatus();
                            })), F(this, "onClickNavTitle", (() => {
                                this.dp.isFinalView || this.dp.up();
                            })), F(this, "update", (() => {
                                let {prevHtml: e, nextHtml: t} = this.opts;
                                this.$prev.innerHTML = e, this.$next.innerHTML = t, this._resetNavStatus(), this.render(), 
                                this.handleNavStatus();
                            })), F(this, "renderDelay", (() => {
                                setTimeout(this.render);
                            })), F(this, "render", (() => {
                                this.$title.innerHTML = this._getTitle(), function(e, t) {
                                    for (let i in t) t[i] ? e.classList.add(i) : e.classList.remove(i);
                                }(this.$title, {
                                    "-disabled-": this.dp.isFinalView
                                });
                            })), this.dp = t, this.opts = i, this.init();
                        }
                        init() {
                            this._createElement(), this._buildBaseHtml(), this._defineDOM(), this.render(), 
                            this.handleNavStatus(), this._bindEvents(), this._bindDatepickerEvents();
                        }
                        _defineDOM() {
                            this.$title = a(".air-datepicker-nav--title", this.$el), this.$prev = a('[data-action="prev"]', this.$el), 
                            this.$next = a('[data-action="next"]', this.$el);
                        }
                        _bindEvents() {
                            this.$el.addEventListener("click", this.onClickNav), this.$title.addEventListener("click", this.onClickNavTitle);
                        }
                        _bindDatepickerEvents() {
                            this.dp.on(i.eventChangeViewDate, this.onChangeViewDate), this.dp.on(i.eventChangeCurrentView, this.onChangeCurrentView), 
                            this.isNavIsFunction && (this.dp.on(i.eventChangeSelectedDate, this.renderDelay), 
                            this.dp.opts.timepicker && this.dp.on(i.eventChangeTime, this.render));
                        }
                        destroy() {
                            this.dp.off(i.eventChangeViewDate, this.onChangeViewDate), this.dp.off(i.eventChangeCurrentView, this.onChangeCurrentView), 
                            this.isNavIsFunction && (this.dp.off(i.eventChangeSelectedDate, this.renderDelay), 
                            this.dp.opts.timepicker && this.dp.off(i.eventChangeTime, this.render));
                        }
                        _createElement() {
                            this.$el = n({
                                tagName: "nav",
                                className: "air-datepicker-nav"
                            });
                        }
                        _getTitle() {
                            let {dp: e, opts: t} = this, i = t.navTitles[e.currentView];
                            return "function" == typeof i ? i(e) : e.formatDate(e.viewDate, i);
                        }
                        handleNavStatus() {
                            let {disableNavWhenOutOfRange: e} = this.opts, {minDate: t, maxDate: s} = this.dp;
                            if (!t && !s || !e) return;
                            let {year: a, month: n} = this.dp.parsedViewDate, r = !!t && h(t), o = !!s && h(s);
                            switch (this.dp.currentView) {
                              case i.days:
                                t && r.month >= n && r.year >= a && this._disableNav("prev"), s && o.month <= n && o.year <= a && this._disableNav("next");
                                break;

                              case i.months:
                                t && r.year >= a && this._disableNav("prev"), s && o.year <= a && this._disableNav("next");
                                break;

                              case i.years:
                                {
                                    let e = c(this.dp.viewDate);
                                    t && r.year >= e[0] && this._disableNav("prev"), s && o.year <= e[1] && this._disableNav("next");
                                    break;
                                }
                            }
                        }
                        _disableNav(e) {
                            a('[data-action="' + e + '"]', this.$el).classList.add("-disabled-");
                        }
                        _resetNavStatus() {
                            !function(e) {
                                for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) i[s - 1] = arguments[s];
                                e.length ? e.forEach((e => {
                                    e.classList.remove(...i);
                                })) : e.classList.remove(...i);
                            }(this.$el.querySelectorAll(".air-datepicker-nav--action"), "-disabled-");
                        }
                        _buildBaseHtml() {
                            let {prevHtml: e, nextHtml: t} = this.opts;
                            this.$el.innerHTML = `<div class="air-datepicker-nav--action" data-action="prev">${e}</div><div class="air-datepicker-nav--title"></div><div class="air-datepicker-nav--action" data-action="next">${t}</div>`;
                        }
                        get isNavIsFunction() {
                            let {navTitles: e} = this.opts;
                            return Object.keys(e).find((t => "function" == typeof e[t]));
                        }
                    }
                    var x = {
                        today: {
                            content: e => e.locale.today,
                            onClick: e => e.setViewDate(new Date)
                        },
                        clear: {
                            content: e => e.locale.clear,
                            onClick: e => e.clear()
                        }
                    };
                    class H {
                        constructor(e) {
                            let {dp: t, opts: i} = e;
                            this.dp = t, this.opts = i, this.init();
                        }
                        init() {
                            this.createElement(), this.render();
                        }
                        createElement() {
                            this.$el = n({
                                className: "air-datepicker-buttons"
                            });
                        }
                        destroy() {
                            this.$el.parentNode.removeChild(this.$el);
                        }
                        clearHtml() {
                            return this.$el.innerHTML = "", this;
                        }
                        generateButtons() {
                            let {buttons: e} = this.opts;
                            Array.isArray(e) || (e = [ e ]), e.forEach((e => {
                                let t = e;
                                "string" == typeof e && x[e] && (t = x[e]);
                                let i = this.createButton(t);
                                t.onClick && this.attachEventToButton(i, t.onClick), this.$el.appendChild(i);
                            }));
                        }
                        attachEventToButton(e, t) {
                            e.addEventListener("click", (() => {
                                t(this.dp);
                            }));
                        }
                        createButton(e) {
                            let {content: t, className: i, tagName: s = "button", attrs: a = {}} = e;
                            return n({
                                tagName: s,
                                innerHtml: `<span tabindex='-1'>${"function" == typeof t ? t(this.dp) : t}</span>`,
                                className: u("air-datepicker-button", i),
                                attrs: a
                            });
                        }
                        render() {
                            this.generateButtons();
                        }
                    }
                    function E(e, t, i) {
                        return (t = function(e) {
                            var t = function(e, t) {
                                if ("object" != typeof e || null === e) return e;
                                var i = e[Symbol.toPrimitive];
                                if (void 0 !== i) {
                                    var s = i.call(e, "string");
                                    if ("object" != typeof s) return s;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e);
                            }(e);
                            return "symbol" == typeof t ? t : String(t);
                        }(t)) in e ? Object.defineProperty(e, t, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = i, e;
                    }
                    class L {
                        constructor() {
                            let {opts: e, dp: t} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            E(this, "toggleTimepickerIsActive", (e => {
                                this.dp.timepickerIsActive = e;
                            })), E(this, "onChangeSelectedDate", (e => {
                                let {date: t, updateTime: i = !1} = e;
                                t && (this.setMinMaxTime(t), this.setCurrentTime(!!i && t), this.addTimeToDate(t));
                            })), E(this, "onChangeLastSelectedDate", (e => {
                                e && (this.setTime(e), this.render());
                            })), E(this, "onChangeInputRange", (e => {
                                let t = e.target;
                                this[t.getAttribute("name")] = t.value, this.updateText(), this.dp.trigger(i.eventChangeTime, {
                                    hours: this.hours,
                                    minutes: this.minutes
                                });
                            })), E(this, "onMouseEnterLeave", (e => {
                                let t = e.target.getAttribute("name"), i = this.$minutesText;
                                "hours" === t && (i = this.$hoursText), i.classList.toggle("-focus-");
                            })), E(this, "onFocus", (() => {
                                this.toggleTimepickerIsActive(!0);
                            })), E(this, "onBlur", (() => {
                                this.toggleTimepickerIsActive(!1);
                            })), this.opts = e, this.dp = t;
                            let {timeFormat: s} = this.dp.locale;
                            s && (s.match(k("h")) || s.match(k("hh"))) && (this.ampm = !0), this.init();
                        }
                        init() {
                            this.setTime(this.dp.lastSelectedDate || this.dp.viewDate), this.createElement(), 
                            this.buildHtml(), this.defineDOM(), this.render(), this.bindDatepickerEvents(), 
                            this.bindDOMEvents();
                        }
                        bindDatepickerEvents() {
                            this.dp.on(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.on(i.eventChangeLastSelectedDate, this.onChangeLastSelectedDate);
                        }
                        bindDOMEvents() {
                            let e = "input";
                            navigator.userAgent.match(/trident/gi) && (e = "change"), D(this.$ranges, e, this.onChangeInputRange), 
                            D(this.$ranges, "mouseenter", this.onMouseEnterLeave), D(this.$ranges, "mouseleave", this.onMouseEnterLeave), 
                            D(this.$ranges, "focus", this.onFocus), D(this.$ranges, "mousedown", this.onFocus), 
                            D(this.$ranges, "blur", this.onBlur);
                        }
                        createElement() {
                            this.$el = n({
                                className: u("air-datepicker-time", {
                                    "-am-pm-": this.dp.ampm
                                })
                            });
                        }
                        destroy() {
                            this.dp.off(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.off(i.eventChangeLastSelectedDate, this.onChangeLastSelectedDate), 
                            this.$el.parentNode.removeChild(this.$el);
                        }
                        buildHtml() {
                            let {ampm: e, hours: t, displayHours: i, minutes: s, minHours: a, minMinutes: n, maxHours: r, maxMinutes: o, dayPeriod: h, opts: {hoursStep: l, minutesStep: c}} = this;
                            this.$el.innerHTML = `<div class="air-datepicker-time--current">   <span class="air-datepicker-time--current-hours">${d(i)}</span>   <span class="air-datepicker-time--current-colon">:</span>   <span class="air-datepicker-time--current-minutes">${d(s)}</span>   ` + (e ? `<span class='air-datepicker-time--current-ampm'>${h}</span>` : "") + '</div><div class="air-datepicker-time--sliders">   <div class="air-datepicker-time--row">' + `      <input type="range" name="hours" value="${t}" min="${a}" max="${r}" step="${l}"/>   </div>   <div class="air-datepicker-time--row">` + `      <input type="range" name="minutes" value="${s}" min="${n}" max="${o}" step="${c}"/>   </div></div>`;
                        }
                        defineDOM() {
                            let e = e => a(e, this.$el);
                            this.$ranges = this.$el.querySelectorAll('[type="range"]'), this.$hours = e('[name="hours"]'), 
                            this.$minutes = e('[name="minutes"]'), this.$hoursText = e(".air-datepicker-time--current-hours"), 
                            this.$minutesText = e(".air-datepicker-time--current-minutes"), this.$ampm = e(".air-datepicker-time--current-ampm");
                        }
                        setTime(e) {
                            this.setMinMaxTime(e), this.setCurrentTime(e);
                        }
                        addTimeToDate(e) {
                            e && (e.setHours(this.hours), e.setMinutes(this.minutes));
                        }
                        setMinMaxTime(e) {
                            if (this.setMinMaxTimeFromOptions(), e) {
                                let {minDate: t, maxDate: i} = this.dp;
                                t && p(e, t) && this.setMinTimeFromMinDate(t), i && p(e, i) && this.setMaxTimeFromMaxDate(i);
                            }
                        }
                        setCurrentTime(e) {
                            let {hours: t, minutes: i} = e ? h(e) : this;
                            this.hours = f(t, this.minHours, this.maxHours), this.minutes = f(i, this.minMinutes, this.maxMinutes);
                        }
                        setMinMaxTimeFromOptions() {
                            let {minHours: e, minMinutes: t, maxHours: i, maxMinutes: s} = this.opts;
                            this.minHours = f(e, 0, 23), this.minMinutes = f(t, 0, 59), this.maxHours = f(i, 0, 23), 
                            this.maxMinutes = f(s, 0, 59);
                        }
                        setMinTimeFromMinDate(e) {
                            let {lastSelectedDate: t} = this.dp;
                            this.minHours = e.getHours(), t && t.getHours() > e.getHours() ? this.minMinutes = this.opts.minMinutes : this.minMinutes = e.getMinutes();
                        }
                        setMaxTimeFromMaxDate(e) {
                            let {lastSelectedDate: t} = this.dp;
                            this.maxHours = e.getHours(), t && t.getHours() < e.getHours() ? this.maxMinutes = this.opts.maxMinutes : this.maxMinutes = e.getMinutes();
                        }
                        updateSliders() {
                            r(this.$hours, {
                                min: this.minHours,
                                max: this.maxHours
                            }).value = this.hours, r(this.$minutes, {
                                min: this.minMinutes,
                                max: this.maxMinutes
                            }).value = this.minutes;
                        }
                        updateText() {
                            this.$hoursText.innerHTML = d(this.displayHours), this.$minutesText.innerHTML = d(this.minutes), 
                            this.ampm && (this.$ampm.innerHTML = this.dayPeriod);
                        }
                        set hours(e) {
                            this._hours = e;
                            let {hours: t, dayPeriod: i} = l(e);
                            this.displayHours = this.ampm ? t : e, this.dayPeriod = i;
                        }
                        get hours() {
                            return this._hours;
                        }
                        render() {
                            this.updateSliders(), this.updateText();
                        }
                    }
                    function O(e, t, i) {
                        return (t = function(e) {
                            var t = function(e, t) {
                                if ("object" != typeof e || null === e) return e;
                                var i = e[Symbol.toPrimitive];
                                if (void 0 !== i) {
                                    var s = i.call(e, "string");
                                    if ("object" != typeof s) return s;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e);
                            }(e);
                            return "symbol" == typeof t ? t : String(t);
                        }(t)) in e ? Object.defineProperty(e, t, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = i, e;
                    }
                    class A {
                        constructor(e) {
                            let {dp: t, opts: i} = e;
                            O(this, "pressedKeys", new Set), O(this, "hotKeys", new Map([ [ [ [ "Control", "ArrowRight" ], [ "Control", "ArrowUp" ] ], e => e.month++ ], [ [ [ "Control", "ArrowLeft" ], [ "Control", "ArrowDown" ] ], e => e.month-- ], [ [ [ "Shift", "ArrowRight" ], [ "Shift", "ArrowUp" ] ], e => e.year++ ], [ [ [ "Shift", "ArrowLeft" ], [ "Shift", "ArrowDown" ] ], e => e.year-- ], [ [ [ "Alt", "ArrowRight" ], [ "Alt", "ArrowUp" ] ], e => e.year += 10 ], [ [ [ "Alt", "ArrowLeft" ], [ "Alt", "ArrowDown" ] ], e => e.year -= 10 ], [ [ "Control", "Shift", "ArrowUp" ], (e, t) => t.up() ] ])), 
                            O(this, "handleHotKey", (e => {
                                let t = this.hotKeys.get(e), i = h(this.getInitialFocusDate());
                                t(i, this.dp);
                                let {year: s, month: a, date: n} = i, r = o(new Date(s, a));
                                r < n && (n = r);
                                let l = this.dp.getClampedDate(new Date(s, a, n));
                                this.dp.setFocusDate(l, {
                                    viewDateTransition: !0
                                });
                            })), O(this, "isHotKeyPressed", (() => {
                                let e = !1, t = this.pressedKeys.size, i = e => this.pressedKeys.has(e);
                                for (let [s] of this.hotKeys) {
                                    if (e) break;
                                    if (Array.isArray(s[0])) s.forEach((a => {
                                        e || t !== a.length || (e = a.every(i) && s);
                                    })); else {
                                        if (t !== s.length) continue;
                                        e = s.every(i) && s;
                                    }
                                }
                                return e;
                            })), O(this, "isArrow", (e => e >= 37 && e <= 40)), O(this, "onKeyDown", (e => {
                                let {key: t, which: i} = e, {dp: s, dp: {focusDate: a}, opts: n} = this;
                                this.registerKey(t);
                                let r = this.isHotKeyPressed();
                                if (r) return e.preventDefault(), void this.handleHotKey(r);
                                if (this.isArrow(i)) return e.preventDefault(), void this.focusNextCell(t);
                                if ("Enter" === t) {
                                    if (s.currentView !== n.minView) return void s.down();
                                    if (a) {
                                        let e = s._checkIfDateIsSelected(a);
                                        return void (e ? s._handleAlreadySelectedDates(e, a) : s.selectDate(a));
                                    }
                                }
                                "Escape" === t && this.dp.hide();
                            })), O(this, "onKeyUp", (e => {
                                this.removeKey(e.key);
                            })), this.dp = t, this.opts = i, this.init();
                        }
                        init() {
                            this.bindKeyboardEvents();
                        }
                        bindKeyboardEvents() {
                            let {$el: e} = this.dp;
                            e.addEventListener("keydown", this.onKeyDown), e.addEventListener("keyup", this.onKeyUp);
                        }
                        destroy() {
                            let {$el: e} = this.dp;
                            e.removeEventListener("keydown", this.onKeyDown), e.removeEventListener("keyup", this.onKeyUp), 
                            this.hotKeys = null, this.pressedKeys = null;
                        }
                        getInitialFocusDate() {
                            let {focusDate: e, currentView: t, selectedDates: s, parsedViewDate: {year: a, month: n}} = this.dp, r = e || s[s.length - 1];
                            if (!r) switch (t) {
                              case i.days:
                                r = new Date(a, n, (new Date).getDate());
                                break;

                              case i.months:
                                r = new Date(a, n, 1);
                                break;

                              case i.years:
                                r = new Date(a, 0, 1);
                            }
                            return r;
                        }
                        focusNextCell(e) {
                            let t = this.getInitialFocusDate(), {currentView: s} = this.dp, {days: a, months: n, years: r} = i, o = h(t), l = o.year, d = o.month, c = o.date;
                            switch (e) {
                              case "ArrowLeft":
                                s === a && (c -= 1), s === n && (d -= 1), s === r && (l -= 1);
                                break;

                              case "ArrowUp":
                                s === a && (c -= 7), s === n && (d -= 3), s === r && (l -= 4);
                                break;

                              case "ArrowRight":
                                s === a && (c += 1), s === n && (d += 1), s === r && (l += 1);
                                break;

                              case "ArrowDown":
                                s === a && (c += 7), s === n && (d += 3), s === r && (l += 4);
                            }
                            let u = this.dp.getClampedDate(new Date(l, d, c));
                            this.dp.setFocusDate(u, {
                                viewDateTransition: !0
                            });
                        }
                        registerKey(e) {
                            this.pressedKeys.add(e);
                        }
                        removeKey(e) {
                            this.pressedKeys.delete(e);
                        }
                    }
                    let N = {
                        on(e, t) {
                            this.__events || (this.__events = {}), this.__events[e] ? this.__events[e].push(t) : this.__events[e] = [ t ];
                        },
                        off(e, t) {
                            this.__events && this.__events[e] && (this.__events[e] = this.__events[e].filter((e => e !== t)));
                        },
                        removeAllEvents() {
                            this.__events = {};
                        },
                        trigger(e) {
                            for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) i[s - 1] = arguments[s];
                            this.__events && this.__events[e] && this.__events[e].forEach((e => {
                                e(...i);
                            }));
                        }
                    };
                    function I(e, t, i) {
                        return (t = function(e) {
                            var t = function(e, t) {
                                if ("object" != typeof e || null === e) return e;
                                var i = e[Symbol.toPrimitive];
                                if (void 0 !== i) {
                                    var s = i.call(e, "string");
                                    if ("object" != typeof s) return s;
                                    throw new TypeError("@@toPrimitive must return a primitive value.");
                                }
                                return String(e);
                            }(e);
                            return "symbol" == typeof t ? t : String(t);
                        }(t)) in e ? Object.defineProperty(e, t, {
                            value: i,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = i, e;
                    }
                    let P = "", j = "", B = !1;
                    class R {
                        static buildGlobalContainer(e) {
                            B = !0, P = n({
                                className: e,
                                id: e
                            }), a("body").appendChild(P);
                        }
                        constructor(e, t) {
                            var r = this;
                            if (I(this, "viewIndexes", [ i.days, i.months, i.years ]), I(this, "next", (() => {
                                let {year: e, month: t} = this.parsedViewDate;
                                switch (this.currentView) {
                                  case i.days:
                                    this.setViewDate(new Date(e, t + 1, 1));
                                    break;

                                  case i.months:
                                    this.setViewDate(new Date(e + 1, t, 1));
                                    break;

                                  case i.years:
                                    this.setViewDate(new Date(e + 10, 0, 1));
                                }
                            })), I(this, "prev", (() => {
                                let {year: e, month: t} = this.parsedViewDate;
                                switch (this.currentView) {
                                  case i.days:
                                    this.setViewDate(new Date(e, t - 1, 1));
                                    break;

                                  case i.months:
                                    this.setViewDate(new Date(e - 1, t, 1));
                                    break;

                                  case i.years:
                                    this.setViewDate(new Date(e - 10, 0, 1));
                                }
                            })), I(this, "_finishHide", (() => {
                                this.hideAnimation = !1, this._destroyComponents(), this.$container.removeChild(this.$datepicker);
                            })), I(this, "setPosition", (function(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                                if ("function" == typeof (e = e || r.opts.position)) return void (r.customHide = e({
                                    $datepicker: r.$datepicker,
                                    $target: r.$el,
                                    $pointer: r.$pointer,
                                    isViewChange: t,
                                    done: r._finishHide
                                }));
                                let i, s, {isMobile: a} = r.opts, n = r.$el.getBoundingClientRect(), o = r.$el.getBoundingClientRect(), h = r.$datepicker.offsetParent, l = r.$el.offsetParent, d = r.$datepicker.getBoundingClientRect(), c = e.split(" "), u = window.scrollY, p = window.scrollX, m = r.opts.offset, v = c[0], g = c[1];
                                if (a) r.$datepicker.style.cssText = "left: 50%; top: 50%"; else {
                                    if (h === l && h !== document.body && (o = {
                                        top: r.$el.offsetTop,
                                        left: r.$el.offsetLeft,
                                        width: n.width,
                                        height: r.$el.offsetHeight
                                    }, u = 0, p = 0), h !== l && h !== document.body) {
                                        let e = h.getBoundingClientRect();
                                        o = {
                                            top: n.top - e.top,
                                            left: n.left - e.left,
                                            width: n.width,
                                            height: n.height
                                        }, u = 0, p = 0;
                                    }
                                    switch (v) {
                                      case "top":
                                        i = o.top - d.height - m;
                                        break;

                                      case "right":
                                        s = o.left + o.width + m;
                                        break;

                                      case "bottom":
                                        i = o.top + o.height + m;
                                        break;

                                      case "left":
                                        s = o.left - d.width - m;
                                    }
                                    switch (g) {
                                      case "top":
                                        i = o.top;
                                        break;

                                      case "right":
                                        s = o.left + o.width - d.width;
                                        break;

                                      case "bottom":
                                        i = o.top + o.height - d.height;
                                        break;

                                      case "left":
                                        s = o.left;
                                        break;

                                      case "center":
                                        /left|right/.test(v) ? i = o.top + o.height / 2 - d.height / 2 : s = o.left + o.width / 2 - d.width / 2;
                                    }
                                    r.$datepicker.style.cssText = `left: ${s + p}px; top: ${i + u}px`;
                                }
                            })), I(this, "_setInputValue", (() => {
                                let {opts: e, $altField: t, locale: {dateFormat: i}} = this, {altFieldDateFormat: s, altField: a} = e;
                                a && t && (t.value = this._getInputValue(s)), this.$el.value = this._getInputValue(i);
                            })), I(this, "_getInputValue", (e => {
                                let {selectedDates: t, opts: i} = this, {multipleDates: s, multipleDatesSeparator: a} = i;
                                if (!t.length) return "";
                                let n = "function" == typeof e, r = n ? e(s ? t : t[0]) : t.map((t => this.formatDate(t, e)));
                                return r = n ? r : r.join(a), r;
                            })), I(this, "_checkIfDateIsSelected", (function(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i.days, s = !1;
                                return r.selectedDates.some((i => {
                                    let a = p(e, i, t);
                                    return s = a && i, a;
                                })), s;
                            })), I(this, "_scheduleCallAfterTransition", (e => {
                                this._cancelScheduledCall(), e && e(!1), this._onTransitionEnd = () => {
                                    e && e(!0);
                                }, this.$datepicker.addEventListener("transitionend", this._onTransitionEnd, {
                                    once: !0
                                });
                            })), I(this, "_cancelScheduledCall", (() => {
                                this.$datepicker.removeEventListener("transitionend", this._onTransitionEnd);
                            })), I(this, "setViewDate", (e => {
                                if (!((e = b(e)) instanceof Date)) return;
                                if (p(e, this.viewDate)) return;
                                let t = this.viewDate;
                                this.viewDate = e;
                                let {onChangeViewDate: s} = this.opts;
                                if (s) {
                                    let {month: e, year: t} = this.parsedViewDate;
                                    s({
                                        month: e,
                                        year: t,
                                        decade: this.curDecade
                                    });
                                }
                                this.trigger(i.eventChangeViewDate, e, t);
                            })), I(this, "setFocusDate", (function(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                (!e || (e = b(e)) instanceof Date) && (r.focusDate = e, r.trigger(i.eventChangeFocusDate, e, t));
                            })), I(this, "setCurrentView", (function(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (r.viewIndexes.includes(e)) {
                                    if (r.currentView = e, r.elIsInput && r.visible && r.setPosition(void 0, !0), r.trigger(i.eventChangeCurrentView, e), 
                                    !r.views[e]) {
                                        let t = r.views[e] = new T({
                                            dp: r,
                                            opts: r.opts,
                                            type: e
                                        });
                                        r.shouldUpdateDOM && r.$content.appendChild(t.$el);
                                    }
                                    r.opts.onChangeView && !t.silent && r.opts.onChangeView(e);
                                }
                            })), I(this, "_updateLastSelectedDate", (e => {
                                this.lastSelectedDate = e, this.trigger(i.eventChangeLastSelectedDate, e);
                            })), I(this, "destroy", (() => {
                                let {showEvent: e, isMobile: t} = this.opts, i = this.$datepicker.parentNode;
                                i && i.removeChild(this.$datepicker), this.$el.removeEventListener(e, this._onFocus), 
                                this.$el.removeEventListener("blur", this._onBlur), window.removeEventListener("resize", this._onResize), 
                                t && this._removeMobileAttributes(), this.keyboardNav && this.keyboardNav.destroy(), 
                                this.views = null, this.nav = null, this.$datepicker = null, this.opts = null, this.$customContainer = null, 
                                this.viewDate = null, this.focusDate = null, this.selectedDates = null, this.rangeDateFrom = null, 
                                this.rangeDateTo = null;
                            })), I(this, "update", (function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, s = w({}, r.opts), {silent: a} = t;
                                w(r.opts, e);
                                let {timepicker: n, buttons: o, range: h, selectedDates: l, isMobile: d} = r.opts, c = r.visible || r.treatAsInline;
                                r._createMinMaxDates(), r._limitViewDateByMaxMinDates(), r._handleLocale(), l && (r.selectedDates = [], 
                                r.selectDate(l, {
                                    silent: a
                                })), e.view && r.setCurrentView(e.view, {
                                    silent: a
                                }), r._setInputValue(), s.range && !h ? (r.rangeDateTo = !1, r.rangeDateFrom = !1) : !s.range && h && r.selectedDates.length && (r.rangeDateFrom = r.selectedDates[0], 
                                r.rangeDateTo = r.selectedDates[1]), s.timepicker && !n ? (c && r.timepicker.destroy(), 
                                r.timepicker = !1, r.$timepicker.parentNode.removeChild(r.$timepicker)) : !s.timepicker && n && r._addTimepicker(), 
                                !s.buttons && o ? r._addButtons() : s.buttons && !o ? (r.buttons.destroy(), r.$buttons.parentNode.removeChild(r.$buttons)) : c && s.buttons && o && r.buttons.clearHtml().render(), 
                                !s.isMobile && d ? (r.treatAsInline || j || r._createMobileOverlay(), r._addMobileAttributes(), 
                                r.visible && r._showMobileOverlay()) : s.isMobile && !d && (r._removeMobileAttributes(), 
                                r.visible && (j.classList.remove("-active-"), "function" != typeof r.opts.position && r.setPosition())), 
                                c && (r.nav.update(), r.views[r.currentView].render(), r.currentView === i.days && r.views[r.currentView].renderDayNames());
                            })), I(this, "disableDate", ((e, t) => {
                                (Array.isArray(e) ? e : [ e ]).forEach((e => {
                                    let i = b(e);
                                    if (!i) return;
                                    let s = t ? "delete" : "add";
                                    this.disabledDates[s](this.formatDate(i, "yyyy-MM-dd"));
                                    let a = this.getCell(i, this.currentViewSingular);
                                    a && a.adpCell.render();
                                }), []);
                            })), I(this, "enableDate", (e => {
                                this.disableDate(e, !0);
                            })), I(this, "isDateDisabled", (e => {
                                let t = b(e);
                                return this.disabledDates.has(this.formatDate(t, "yyyy-MM-dd"));
                            })), I(this, "isOtherMonth", (e => {
                                let {month: t} = h(e);
                                return t !== this.parsedViewDate.month;
                            })), I(this, "isOtherYear", (e => {
                                let {year: t} = h(e);
                                return t !== this.parsedViewDate.year;
                            })), I(this, "isOtherDecade", (e => {
                                let {year: t} = h(e), [i, s] = c(this.viewDate);
                                return t < i || t > s;
                            })), I(this, "_onChangeSelectedDate", (e => {
                                let {silent: t} = e;
                                setTimeout((() => {
                                    this._setInputValue(), this.opts.onSelect && !t && this._triggerOnSelect();
                                }));
                            })), I(this, "_onChangeFocusedDate", (function(e) {
                                let {viewDateTransition: t} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (!e) return;
                                let i = !1;
                                t && (i = r.isOtherMonth(e) || r.isOtherYear(e) || r.isOtherDecade(e)), i && r.setViewDate(e), 
                                r.opts.onFocus && r.opts.onFocus({
                                    datepicker: r,
                                    date: e
                                });
                            })), I(this, "_onChangeTime", (e => {
                                let {hours: t, minutes: i} = e, s = new Date, {lastSelectedDate: a, opts: {onSelect: n}} = this, r = a;
                                a || (r = s);
                                let o = this.getCell(r, this.currentViewSingular), h = o && o.adpCell;
                                h && h.isDisabled || (r.setHours(t), r.setMinutes(i), a ? (this._setInputValue(), 
                                n && this._triggerOnSelect()) : this.selectDate(r));
                            })), I(this, "_onFocus", (e => {
                                this.visible || this.show();
                            })), I(this, "_onBlur", (e => {
                                this.inFocus || !this.visible || this.opts.isMobile || this.hide();
                            })), I(this, "_onMouseDown", (e => {
                                this.inFocus = !0;
                            })), I(this, "_onMouseUp", (e => {
                                this.inFocus = !1, this.$el.focus();
                            })), I(this, "_onResize", (() => {
                                this.visible && "function" != typeof this.opts.position && this.setPosition();
                            })), I(this, "_onClickOverlay", (() => {
                                this.visible && this.hide();
                            })), I(this, "getViewDates", (function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i.days;
                                return T.getDatesFunction(e)(r);
                            })), I(this, "isWeekend", (e => this.opts.weekends.includes(e))), I(this, "getClampedDate", (e => {
                                let {minDate: t, maxDate: i} = this, s = e;
                                return i && m(e, i) ? s = i : t && v(e, t) && (s = t), s;
                            })), this.$el = a(e), !this.$el) return;
                            this.$datepicker = n({
                                className: "air-datepicker"
                            }), this.opts = w({}, s, t), this.$customContainer = !!this.opts.container && a(this.opts.container), 
                            this.$altField = a(this.opts.altField || !1);
                            let {view: o, startDate: l} = this.opts;
                            l || (this.opts.startDate = new Date), "INPUT" === this.$el.nodeName && (this.elIsInput = !0), 
                            this.inited = !1, this.visible = !1, this.viewDate = b(this.opts.startDate), this.focusDate = !1, 
                            this.initialReadonly = this.$el.getAttribute("readonly"), this.customHide = !1, 
                            this.currentView = o, this.selectedDates = [], this.disabledDates = new Set, this.views = {}, 
                            this.keys = [], this.rangeDateFrom = "", this.rangeDateTo = "", this.timepickerIsActive = !1, 
                            this.treatAsInline = this.opts.inline || !this.elIsInput, this.init();
                        }
                        init() {
                            let {opts: e, treatAsInline: t, opts: {inline: i, isMobile: s, selectedDates: n, keyboardNav: r, onlyTimepicker: o}} = this, h = a("body");
                            (!B || B && P && !h.contains(P)) && !i && this.elIsInput && !this.$customContainer && R.buildGlobalContainer(R.defaultGlobalContainerId), 
                            !s || j || t || this._createMobileOverlay(), this._handleLocale(), this._bindSubEvents(), 
                            this._createMinMaxDates(), this._limitViewDateByMaxMinDates(), this.elIsInput && (i || this._bindEvents(), 
                            r && !o && (this.keyboardNav = new A({
                                dp: this,
                                opts: e
                            }))), n && this.selectDate(n, {
                                silent: !0
                            }), this.opts.visible && !t && this.show(), s && !t && this.$el.setAttribute("readonly", !0), 
                            t && this._createComponents();
                        }
                        _createMobileOverlay() {
                            j = n({
                                className: "air-datepicker-overlay"
                            }), P.appendChild(j);
                        }
                        _createComponents() {
                            let {opts: e, treatAsInline: t, opts: {inline: i, buttons: s, timepicker: a, position: n, classes: r, onlyTimepicker: o, isMobile: h}} = this;
                            this._buildBaseHtml(), this.elIsInput && (i || this._setPositionClasses(n)), !i && this.elIsInput || this.$datepicker.classList.add("-inline-"), 
                            r && this.$datepicker.classList.add(...r.split(" ")), o && this.$datepicker.classList.add("-only-timepicker-"), 
                            h && !t && this._addMobileAttributes(), this.views[this.currentView] = new T({
                                dp: this,
                                type: this.currentView,
                                opts: e
                            }), this.nav = new V({
                                dp: this,
                                opts: e
                            }), a && this._addTimepicker(), s && this._addButtons(), this.$content.appendChild(this.views[this.currentView].$el), 
                            this.$nav.appendChild(this.nav.$el);
                        }
                        _destroyComponents() {
                            for (let e in this.views) this.views[e].destroy();
                            this.views = {}, this.nav.destroy(), this.timepicker && this.timepicker.destroy();
                        }
                        _addMobileAttributes() {
                            j.addEventListener("click", this._onClickOverlay), this.$datepicker.classList.add("-is-mobile-"), 
                            this.$el.setAttribute("readonly", !0);
                        }
                        _removeMobileAttributes() {
                            j.removeEventListener("click", this._onClickOverlay), this.$datepicker.classList.remove("-is-mobile-"), 
                            this.initialReadonly || "" === this.initialReadonly || this.$el.removeAttribute("readonly");
                        }
                        _createMinMaxDates() {
                            let {minDate: e, maxDate: t} = this.opts;
                            this.minDate = !!e && b(e), this.maxDate = !!t && b(t);
                        }
                        _addTimepicker() {
                            this.$timepicker = n({
                                className: "air-datepicker--time"
                            }), this.$datepicker.appendChild(this.$timepicker), this.timepicker = new L({
                                dp: this,
                                opts: this.opts
                            }), this.$timepicker.appendChild(this.timepicker.$el);
                        }
                        _addButtons() {
                            this.$buttons = n({
                                className: "air-datepicker--buttons"
                            }), this.$datepicker.appendChild(this.$buttons), this.buttons = new H({
                                dp: this,
                                opts: this.opts
                            }), this.$buttons.appendChild(this.buttons.$el);
                        }
                        _bindSubEvents() {
                            this.on(i.eventChangeSelectedDate, this._onChangeSelectedDate), this.on(i.eventChangeFocusDate, this._onChangeFocusedDate), 
                            this.on(i.eventChangeTime, this._onChangeTime);
                        }
                        _buildBaseHtml() {
                            let {inline: e} = this.opts;
                            var t, i;
                            this.elIsInput ? e ? (t = this.$datepicker, (i = this.$el).parentNode.insertBefore(t, i.nextSibling)) : this.$container.appendChild(this.$datepicker) : this.$el.appendChild(this.$datepicker), 
                            this.$datepicker.innerHTML = '<i class="air-datepicker--pointer"></i><div class="air-datepicker--navigation"></div><div class="air-datepicker--content"></div>', 
                            this.$content = a(".air-datepicker--content", this.$datepicker), this.$pointer = a(".air-datepicker--pointer", this.$datepicker), 
                            this.$nav = a(".air-datepicker--navigation", this.$datepicker);
                        }
                        _handleLocale() {
                            let {locale: e, dateFormat: t, firstDay: i, timepicker: s, onlyTimepicker: a, timeFormat: n, dateTimeSeparator: r} = this.opts;
                            var o;
                            this.locale = (o = e, JSON.parse(JSON.stringify(o))), t && (this.locale.dateFormat = t), 
                            void 0 !== n && "" !== n && (this.locale.timeFormat = n);
                            let {timeFormat: h} = this.locale;
                            if ("" !== i && (this.locale.firstDay = i), s && "function" != typeof t) {
                                let e = h ? r : "";
                                this.locale.dateFormat = [ this.locale.dateFormat, h || "" ].join(e);
                            }
                            a && "function" != typeof t && (this.locale.dateFormat = this.locale.timeFormat);
                        }
                        _setPositionClasses(e) {
                            if ("function" == typeof e) return void this.$datepicker.classList.add("-custom-position-");
                            let t = (e = e.split(" "))[0], i = `air-datepicker -${t}-${e[1]}- -from-${t}-`;
                            this.$datepicker.classList.add(...i.split(" "));
                        }
                        _bindEvents() {
                            this.$el.addEventListener(this.opts.showEvent, this._onFocus), this.$el.addEventListener("blur", this._onBlur), 
                            this.$datepicker.addEventListener("mousedown", this._onMouseDown), this.$datepicker.addEventListener("mouseup", this._onMouseUp), 
                            window.addEventListener("resize", this._onResize);
                        }
                        _limitViewDateByMaxMinDates() {
                            let {viewDate: e, minDate: t, maxDate: i} = this;
                            i && m(e, i) && this.setViewDate(i), t && v(e, t) && this.setViewDate(t);
                        }
                        formatDate() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.viewDate, t = arguments.length > 1 ? arguments[1] : void 0;
                            if (e = b(e), !(e instanceof Date)) return;
                            let i = t, s = this.locale, a = h(e), n = a.dayPeriod, r = c(e), o = R.replacer, l = {
                                T: e.getTime(),
                                m: a.minutes,
                                mm: a.fullMinutes,
                                h: a.hours12,
                                hh: a.fullHours12,
                                H: a.hours,
                                HH: a.fullHours,
                                aa: n,
                                AA: n.toUpperCase(),
                                E: s.daysShort[a.day],
                                EEEE: s.days[a.day],
                                d: a.date,
                                dd: a.fullDate,
                                M: a.month + 1,
                                MM: a.fullMonth,
                                MMM: s.monthsShort[a.month],
                                MMMM: s.months[a.month],
                                yy: a.year.toString().slice(-2),
                                yyyy: a.year,
                                yyyy1: r[0],
                                yyyy2: r[1]
                            };
                            for (let [e, t] of Object.entries(l)) i = o(i, k(e), t);
                            return i;
                        }
                        down(e) {
                            this._handleUpDownActions(e, "down");
                        }
                        up(e) {
                            this._handleUpDownActions(e, "up");
                        }
                        selectDate(e) {
                            let t, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {currentView: a, parsedViewDate: n, selectedDates: r} = this, {updateTime: o} = s, {moveToOtherMonthsOnSelect: h, moveToOtherYearsOnSelect: l, multipleDates: d, range: c, autoClose: u, onBeforeSelect: p} = this.opts, v = r.length;
                            if (Array.isArray(e)) return e.forEach((e => {
                                this.selectDate(e, s);
                            })), new Promise((e => {
                                setTimeout(e);
                            }));
                            if ((e = b(e)) instanceof Date) {
                                if (p && !p({
                                    date: e,
                                    datepicker: this
                                })) return Promise.resolve();
                                if (a === i.days && e.getMonth() !== n.month && h && (t = new Date(e.getFullYear(), e.getMonth(), 1)), 
                                a === i.years && e.getFullYear() !== n.year && l && (t = new Date(e.getFullYear(), 0, 1)), 
                                t && this.setViewDate(t), d && !c) {
                                    if (v === d) return;
                                    this._checkIfDateIsSelected(e) || r.push(e);
                                } else if (c) switch (v) {
                                  case 1:
                                    r.push(e), this.rangeDateTo || (this.rangeDateTo = e), m(this.rangeDateFrom, this.rangeDateTo) && (this.rangeDateTo = this.rangeDateFrom, 
                                    this.rangeDateFrom = e), this.selectedDates = [ this.rangeDateFrom, this.rangeDateTo ];
                                    break;

                                  case 2:
                                    this.selectedDates = [ e ], this.rangeDateFrom = e, this.rangeDateTo = "";
                                    break;

                                  default:
                                    this.selectedDates = [ e ], this.rangeDateFrom = e;
                                } else this.selectedDates = [ e ];
                                return this.trigger(i.eventChangeSelectedDate, {
                                    action: i.actionSelectDate,
                                    silent: null == s ? void 0 : s.silent,
                                    date: e,
                                    updateTime: o
                                }), this._updateLastSelectedDate(e), u && !this.timepickerIsActive && this.visible && (d || c ? c && 1 === v && this.hide() : this.hide()), 
                                new Promise((e => {
                                    setTimeout(e);
                                }));
                            }
                        }
                        unselectDate(e) {
                            let t = this.selectedDates, s = this;
                            if ((e = b(e)) instanceof Date) return t.some(((a, n) => {
                                if (p(a, e)) return t.splice(n, 1), s.selectedDates.length ? s._updateLastSelectedDate(s.selectedDates[s.selectedDates.length - 1]) : (s.rangeDateFrom = "", 
                                s.rangeDateTo = "", s._updateLastSelectedDate(!1)), this.trigger(i.eventChangeSelectedDate, {
                                    action: i.actionUnselectDate,
                                    date: e
                                }), !0;
                            }));
                        }
                        replaceDate(e, t) {
                            let s = this.selectedDates.find((t => p(t, e, this.currentView))), a = this.selectedDates.indexOf(s);
                            a < 0 || p(this.selectedDates[a], t, this.currentView) || (this.selectedDates[a] = t, 
                            this.trigger(i.eventChangeSelectedDate, {
                                action: i.actionSelectDate,
                                date: t,
                                updateTime: !0
                            }), this._updateLastSelectedDate(t));
                        }
                        clear() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            return this.selectedDates = [], this.rangeDateFrom = !1, this.rangeDateTo = !1, 
                            this.lastSelectedDate = !1, this.trigger(i.eventChangeSelectedDate, {
                                action: i.actionUnselectDate,
                                silent: e.silent
                            }), new Promise((e => {
                                setTimeout(e);
                            }));
                        }
                        show() {
                            let {onShow: e, isMobile: t} = this.opts;
                            this._cancelScheduledCall(), this.visible || this.hideAnimation || this._createComponents(), 
                            this.setPosition(this.opts.position), this.$datepicker.classList.add("-active-"), 
                            this.visible = !0, e && this._scheduleCallAfterTransition(e), t && this._showMobileOverlay();
                        }
                        hide() {
                            let {onHide: e, isMobile: t} = this.opts, i = this._hasTransition();
                            this.visible = !1, this.hideAnimation = !0, this.$datepicker.classList.remove("-active-"), 
                            this.customHide && this.customHide(), this.elIsInput && this.$el.blur(), this._scheduleCallAfterTransition((t => {
                                !this.customHide && (t && i || !t && !i) && this._finishHide(), e && e(t);
                            })), t && j.classList.remove("-active-");
                        }
                        _triggerOnSelect() {
                            let e = [], t = [], {selectedDates: i, locale: s, opts: {onSelect: a, multipleDates: n, range: r}} = this, o = n || r, h = "function" == typeof s.dateFormat;
                            i.length && (e = i.map(g), t = h ? n ? s.dateFormat(e) : e.map((e => s.dateFormat(e))) : e.map((e => this.formatDate(e, s.dateFormat)))), 
                            a({
                                date: o ? e : e[0],
                                formattedDate: o ? t : t[0],
                                datepicker: this
                            });
                        }
                        _handleAlreadySelectedDates(e, t) {
                            let {selectedDates: i, rangeDateFrom: s, rangeDateTo: a} = this, {range: n, toggleSelected: r} = this.opts, o = i.length, h = "function" == typeof r ? r({
                                datepicker: this,
                                date: t
                            }) : r, l = Boolean(n && 1 === o && e), d = l ? g(t) : t;
                            n && !h && (2 !== o && this.selectDate(d), 2 === o && p(s, a)) || (h ? this.unselectDate(d) : this._updateLastSelectedDate(l ? d : e));
                        }
                        _handleUpDownActions(e, t) {
                            if (!((e = b(e || this.focusDate || this.viewDate)) instanceof Date)) return;
                            let i = "up" === t ? this.viewIndex + 1 : this.viewIndex - 1;
                            i > 2 && (i = 2), i < 0 && (i = 0), this.setViewDate(new Date(e.getFullYear(), e.getMonth(), 1)), 
                            this.setCurrentView(this.viewIndexes[i]);
                        }
                        getCell(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i.day;
                            if (!((e = b(e)) instanceof Date)) return;
                            let {year: s, month: a, date: n} = h(e), r = `[data-year="${s}"]`, o = `[data-month="${a}"]`, l = {
                                [i.day]: `${r}${o}[data-date="${n}"]`,
                                [i.month]: `${r}${o}`,
                                [i.year]: `${r}`
                            };
                            return this.views[this.currentView] ? this.views[this.currentView].$el.querySelector(l[t]) : void 0;
                        }
                        _showMobileOverlay() {
                            j.classList.add("-active-");
                        }
                        _hasTransition() {
                            return window.getComputedStyle(this.$datepicker).getPropertyValue("transition-duration").split(", ").reduce(((e, t) => parseFloat(t) + e), 0) > 0;
                        }
                        get shouldUpdateDOM() {
                            return this.visible || this.treatAsInline;
                        }
                        get parsedViewDate() {
                            return h(this.viewDate);
                        }
                        get currentViewSingular() {
                            return this.currentView.slice(0, -1);
                        }
                        get curDecade() {
                            return c(this.viewDate);
                        }
                        get viewIndex() {
                            return this.viewIndexes.indexOf(this.currentView);
                        }
                        get isFinalView() {
                            return this.currentView === i.years;
                        }
                        get hasSelectedDates() {
                            return this.selectedDates.length > 0;
                        }
                        get isMinViewReached() {
                            return this.currentView === this.opts.minView || this.currentView === i.days;
                        }
                        get $container() {
                            return this.$customContainer || P;
                        }
                        static replacer(e, t, i) {
                            return e.replace(t, (function(e, t, s, a) {
                                return t + i + a;
                            }));
                        }
                    }
                    var K;
                    return I(R, "defaults", s), I(R, "version", "3.5.0"), I(R, "defaultGlobalContainerId", "air-datepicker-global-container"), 
                    K = R.prototype, Object.assign(K, N), t.default;
                }();
            }));
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        __webpack_require__.n = module => {
            var getter = module && module.__esModule ? () => module["default"] : () => module;
            __webpack_require__.d(getter, {
                a: getter
            });
            return getter;
        };
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key]
            });
        };
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        "use strict";
        const modules_flsModules = {};
        function isWebp() {
            function testWebP(callback) {
                let webP = new Image;
                webP.onload = webP.onerror = function() {
                    callback(webP.height == 2);
                };
                webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
            }
            testWebP((function(support) {
                let className = support === true ? "webp" : "no-webp";
                document.documentElement.classList.add(className);
            }));
        }
        function getHash() {
            if (location.hash) return location.hash.replace("#", "");
        }
        function setHash(hash) {
            hash = hash ? `#${hash}` : window.location.href.split("#")[0];
            history.pushState("", "", hash);
        }
        let _slideUp = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = `${target.offsetHeight}px`;
                target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                window.setTimeout((() => {
                    target.hidden = !showmore ? true : false;
                    !showmore ? target.style.removeProperty("height") : null;
                    target.style.removeProperty("padding-top");
                    target.style.removeProperty("padding-bottom");
                    target.style.removeProperty("margin-top");
                    target.style.removeProperty("margin-bottom");
                    !showmore ? target.style.removeProperty("overflow") : null;
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideUpDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideDown = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.hidden = target.hidden ? false : null;
                showmore ? target.style.removeProperty("height") : null;
                let height = target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                target.offsetHeight;
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = height + "px";
                target.style.removeProperty("padding-top");
                target.style.removeProperty("padding-bottom");
                target.style.removeProperty("margin-top");
                target.style.removeProperty("margin-bottom");
                window.setTimeout((() => {
                    target.style.removeProperty("height");
                    target.style.removeProperty("overflow");
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideDownDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideToggle = (target, duration = 500) => {
            if (target.hidden) return _slideDown(target, duration); else return _slideUp(target, duration);
        };
        let bodyLockStatus = true;
        let bodyLockToggle = (delay = 500) => {
            if (document.documentElement.classList.contains("lock")) bodyUnlock(delay); else bodyLock(delay);
        };
        let bodyUnlock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    for (let index = 0; index < lock_padding.length; index++) {
                        const el = lock_padding[index];
                        el.style.paddingRight = "0px";
                    }
                    body.style.paddingRight = "0px";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                for (let index = 0; index < lock_padding.length; index++) {
                    const el = lock_padding[index];
                    el.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                }
                body.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        function spollers() {
            const spollersArray = document.querySelectorAll("[data-spollers]");
            if (spollersArray.length > 0) {
                document.addEventListener("click", setSpollerAction);
                const spollersRegular = Array.from(spollersArray).filter((function(item, index, self) {
                    return !item.dataset.spollers.split(",")[0];
                }));
                if (spollersRegular.length) initSpollers(spollersRegular);
                let mdQueriesArray = dataMediaQueries(spollersArray, "spollers");
                if (mdQueriesArray && mdQueriesArray.length) mdQueriesArray.forEach((mdQueriesItem => {
                    mdQueriesItem.matchMedia.addEventListener("change", (function() {
                        initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                    initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                }));
                function initSpollers(spollersArray, matchMedia = false) {
                    spollersArray.forEach((spollersBlock => {
                        spollersBlock = matchMedia ? spollersBlock.item : spollersBlock;
                        if (matchMedia.matches || !matchMedia) {
                            spollersBlock.classList.add("_spoller-init");
                            initSpollerBody(spollersBlock);
                        } else {
                            spollersBlock.classList.remove("_spoller-init");
                            initSpollerBody(spollersBlock, false);
                        }
                    }));
                }
                function initSpollerBody(spollersBlock, hideSpollerBody = true) {
                    let spollerItems = spollersBlock.querySelectorAll("details");
                    if (spollerItems.length) spollerItems.forEach((spollerItem => {
                        let spollerTitle = spollerItem.querySelector("summary");
                        if (hideSpollerBody) {
                            spollerTitle.removeAttribute("tabindex");
                            if (!spollerItem.hasAttribute("data-open")) {
                                spollerItem.open = false;
                                spollerTitle.nextElementSibling.hidden = true;
                            } else {
                                spollerTitle.classList.add("_spoller-active");
                                spollerItem.open = true;
                            }
                        } else {
                            spollerTitle.setAttribute("tabindex", "-1");
                            spollerTitle.classList.remove("_spoller-active");
                            spollerItem.open = true;
                            spollerTitle.nextElementSibling ? spollerTitle.nextElementSibling.hidden = false : null;
                        }
                    }));
                }
                function setSpollerAction(e) {
                    const el = e.target;
                    if (el.closest("summary") && el.closest("[data-spollers]")) {
                        e.preventDefault();
                        if (el.closest("[data-spollers]").classList.contains("_spoller-init")) {
                            const spollerTitle = el.closest("summary");
                            const spollerBlock = spollerTitle.closest("details");
                            const spollersBlock = spollerTitle.closest("[data-spollers]");
                            const oneSpoller = spollersBlock.hasAttribute("data-one-spoller");
                            const scrollSpoller = spollerBlock.hasAttribute("data-spoller-scroll");
                            const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                            if (!spollersBlock.querySelectorAll("._slide").length) {
                                if (oneSpoller && !spollerBlock.open) hideSpollersBody(spollersBlock);
                                !spollerBlock.open ? spollerBlock.open = true : setTimeout((() => {
                                    spollerBlock.open = false;
                                }), spollerSpeed);
                                spollerTitle.classList.toggle("_spoller-active");
                                _slideToggle(spollerTitle.nextElementSibling, spollerSpeed);
                                if (scrollSpoller && spollerTitle.classList.contains("_spoller-active")) {
                                    const scrollSpollerValue = spollerBlock.dataset.spollerScroll;
                                    const scrollSpollerOffset = +scrollSpollerValue ? +scrollSpollerValue : 0;
                                    const scrollSpollerNoHeader = spollerBlock.hasAttribute("data-spoller-scroll-noheader") ? document.querySelector(".header").offsetHeight : 0;
                                    window.scrollTo({
                                        top: spollerBlock.offsetTop - (scrollSpollerOffset + scrollSpollerNoHeader),
                                        behavior: "smooth"
                                    });
                                }
                            }
                        }
                    }
                    if (!el.closest("[data-spollers]")) {
                        const spollersClose = document.querySelectorAll("[data-spoller-close]");
                        if (spollersClose.length) spollersClose.forEach((spollerClose => {
                            const spollersBlock = spollerClose.closest("[data-spollers]");
                            const spollerCloseBlock = spollerClose.parentNode;
                            if (spollersBlock.classList.contains("_spoller-init")) {
                                const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                                spollerClose.classList.remove("_spoller-active");
                                _slideUp(spollerClose.nextElementSibling, spollerSpeed);
                                setTimeout((() => {
                                    spollerCloseBlock.open = false;
                                }), spollerSpeed);
                            }
                        }));
                    }
                }
                function hideSpollersBody(spollersBlock) {
                    const spollerActiveBlock = spollersBlock.querySelector("details[open]");
                    if (spollerActiveBlock && !spollersBlock.querySelectorAll("._slide").length) {
                        const spollerActiveTitle = spollerActiveBlock.querySelector("summary");
                        const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                        spollerActiveTitle.classList.remove("_spoller-active");
                        _slideUp(spollerActiveTitle.nextElementSibling, spollerSpeed);
                        setTimeout((() => {
                            spollerActiveBlock.open = false;
                        }), spollerSpeed);
                    }
                }
            }
        }
        function tabs() {
            const tabs = document.querySelectorAll("[data-tabs]");
            let tabsActiveHash = [];
            if (tabs.length > 0) {
                const hash = getHash();
                if (hash && hash.startsWith("tab-")) tabsActiveHash = hash.replace("tab-", "").split("-");
                tabs.forEach(((tabsBlock, index) => {
                    tabsBlock.classList.add("_tab-init");
                    tabsBlock.setAttribute("data-tabs-index", index);
                    tabsBlock.addEventListener("click", setTabsAction);
                    initTabs(tabsBlock);
                }));
                let mdQueriesArray = dataMediaQueries(tabs, "tabs");
                if (mdQueriesArray && mdQueriesArray.length) mdQueriesArray.forEach((mdQueriesItem => {
                    mdQueriesItem.matchMedia.addEventListener("change", (function() {
                        setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                    setTitlePosition(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                }));
            }
            function setTitlePosition(tabsMediaArray, matchMedia) {
                tabsMediaArray.forEach((tabsMediaItem => {
                    tabsMediaItem = tabsMediaItem.item;
                    let tabsTitles = tabsMediaItem.querySelector("[data-tabs-titles]");
                    let tabsTitleItems = tabsMediaItem.querySelectorAll("[data-tabs-title]");
                    let tabsContent = tabsMediaItem.querySelector("[data-tabs-body]");
                    let tabsContentItems = tabsMediaItem.querySelectorAll("[data-tabs-item]");
                    tabsTitleItems = Array.from(tabsTitleItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems = Array.from(tabsContentItems).filter((item => item.closest("[data-tabs]") === tabsMediaItem));
                    tabsContentItems.forEach(((tabsContentItem, index) => {
                        if (matchMedia.matches) {
                            tabsContent.append(tabsTitleItems[index]);
                            tabsContent.append(tabsContentItem);
                            tabsMediaItem.classList.add("_tab-spoller");
                        } else {
                            tabsTitles.append(tabsTitleItems[index]);
                            tabsMediaItem.classList.remove("_tab-spoller");
                        }
                    }));
                }));
            }
            function initTabs(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-titles]>*");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-body]>*");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                const tabsActiveHashBlock = tabsActiveHash[0] == tabsBlockIndex;
                if (tabsActiveHashBlock) {
                    const tabsActiveTitle = tabsBlock.querySelector("[data-tabs-titles]>._tab-active");
                    tabsActiveTitle ? tabsActiveTitle.classList.remove("_tab-active") : null;
                }
                if (tabsContent.length) tabsContent.forEach(((tabsContentItem, index) => {
                    tabsTitles[index].setAttribute("data-tabs-title", "");
                    tabsContentItem.setAttribute("data-tabs-item", "");
                    if (tabsActiveHashBlock && index == tabsActiveHash[1]) tabsTitles[index].classList.add("_tab-active");
                    tabsContentItem.hidden = !tabsTitles[index].classList.contains("_tab-active");
                }));
            }
            function setTabsStatus(tabsBlock) {
                let tabsTitles = tabsBlock.querySelectorAll("[data-tabs-title]");
                let tabsContent = tabsBlock.querySelectorAll("[data-tabs-item]");
                const tabsBlockIndex = tabsBlock.dataset.tabsIndex;
                function isTabsAnamate(tabsBlock) {
                    if (tabsBlock.hasAttribute("data-tabs-animate")) return tabsBlock.dataset.tabsAnimate > 0 ? Number(tabsBlock.dataset.tabsAnimate) : 500;
                }
                const tabsBlockAnimate = isTabsAnamate(tabsBlock);
                if (tabsContent.length > 0) {
                    const isHash = tabsBlock.hasAttribute("data-tabs-hash");
                    tabsContent = Array.from(tabsContent).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsTitles = Array.from(tabsTitles).filter((item => item.closest("[data-tabs]") === tabsBlock));
                    tabsContent.forEach(((tabsContentItem, index) => {
                        if (tabsTitles[index].classList.contains("_tab-active")) {
                            if (tabsBlockAnimate) _slideDown(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = false;
                            if (isHash && !tabsContentItem.closest(".popup")) setHash(`tab-${tabsBlockIndex}-${index}`);
                        } else if (tabsBlockAnimate) _slideUp(tabsContentItem, tabsBlockAnimate); else tabsContentItem.hidden = true;
                    }));
                }
            }
            function setTabsAction(e) {
                const el = e.target;
                if (el.closest("[data-tabs-title]")) {
                    const tabTitle = el.closest("[data-tabs-title]");
                    const tabsBlock = tabTitle.closest("[data-tabs]");
                    if (!tabTitle.classList.contains("_tab-active") && !tabsBlock.querySelector("._slide")) {
                        let tabActiveTitle = tabsBlock.querySelectorAll("[data-tabs-title]._tab-active");
                        tabActiveTitle.length ? tabActiveTitle = Array.from(tabActiveTitle).filter((item => item.closest("[data-tabs]") === tabsBlock)) : null;
                        tabActiveTitle.length ? tabActiveTitle[0].classList.remove("_tab-active") : null;
                        tabTitle.classList.add("_tab-active");
                        setTabsStatus(tabsBlock);
                    }
                    e.preventDefault();
                }
            }
        }
        function menuInit() {
            if (document.querySelector(".icon-menu")) document.addEventListener("click", (function(e) {
                if (bodyLockStatus && e.target.closest(".icon-menu")) {
                    bodyLockToggle();
                    document.documentElement.classList.toggle("menu-open");
                }
            }));
        }
        function menuClose() {
            bodyUnlock();
            document.documentElement.classList.remove("menu-open");
        }
        function showMore() {
            window.addEventListener("load", (function(e) {
                const showMoreBlocks = document.querySelectorAll("[data-showmore]");
                let showMoreBlocksRegular;
                let mdQueriesArray;
                if (showMoreBlocks.length) {
                    showMoreBlocksRegular = Array.from(showMoreBlocks).filter((function(item, index, self) {
                        return !item.dataset.showmoreMedia;
                    }));
                    showMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;
                    document.addEventListener("click", showMoreActions);
                    window.addEventListener("resize", showMoreActions);
                    mdQueriesArray = dataMediaQueries(showMoreBlocks, "showmoreMedia");
                    if (mdQueriesArray && mdQueriesArray.length) {
                        mdQueriesArray.forEach((mdQueriesItem => {
                            mdQueriesItem.matchMedia.addEventListener("change", (function() {
                                initItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                            }));
                        }));
                        initItemsMedia(mdQueriesArray);
                    }
                }
                function initItemsMedia(mdQueriesArray) {
                    mdQueriesArray.forEach((mdQueriesItem => {
                        initItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                }
                function initItems(showMoreBlocks, matchMedia) {
                    showMoreBlocks.forEach((showMoreBlock => {
                        initItem(showMoreBlock, matchMedia);
                    }));
                }
                function initItem(showMoreBlock, matchMedia = false) {
                    showMoreBlock = matchMedia ? showMoreBlock.item : showMoreBlock;
                    let showMoreContent = showMoreBlock.querySelectorAll("[data-showmore-content]");
                    let showMoreButton = showMoreBlock.querySelectorAll("[data-showmore-button]");
                    showMoreContent = Array.from(showMoreContent).filter((item => item.closest("[data-showmore]") === showMoreBlock))[0];
                    showMoreButton = Array.from(showMoreButton).filter((item => item.closest("[data-showmore]") === showMoreBlock))[0];
                    const hiddenHeight = getHeight(showMoreBlock, showMoreContent);
                    if (matchMedia.matches || !matchMedia) if (hiddenHeight < getOriginalHeight(showMoreContent)) {
                        _slideUp(showMoreContent, 0, showMoreBlock.classList.contains("_showmore-active") ? getOriginalHeight(showMoreContent) : hiddenHeight);
                        showMoreButton.hidden = false;
                    } else {
                        _slideDown(showMoreContent, 0, hiddenHeight);
                        showMoreButton.hidden = true;
                    } else {
                        _slideDown(showMoreContent, 0, hiddenHeight);
                        showMoreButton.hidden = true;
                    }
                }
                function getHeight(showMoreBlock, showMoreContent) {
                    let hiddenHeight = 0;
                    const showMoreType = showMoreBlock.dataset.showmore ? showMoreBlock.dataset.showmore : "size";
                    const rowGap = parseFloat(getComputedStyle(showMoreContent).rowGap) ? parseFloat(getComputedStyle(showMoreContent).rowGap) : 0;
                    if (showMoreType === "items") {
                        const showMoreTypeValue = showMoreContent.dataset.showmoreContent ? showMoreContent.dataset.showmoreContent : 3;
                        const showMoreItems = showMoreContent.children;
                        for (let index = 1; index < showMoreItems.length; index++) {
                            const showMoreItem = showMoreItems[index - 1];
                            const marginTop = parseFloat(getComputedStyle(showMoreItem).marginTop) ? parseFloat(getComputedStyle(showMoreItem).marginTop) : 0;
                            const marginBottom = parseFloat(getComputedStyle(showMoreItem).marginBottom) ? parseFloat(getComputedStyle(showMoreItem).marginBottom) : 0;
                            hiddenHeight += showMoreItem.offsetHeight + marginTop;
                            if (index == showMoreTypeValue) break;
                            hiddenHeight += marginBottom;
                        }
                        rowGap ? hiddenHeight += (showMoreTypeValue - 1) * rowGap : null;
                    } else {
                        const showMoreTypeValue = showMoreContent.dataset.showmoreContent ? showMoreContent.dataset.showmoreContent : 150;
                        hiddenHeight = showMoreTypeValue;
                    }
                    return hiddenHeight;
                }
                function getOriginalHeight(showMoreContent) {
                    let parentHidden;
                    let hiddenHeight = showMoreContent.offsetHeight;
                    showMoreContent.style.removeProperty("height");
                    if (showMoreContent.closest(`[hidden]`)) {
                        parentHidden = showMoreContent.closest(`[hidden]`);
                        parentHidden.hidden = false;
                    }
                    let originalHeight = showMoreContent.offsetHeight;
                    parentHidden ? parentHidden.hidden = true : null;
                    showMoreContent.style.height = `${hiddenHeight}px`;
                    return originalHeight;
                }
                function showMoreActions(e) {
                    const targetEvent = e.target;
                    const targetType = e.type;
                    if (targetType === "click") {
                        if (targetEvent.closest("[data-showmore-button]")) {
                            const showMoreButton = targetEvent.closest("[data-showmore-button]");
                            const showMoreBlock = showMoreButton.closest("[data-showmore]");
                            const showMoreContent = showMoreBlock.querySelector("[data-showmore-content]");
                            const showMoreSpeed = showMoreBlock.dataset.showmoreButton ? showMoreBlock.dataset.showmoreButton : "500";
                            const hiddenHeight = getHeight(showMoreBlock, showMoreContent);
                            if (!showMoreContent.classList.contains("_slide")) {
                                showMoreBlock.classList.contains("_showmore-active") ? _slideUp(showMoreContent, showMoreSpeed, hiddenHeight) : _slideDown(showMoreContent, showMoreSpeed, hiddenHeight);
                                showMoreBlock.classList.toggle("_showmore-active");
                            }
                        }
                    } else if (targetType === "resize") {
                        showMoreBlocksRegular && showMoreBlocksRegular.length ? initItems(showMoreBlocksRegular) : null;
                        mdQueriesArray && mdQueriesArray.length ? initItemsMedia(mdQueriesArray) : null;
                    }
                }
            }));
        }
        function functions_FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        function uniqArray(array) {
            return array.filter((function(item, index, self) {
                return self.indexOf(item) === index;
            }));
        }
        function dataMediaQueries(array, dataSetValue) {
            const media = Array.from(array).filter((function(item, index, self) {
                if (item.dataset[dataSetValue]) return item.dataset[dataSetValue].split(",")[0];
            }));
            if (media.length) {
                const breakpointsArray = [];
                media.forEach((item => {
                    const params = item.dataset[dataSetValue];
                    const breakpoint = {};
                    const paramsArray = params.split(",");
                    breakpoint.value = paramsArray[0];
                    breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
                    breakpoint.item = item;
                    breakpointsArray.push(breakpoint);
                }));
                let mdQueries = breakpointsArray.map((function(item) {
                    return "(" + item.type + "-width: " + item.value + "px)," + item.value + "," + item.type;
                }));
                mdQueries = uniqArray(mdQueries);
                const mdQueriesArray = [];
                if (mdQueries.length) {
                    mdQueries.forEach((breakpoint => {
                        const paramsArray = breakpoint.split(",");
                        const mediaBreakpoint = paramsArray[1];
                        const mediaType = paramsArray[2];
                        const matchMedia = window.matchMedia(paramsArray[0]);
                        const itemsArray = breakpointsArray.filter((function(item) {
                            if (item.value === mediaBreakpoint && item.type === mediaType) return true;
                        }));
                        mdQueriesArray.push({
                            itemsArray,
                            matchMedia
                        });
                    }));
                    return mdQueriesArray;
                }
            }
        }
        !function(e) {
            "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? module.exports = e() : window.wNumb = e();
        }((function() {
            "use strict";
            var o = [ "decimals", "thousand", "mark", "prefix", "suffix", "encoder", "decoder", "negativeBefore", "negative", "edit", "undo" ];
            function w(e) {
                return e.split("").reverse().join("");
            }
            function h(e, t) {
                return e.substring(0, t.length) === t;
            }
            function f(e, t, n) {
                if ((e[t] || e[n]) && e[t] === e[n]) throw new Error(t);
            }
            function x(e) {
                return "number" == typeof e && isFinite(e);
            }
            function n(e, t, n, r, i, o, f, u, s, c, a, p) {
                var d, l, h, g = p, v = "", m = "";
                return o && (p = o(p)), !!x(p) && (!1 !== e && 0 === parseFloat(p.toFixed(e)) && (p = 0), 
                p < 0 && (d = !0, p = Math.abs(p)), !1 !== e && (p = function(e, t) {
                    return e = e.toString().split("e"), (+((e = (e = Math.round(+(e[0] + "e" + (e[1] ? +e[1] + t : t)))).toString().split("e"))[0] + "e" + (e[1] ? e[1] - t : -t))).toFixed(t);
                }(p, e)), -1 !== (p = p.toString()).indexOf(".") ? (h = (l = p.split("."))[0], n && (v = n + l[1])) : h = p, 
                t && (h = w((h = w(h).match(/.{1,3}/g)).join(w(t)))), d && u && (m += u), r && (m += r), 
                d && s && (m += s), m += h, m += v, i && (m += i), c && (m = c(m, g)), m);
            }
            function r(e, t, n, r, i, o, f, u, s, c, a, p) {
                var d, l = "";
                return a && (p = a(p)), !(!p || "string" != typeof p) && (u && h(p, u) && (p = p.replace(u, ""), 
                d = !0), r && h(p, r) && (p = p.replace(r, "")), s && h(p, s) && (p = p.replace(s, ""), 
                d = !0), i && function(e, t) {
                    return e.slice(-1 * t.length) === t;
                }(p, i) && (p = p.slice(0, -1 * i.length)), t && (p = p.split(t).join("")), n && (p = p.replace(n, ".")), 
                d && (l += "-"), "" !== (l = (l += p).replace(/[^0-9\.\-.]/g, "")) && (l = Number(l), 
                f && (l = f(l)), !!x(l) && l));
            }
            function i(e, t, n) {
                var r, i = [];
                for (r = 0; r < o.length; r += 1) i.push(e[o[r]]);
                return i.push(n), t.apply("", i);
            }
            return function e(t) {
                if (!(this instanceof e)) return new e(t);
                "object" == typeof t && (t = function(e) {
                    var t, n, r, i = {};
                    for (void 0 === e.suffix && (e.suffix = e.postfix), t = 0; t < o.length; t += 1) if (void 0 === (r = e[n = o[t]])) "negative" !== n || i.negativeBefore ? "mark" === n && "." !== i.thousand ? i[n] = "." : i[n] = !1 : i[n] = "-"; else if ("decimals" === n) {
                        if (!(0 <= r && r < 8)) throw new Error(n);
                        i[n] = r;
                    } else if ("encoder" === n || "decoder" === n || "edit" === n || "undo" === n) {
                        if ("function" != typeof r) throw new Error(n);
                        i[n] = r;
                    } else {
                        if ("string" != typeof r) throw new Error(n);
                        i[n] = r;
                    }
                    return f(i, "mark", "thousand"), f(i, "prefix", "negative"), f(i, "prefix", "negativeBefore"), 
                    i;
                }(t), this.to = function(e) {
                    return i(t, n, e);
                }, this.from = function(e) {
                    return i(t, r, e);
                });
            };
        }));
        class Popup {
            constructor(options) {
                let config = {
                    logging: true,
                    init: true,
                    attributeOpenButton: "data-popup",
                    attributeCloseButton: "data-close",
                    fixElementSelector: "[data-lp]",
                    youtubeAttribute: "data-popup-youtube",
                    youtubePlaceAttribute: "data-popup-youtube-place",
                    setAutoplayYoutube: true,
                    classes: {
                        popup: "popup",
                        popupContent: "popup__content",
                        popupActive: "popup_show",
                        bodyActive: "popup-show"
                    },
                    focusCatch: true,
                    closeEsc: true,
                    bodyLock: true,
                    hashSettings: {
                        location: true,
                        goHash: true
                    },
                    on: {
                        beforeOpen: function() {},
                        afterOpen: function() {},
                        beforeClose: function() {},
                        afterClose: function() {}
                    }
                };
                this.youTubeCode;
                this.isOpen = false;
                this.targetOpen = {
                    selector: false,
                    element: false
                };
                this.previousOpen = {
                    selector: false,
                    element: false
                };
                this.lastClosed = {
                    selector: false,
                    element: false
                };
                this._dataValue = false;
                this.hash = false;
                this._reopen = false;
                this._selectorOpen = false;
                this.lastFocusEl = false;
                this._focusEl = [ "a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])' ];
                this.options = {
                    ...config,
                    ...options,
                    classes: {
                        ...config.classes,
                        ...options?.classes
                    },
                    hashSettings: {
                        ...config.hashSettings,
                        ...options?.hashSettings
                    },
                    on: {
                        ...config.on,
                        ...options?.on
                    }
                };
                this.bodyLock = false;
                this.options.init ? this.initPopups() : null;
            }
            initPopups() {
                this.popupLogging(`Проснулся`);
                this.eventsPopup();
            }
            eventsPopup() {
                document.addEventListener("click", function(e) {
                    const buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);
                    if (buttonOpen) {
                        e.preventDefault();
                        this._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ? buttonOpen.getAttribute(this.options.attributeOpenButton) : "error";
                        this.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ? buttonOpen.getAttribute(this.options.youtubeAttribute) : null;
                        if (this._dataValue !== "error") {
                            if (!this.isOpen) this.lastFocusEl = buttonOpen;
                            this.targetOpen.selector = `${this._dataValue}`;
                            this._selectorOpen = true;
                            this.open();
                            return;
                        } else this.popupLogging(`Йой, не заполнен атрибут в ${buttonOpen.classList}`);
                        return;
                    }
                    const buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);
                    if (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen && !e.target.closest(".popup__wrapper")) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    if (this.options.closeEsc && e.which == 27 && e.code === "Escape" && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                    if (this.options.focusCatch && e.which == 9 && this.isOpen) {
                        this._focusCatch(e);
                        return;
                    }
                }.bind(this));
                if (this.options.hashSettings.goHash) {
                    window.addEventListener("hashchange", function() {
                        if (window.location.hash) this._openToHash(); else this.close(this.targetOpen.selector);
                    }.bind(this));
                    window.addEventListener("load", function() {
                        if (window.location.hash) this._openToHash();
                    }.bind(this));
                }
            }
            open(selectorValue) {
                if (bodyLockStatus) {
                    this.bodyLock = document.documentElement.classList.contains("lock") && !this.isOpen ? true : false;
                    if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") {
                        this.targetOpen.selector = selectorValue;
                        this._selectorOpen = true;
                    }
                    if (this.isOpen) {
                        this._reopen = true;
                        this.close();
                    }
                    if (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;
                    if (!this._reopen) this.previousActiveElement = document.activeElement;
                    this.targetOpen.element = document.querySelector(this.targetOpen.selector);
                    if (this.targetOpen.element) {
                        if (this.youTubeCode) {
                            const codeVideo = this.youTubeCode;
                            const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
                            const iframe = document.createElement("iframe");
                            iframe.setAttribute("allowfullscreen", "");
                            const autoplay = this.options.setAutoplayYoutube ? "autoplay;" : "";
                            iframe.setAttribute("allow", `${autoplay}; encrypted-media`);
                            iframe.setAttribute("src", urlVideo);
                            if (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {
                                this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "");
                            }
                            this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);
                        }
                        if (this.options.hashSettings.location) {
                            this._getHash();
                            this._setHash();
                        }
                        this.options.on.beforeOpen(this);
                        document.dispatchEvent(new CustomEvent("beforePopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.targetOpen.element.classList.add(this.options.classes.popupActive);
                        document.documentElement.classList.add(this.options.classes.bodyActive);
                        if (!this._reopen) !this.bodyLock ? bodyLock() : null; else this._reopen = false;
                        this.targetOpen.element.setAttribute("aria-hidden", "false");
                        this.previousOpen.selector = this.targetOpen.selector;
                        this.previousOpen.element = this.targetOpen.element;
                        this._selectorOpen = false;
                        this.isOpen = true;
                        setTimeout((() => {
                            this._focusTrap();
                        }), 50);
                        this.options.on.afterOpen(this);
                        document.dispatchEvent(new CustomEvent("afterPopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.popupLogging(`Открыл попап`);
                    } else this.popupLogging(`Ей, такого попа нет. Проверьте корректность ввода. `);
                }
            }
            close(selectorValue) {
                if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") this.previousOpen.selector = selectorValue;
                if (!this.isOpen || !bodyLockStatus) return;
                this.options.on.beforeClose(this);
                document.dispatchEvent(new CustomEvent("beforePopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                if (this.youTubeCode) if (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = "";
                this.previousOpen.element.classList.remove(this.options.classes.popupActive);
                this.previousOpen.element.setAttribute("aria-hidden", "true");
                if (!this._reopen) {
                    document.documentElement.classList.remove(this.options.classes.bodyActive);
                    !this.bodyLock ? bodyUnlock() : null;
                    this.isOpen = false;
                }
                this._removeHash();
                if (this._selectorOpen) {
                    this.lastClosed.selector = this.previousOpen.selector;
                    this.lastClosed.element = this.previousOpen.element;
                }
                this.options.on.afterClose(this);
                document.dispatchEvent(new CustomEvent("afterPopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                setTimeout((() => {
                    this._focusTrap();
                }), 50);
                this.popupLogging(`Закрыл попап`);
            }
            _getHash() {
                if (this.options.hashSettings.location) this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#");
            }
            _openToHash() {
                let classInHash = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null;
                const buttons = document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash.replace(".", "#")}"]`);
                this.youTubeCode = buttons.getAttribute(this.options.youtubeAttribute) ? buttons.getAttribute(this.options.youtubeAttribute) : null;
                if (buttons && classInHash) this.open(classInHash);
            }
            _setHash() {
                history.pushState("", "", this.hash);
            }
            _removeHash() {
                history.pushState("", "", window.location.href.split("#")[0]);
            }
            _focusCatch(e) {
                const focusable = this.targetOpen.element.querySelectorAll(this._focusEl);
                const focusArray = Array.prototype.slice.call(focusable);
                const focusedIndex = focusArray.indexOf(document.activeElement);
                if (e.shiftKey && focusedIndex === 0) {
                    focusArray[focusArray.length - 1].focus();
                    e.preventDefault();
                }
                if (!e.shiftKey && focusedIndex === focusArray.length - 1) {
                    focusArray[0].focus();
                    e.preventDefault();
                }
            }
            _focusTrap() {
                const focusable = this.previousOpen.element.querySelectorAll(this._focusEl);
                if (!this.isOpen && this.lastFocusEl) this.lastFocusEl.focus(); else focusable[0].focus();
            }
            popupLogging(message) {
                this.options.logging ? functions_FLS(`[Попапос]: ${message}`) : null;
            }
        }
        modules_flsModules.popup = new Popup({});
        let gotoblock_gotoBlock = (targetBlock, noHeader = false, speed = 500, offsetTop = 0) => {
            const targetBlockElement = document.querySelector(targetBlock);
            if (targetBlockElement) {
                let headerItem = "";
                let headerItemHeight = 0;
                if (noHeader) {
                    headerItem = "header.header";
                    const headerElement = document.querySelector(headerItem);
                    if (!headerElement.classList.contains("_header-scroll")) {
                        headerElement.style.cssText = `transition-duration: 0s;`;
                        headerElement.classList.add("_header-scroll");
                        headerItemHeight = headerElement.offsetHeight;
                        headerElement.classList.remove("_header-scroll");
                        setTimeout((() => {
                            headerElement.style.cssText = ``;
                        }), 0);
                    } else headerItemHeight = headerElement.offsetHeight;
                }
                let options = {
                    speedAsDuration: true,
                    speed,
                    header: headerItem,
                    offset: offsetTop,
                    easing: "easeOutQuad"
                };
                document.documentElement.classList.contains("menu-open") ? menuClose() : null;
                if (typeof SmoothScroll !== "undefined") (new SmoothScroll).animateScroll(targetBlockElement, "", options); else {
                    let targetBlockElementPosition = targetBlockElement.getBoundingClientRect().top + scrollY;
                    targetBlockElementPosition = headerItemHeight ? targetBlockElementPosition - headerItemHeight : targetBlockElementPosition;
                    targetBlockElementPosition = offsetTop ? targetBlockElementPosition - offsetTop : targetBlockElementPosition;
                    window.scrollTo({
                        top: targetBlockElementPosition,
                        behavior: "smooth"
                    });
                }
                functions_FLS(`[gotoBlock]: Юхуу...едем в ${targetBlock}`);
            } else functions_FLS(`[gotoBlock]: Ей... Такого блока нет на странице: ${targetBlock}`);
        };
        function formQuantity() {
            document.addEventListener("click", (function(e) {
                let targetElement = e.target;
                if (targetElement.closest("[data-quantity-plus]") || targetElement.closest("[data-quantity-minus]")) {
                    const valueElement = targetElement.closest("[data-quantity]").querySelector("[data-quantity-value]");
                    let value = parseInt(valueElement.value);
                    if (targetElement.hasAttribute("data-quantity-plus")) {
                        value++;
                        if (+valueElement.dataset.quantityMax && +valueElement.dataset.quantityMax < value) value = valueElement.dataset.quantityMax;
                    } else {
                        --value;
                        if (+valueElement.dataset.quantityMin) {
                            if (+valueElement.dataset.quantityMin > value) value = valueElement.dataset.quantityMin;
                        } else if (value < 1) value = 0;
                    }
                    targetElement.closest("[data-quantity]").querySelector("[data-quantity-value]").value = value;
                }
            }));
        }
        var PipsMode;
        (function(PipsMode) {
            PipsMode["Range"] = "range";
            PipsMode["Steps"] = "steps";
            PipsMode["Positions"] = "positions";
            PipsMode["Count"] = "count";
            PipsMode["Values"] = "values";
        })(PipsMode || (PipsMode = {}));
        var PipsType;
        (function(PipsType) {
            PipsType[PipsType["None"] = -1] = "None";
            PipsType[PipsType["NoValue"] = 0] = "NoValue";
            PipsType[PipsType["LargeValue"] = 1] = "LargeValue";
            PipsType[PipsType["SmallValue"] = 2] = "SmallValue";
        })(PipsType || (PipsType = {}));
        function isValidFormatter(entry) {
            return isValidPartialFormatter(entry) && typeof entry.from === "function";
        }
        function isValidPartialFormatter(entry) {
            return typeof entry === "object" && typeof entry.to === "function";
        }
        function removeElement(el) {
            el.parentElement.removeChild(el);
        }
        function isSet(value) {
            return value !== null && value !== void 0;
        }
        function preventDefault(e) {
            e.preventDefault();
        }
        function unique(array) {
            return array.filter((function(a) {
                return !this[a] ? this[a] = true : false;
            }), {});
        }
        function closest(value, to) {
            return Math.round(value / to) * to;
        }
        function offset(elem, orientation) {
            var rect = elem.getBoundingClientRect();
            var doc = elem.ownerDocument;
            var docElem = doc.documentElement;
            var pageOffset = getPageOffset(doc);
            if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) pageOffset.x = 0;
            return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;
        }
        function isNumeric(a) {
            return typeof a === "number" && !isNaN(a) && isFinite(a);
        }
        function addClassFor(element, className, duration) {
            if (duration > 0) {
                addClass(element, className);
                setTimeout((function() {
                    removeClass(element, className);
                }), duration);
            }
        }
        function limit(a) {
            return Math.max(Math.min(a, 100), 0);
        }
        function asArray(a) {
            return Array.isArray(a) ? a : [ a ];
        }
        function countDecimals(numStr) {
            numStr = String(numStr);
            var pieces = numStr.split(".");
            return pieces.length > 1 ? pieces[1].length : 0;
        }
        function addClass(el, className) {
            if (el.classList && !/\s/.test(className)) el.classList.add(className); else el.className += " " + className;
        }
        function removeClass(el, className) {
            if (el.classList && !/\s/.test(className)) el.classList.remove(className); else el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
        }
        function hasClass(el, className) {
            return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className);
        }
        function getPageOffset(doc) {
            var supportPageOffset = window.pageXOffset !== void 0;
            var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";
            var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
            var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
            return {
                x,
                y
            };
        }
        function getActions() {
            return window.navigator.pointerEnabled ? {
                start: "pointerdown",
                move: "pointermove",
                end: "pointerup"
            } : window.navigator.msPointerEnabled ? {
                start: "MSPointerDown",
                move: "MSPointerMove",
                end: "MSPointerUp"
            } : {
                start: "mousedown touchstart",
                move: "mousemove touchmove",
                end: "mouseup touchend"
            };
        }
        function getSupportsPassive() {
            var supportsPassive = false;
            try {
                var opts = Object.defineProperty({}, "passive", {
                    get: function() {
                        supportsPassive = true;
                    }
                });
                window.addEventListener("test", null, opts);
            } catch (e) {}
            return supportsPassive;
        }
        function getSupportsTouchActionNone() {
            return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
        }
        function subRangeRatio(pa, pb) {
            return 100 / (pb - pa);
        }
        function fromPercentage(range, value, startRange) {
            return value * 100 / (range[startRange + 1] - range[startRange]);
        }
        function toPercentage(range, value) {
            return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);
        }
        function isPercentage(range, value) {
            return value * (range[1] - range[0]) / 100 + range[0];
        }
        function getJ(value, arr) {
            var j = 1;
            while (value >= arr[j]) j += 1;
            return j;
        }
        function toStepping(xVal, xPct, value) {
            if (value >= xVal.slice(-1)[0]) return 100;
            var j = getJ(value, xVal);
            var va = xVal[j - 1];
            var vb = xVal[j];
            var pa = xPct[j - 1];
            var pb = xPct[j];
            return pa + toPercentage([ va, vb ], value) / subRangeRatio(pa, pb);
        }
        function fromStepping(xVal, xPct, value) {
            if (value >= 100) return xVal.slice(-1)[0];
            var j = getJ(value, xPct);
            var va = xVal[j - 1];
            var vb = xVal[j];
            var pa = xPct[j - 1];
            var pb = xPct[j];
            return isPercentage([ va, vb ], (value - pa) * subRangeRatio(pa, pb));
        }
        function getStep(xPct, xSteps, snap, value) {
            if (value === 100) return value;
            var j = getJ(value, xPct);
            var a = xPct[j - 1];
            var b = xPct[j];
            if (snap) {
                if (value - a > (b - a) / 2) return b;
                return a;
            }
            if (!xSteps[j - 1]) return value;
            return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
        }
        var Spectrum = function() {
            function Spectrum(entry, snap, singleStep) {
                this.xPct = [];
                this.xVal = [];
                this.xSteps = [];
                this.xNumSteps = [];
                this.xHighestCompleteStep = [];
                this.xSteps = [ singleStep || false ];
                this.xNumSteps = [ false ];
                this.snap = snap;
                var index;
                var ordered = [];
                Object.keys(entry).forEach((function(index) {
                    ordered.push([ asArray(entry[index]), index ]);
                }));
                ordered.sort((function(a, b) {
                    return a[0][0] - b[0][0];
                }));
                for (index = 0; index < ordered.length; index++) this.handleEntryPoint(ordered[index][1], ordered[index][0]);
                this.xNumSteps = this.xSteps.slice(0);
                for (index = 0; index < this.xNumSteps.length; index++) this.handleStepPoint(index, this.xNumSteps[index]);
            }
            Spectrum.prototype.getDistance = function(value) {
                var distances = [];
                for (var index = 0; index < this.xNumSteps.length - 1; index++) distances[index] = fromPercentage(this.xVal, value, index);
                return distances;
            };
            Spectrum.prototype.getAbsoluteDistance = function(value, distances, direction) {
                var xPct_index = 0;
                if (value < this.xPct[this.xPct.length - 1]) while (value > this.xPct[xPct_index + 1]) xPct_index++; else if (value === this.xPct[this.xPct.length - 1]) xPct_index = this.xPct.length - 2;
                if (!direction && value === this.xPct[xPct_index + 1]) xPct_index++;
                if (distances === null) distances = [];
                var start_factor;
                var rest_factor = 1;
                var rest_rel_distance = distances[xPct_index];
                var range_pct = 0;
                var rel_range_distance = 0;
                var abs_distance_counter = 0;
                var range_counter = 0;
                if (direction) start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]); else start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);
                while (rest_rel_distance > 0) {
                    range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];
                    if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {
                        rel_range_distance = range_pct * start_factor;
                        rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];
                        start_factor = 1;
                    } else {
                        rel_range_distance = distances[xPct_index + range_counter] * range_pct / 100 * rest_factor;
                        rest_factor = 0;
                    }
                    if (direction) {
                        abs_distance_counter -= rel_range_distance;
                        if (this.xPct.length + range_counter >= 1) range_counter--;
                    } else {
                        abs_distance_counter += rel_range_distance;
                        if (this.xPct.length - range_counter >= 1) range_counter++;
                    }
                    rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;
                }
                return value + abs_distance_counter;
            };
            Spectrum.prototype.toStepping = function(value) {
                value = toStepping(this.xVal, this.xPct, value);
                return value;
            };
            Spectrum.prototype.fromStepping = function(value) {
                return fromStepping(this.xVal, this.xPct, value);
            };
            Spectrum.prototype.getStep = function(value) {
                value = getStep(this.xPct, this.xSteps, this.snap, value);
                return value;
            };
            Spectrum.prototype.getDefaultStep = function(value, isDown, size) {
                var j = getJ(value, this.xPct);
                if (value === 100 || isDown && value === this.xPct[j - 1]) j = Math.max(j - 1, 1);
                return (this.xVal[j] - this.xVal[j - 1]) / size;
            };
            Spectrum.prototype.getNearbySteps = function(value) {
                var j = getJ(value, this.xPct);
                return {
                    stepBefore: {
                        startValue: this.xVal[j - 2],
                        step: this.xNumSteps[j - 2],
                        highestStep: this.xHighestCompleteStep[j - 2]
                    },
                    thisStep: {
                        startValue: this.xVal[j - 1],
                        step: this.xNumSteps[j - 1],
                        highestStep: this.xHighestCompleteStep[j - 1]
                    },
                    stepAfter: {
                        startValue: this.xVal[j],
                        step: this.xNumSteps[j],
                        highestStep: this.xHighestCompleteStep[j]
                    }
                };
            };
            Spectrum.prototype.countStepDecimals = function() {
                var stepDecimals = this.xNumSteps.map(countDecimals);
                return Math.max.apply(null, stepDecimals);
            };
            Spectrum.prototype.hasNoSize = function() {
                return this.xVal[0] === this.xVal[this.xVal.length - 1];
            };
            Spectrum.prototype.convert = function(value) {
                return this.getStep(this.toStepping(value));
            };
            Spectrum.prototype.handleEntryPoint = function(index, value) {
                var percentage;
                if (index === "min") percentage = 0; else if (index === "max") percentage = 100; else percentage = parseFloat(index);
                if (!isNumeric(percentage) || !isNumeric(value[0])) throw new Error("noUiSlider: 'range' value isn't numeric.");
                this.xPct.push(percentage);
                this.xVal.push(value[0]);
                var value1 = Number(value[1]);
                if (!percentage) {
                    if (!isNaN(value1)) this.xSteps[0] = value1;
                } else this.xSteps.push(isNaN(value1) ? false : value1);
                this.xHighestCompleteStep.push(0);
            };
            Spectrum.prototype.handleStepPoint = function(i, n) {
                if (!n) return;
                if (this.xVal[i] === this.xVal[i + 1]) {
                    this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];
                    return;
                }
                this.xSteps[i] = fromPercentage([ this.xVal[i], this.xVal[i + 1] ], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);
                var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];
                var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
                var step = this.xVal[i] + this.xNumSteps[i] * highestStep;
                this.xHighestCompleteStep[i] = step;
            };
            return Spectrum;
        }();
        var defaultFormatter = {
            to: function(value) {
                return value === void 0 ? "" : value.toFixed(2);
            },
            from: Number
        };
        var cssClasses = {
            target: "target",
            base: "base",
            origin: "origin",
            handle: "handle",
            handleLower: "handle-lower",
            handleUpper: "handle-upper",
            touchArea: "touch-area",
            horizontal: "horizontal",
            vertical: "vertical",
            background: "background",
            connect: "connect",
            connects: "connects",
            ltr: "ltr",
            rtl: "rtl",
            textDirectionLtr: "txt-dir-ltr",
            textDirectionRtl: "txt-dir-rtl",
            draggable: "draggable",
            drag: "state-drag",
            tap: "state-tap",
            active: "active",
            tooltip: "tooltip",
            pips: "pips",
            pipsHorizontal: "pips-horizontal",
            pipsVertical: "pips-vertical",
            marker: "marker",
            markerHorizontal: "marker-horizontal",
            markerVertical: "marker-vertical",
            markerNormal: "marker-normal",
            markerLarge: "marker-large",
            markerSub: "marker-sub",
            value: "value",
            valueHorizontal: "value-horizontal",
            valueVertical: "value-vertical",
            valueNormal: "value-normal",
            valueLarge: "value-large",
            valueSub: "value-sub"
        };
        var INTERNAL_EVENT_NS = {
            tooltips: ".__tooltips",
            aria: ".__aria"
        };
        function testStep(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'step' is not numeric.");
            parsed.singleStep = entry;
        }
        function testKeyboardPageMultiplier(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
            parsed.keyboardPageMultiplier = entry;
        }
        function testKeyboardMultiplier(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
            parsed.keyboardMultiplier = entry;
        }
        function testKeyboardDefaultStep(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
            parsed.keyboardDefaultStep = entry;
        }
        function testRange(parsed, entry) {
            if (typeof entry !== "object" || Array.isArray(entry)) throw new Error("noUiSlider: 'range' is not an object.");
            if (entry.min === void 0 || entry.max === void 0) throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
            parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);
        }
        function testStart(parsed, entry) {
            entry = asArray(entry);
            if (!Array.isArray(entry) || !entry.length) throw new Error("noUiSlider: 'start' option is incorrect.");
            parsed.handles = entry.length;
            parsed.start = entry;
        }
        function testSnap(parsed, entry) {
            if (typeof entry !== "boolean") throw new Error("noUiSlider: 'snap' option must be a boolean.");
            parsed.snap = entry;
        }
        function testAnimate(parsed, entry) {
            if (typeof entry !== "boolean") throw new Error("noUiSlider: 'animate' option must be a boolean.");
            parsed.animate = entry;
        }
        function testAnimationDuration(parsed, entry) {
            if (typeof entry !== "number") throw new Error("noUiSlider: 'animationDuration' option must be a number.");
            parsed.animationDuration = entry;
        }
        function testConnect(parsed, entry) {
            var connect = [ false ];
            var i;
            if (entry === "lower") entry = [ true, false ]; else if (entry === "upper") entry = [ false, true ];
            if (entry === true || entry === false) {
                for (i = 1; i < parsed.handles; i++) connect.push(entry);
                connect.push(false);
            } else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) throw new Error("noUiSlider: 'connect' option doesn't match handle count."); else connect = entry;
            parsed.connect = connect;
        }
        function testOrientation(parsed, entry) {
            switch (entry) {
              case "horizontal":
                parsed.ort = 0;
                break;

              case "vertical":
                parsed.ort = 1;
                break;

              default:
                throw new Error("noUiSlider: 'orientation' option is invalid.");
            }
        }
        function testMargin(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'margin' option must be numeric.");
            if (entry === 0) return;
            parsed.margin = parsed.spectrum.getDistance(entry);
        }
        function testLimit(parsed, entry) {
            if (!isNumeric(entry)) throw new Error("noUiSlider: 'limit' option must be numeric.");
            parsed.limit = parsed.spectrum.getDistance(entry);
            if (!parsed.limit || parsed.handles < 2) throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
        }
        function testPadding(parsed, entry) {
            var index;
            if (!isNumeric(entry) && !Array.isArray(entry)) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
            if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
            if (entry === 0) return;
            if (!Array.isArray(entry)) entry = [ entry, entry ];
            parsed.padding = [ parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1]) ];
            for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
            var totalPadding = entry[0] + entry[1];
            var firstValue = parsed.spectrum.xVal[0];
            var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];
            if (totalPadding / (lastValue - firstValue) > 1) throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
        }
        function testDirection(parsed, entry) {
            switch (entry) {
              case "ltr":
                parsed.dir = 0;
                break;

              case "rtl":
                parsed.dir = 1;
                break;

              default:
                throw new Error("noUiSlider: 'direction' option was not recognized.");
            }
        }
        function testBehaviour(parsed, entry) {
            if (typeof entry !== "string") throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
            var tap = entry.indexOf("tap") >= 0;
            var drag = entry.indexOf("drag") >= 0;
            var fixed = entry.indexOf("fixed") >= 0;
            var snap = entry.indexOf("snap") >= 0;
            var hover = entry.indexOf("hover") >= 0;
            var unconstrained = entry.indexOf("unconstrained") >= 0;
            var dragAll = entry.indexOf("drag-all") >= 0;
            var smoothSteps = entry.indexOf("smooth-steps") >= 0;
            if (fixed) {
                if (parsed.handles !== 2) throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
                testMargin(parsed, parsed.start[1] - parsed.start[0]);
            }
            if (unconstrained && (parsed.margin || parsed.limit)) throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
            parsed.events = {
                tap: tap || snap,
                drag,
                dragAll,
                smoothSteps,
                fixed,
                snap,
                hover,
                unconstrained
            };
        }
        function testTooltips(parsed, entry) {
            if (entry === false) return;
            if (entry === true || isValidPartialFormatter(entry)) {
                parsed.tooltips = [];
                for (var i = 0; i < parsed.handles; i++) parsed.tooltips.push(entry);
            } else {
                entry = asArray(entry);
                if (entry.length !== parsed.handles) throw new Error("noUiSlider: must pass a formatter for all handles.");
                entry.forEach((function(formatter) {
                    if (typeof formatter !== "boolean" && !isValidPartialFormatter(formatter)) throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
                }));
                parsed.tooltips = entry;
            }
        }
        function testHandleAttributes(parsed, entry) {
            if (entry.length !== parsed.handles) throw new Error("noUiSlider: must pass a attributes for all handles.");
            parsed.handleAttributes = entry;
        }
        function testAriaFormat(parsed, entry) {
            if (!isValidPartialFormatter(entry)) throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
            parsed.ariaFormat = entry;
        }
        function testFormat(parsed, entry) {
            if (!isValidFormatter(entry)) throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
            parsed.format = entry;
        }
        function testKeyboardSupport(parsed, entry) {
            if (typeof entry !== "boolean") throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
            parsed.keyboardSupport = entry;
        }
        function testDocumentElement(parsed, entry) {
            parsed.documentElement = entry;
        }
        function testCssPrefix(parsed, entry) {
            if (typeof entry !== "string" && entry !== false) throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
            parsed.cssPrefix = entry;
        }
        function testCssClasses(parsed, entry) {
            if (typeof entry !== "object") throw new Error("noUiSlider: 'cssClasses' must be an object.");
            if (typeof parsed.cssPrefix === "string") {
                parsed.cssClasses = {};
                Object.keys(entry).forEach((function(key) {
                    parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
                }));
            } else parsed.cssClasses = entry;
        }
        function testOptions(options) {
            var parsed = {
                margin: null,
                limit: null,
                padding: null,
                animate: true,
                animationDuration: 300,
                ariaFormat: defaultFormatter,
                format: defaultFormatter
            };
            var tests = {
                step: {
                    r: false,
                    t: testStep
                },
                keyboardPageMultiplier: {
                    r: false,
                    t: testKeyboardPageMultiplier
                },
                keyboardMultiplier: {
                    r: false,
                    t: testKeyboardMultiplier
                },
                keyboardDefaultStep: {
                    r: false,
                    t: testKeyboardDefaultStep
                },
                start: {
                    r: true,
                    t: testStart
                },
                connect: {
                    r: true,
                    t: testConnect
                },
                direction: {
                    r: true,
                    t: testDirection
                },
                snap: {
                    r: false,
                    t: testSnap
                },
                animate: {
                    r: false,
                    t: testAnimate
                },
                animationDuration: {
                    r: false,
                    t: testAnimationDuration
                },
                range: {
                    r: true,
                    t: testRange
                },
                orientation: {
                    r: false,
                    t: testOrientation
                },
                margin: {
                    r: false,
                    t: testMargin
                },
                limit: {
                    r: false,
                    t: testLimit
                },
                padding: {
                    r: false,
                    t: testPadding
                },
                behaviour: {
                    r: true,
                    t: testBehaviour
                },
                ariaFormat: {
                    r: false,
                    t: testAriaFormat
                },
                format: {
                    r: false,
                    t: testFormat
                },
                tooltips: {
                    r: false,
                    t: testTooltips
                },
                keyboardSupport: {
                    r: true,
                    t: testKeyboardSupport
                },
                documentElement: {
                    r: false,
                    t: testDocumentElement
                },
                cssPrefix: {
                    r: true,
                    t: testCssPrefix
                },
                cssClasses: {
                    r: true,
                    t: testCssClasses
                },
                handleAttributes: {
                    r: false,
                    t: testHandleAttributes
                }
            };
            var defaults = {
                connect: false,
                direction: "ltr",
                behaviour: "tap",
                orientation: "horizontal",
                keyboardSupport: true,
                cssPrefix: "noUi-",
                cssClasses,
                keyboardPageMultiplier: 5,
                keyboardMultiplier: 1,
                keyboardDefaultStep: 10
            };
            if (options.format && !options.ariaFormat) options.ariaFormat = options.format;
            Object.keys(tests).forEach((function(name) {
                if (!isSet(options[name]) && defaults[name] === void 0) {
                    if (tests[name].r) throw new Error("noUiSlider: '" + name + "' is required.");
                    return;
                }
                tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);
            }));
            parsed.pips = options.pips;
            var d = document.createElement("div");
            var msPrefix = d.style.msTransform !== void 0;
            var noPrefix = d.style.transform !== void 0;
            parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";
            var styles = [ [ "left", "top" ], [ "right", "bottom" ] ];
            parsed.style = styles[parsed.dir][parsed.ort];
            return parsed;
        }
        function scope(target, options, originalOptions) {
            var actions = getActions();
            var supportsTouchActionNone = getSupportsTouchActionNone();
            var supportsPassive = supportsTouchActionNone && getSupportsPassive();
            var scope_Target = target;
            var scope_Base;
            var scope_Handles;
            var scope_Connects;
            var scope_Pips;
            var scope_Tooltips;
            var scope_Spectrum = options.spectrum;
            var scope_Values = [];
            var scope_Locations = [];
            var scope_HandleNumbers = [];
            var scope_ActiveHandlesCount = 0;
            var scope_Events = {};
            var scope_Document = target.ownerDocument;
            var scope_DocumentElement = options.documentElement || scope_Document.documentElement;
            var scope_Body = scope_Document.body;
            var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;
            function addNodeTo(addTarget, className) {
                var div = scope_Document.createElement("div");
                if (className) addClass(div, className);
                addTarget.appendChild(div);
                return div;
            }
            function addOrigin(base, handleNumber) {
                var origin = addNodeTo(base, options.cssClasses.origin);
                var handle = addNodeTo(origin, options.cssClasses.handle);
                addNodeTo(handle, options.cssClasses.touchArea);
                handle.setAttribute("data-handle", String(handleNumber));
                if (options.keyboardSupport) {
                    handle.setAttribute("tabindex", "0");
                    handle.addEventListener("keydown", (function(event) {
                        return eventKeydown(event, handleNumber);
                    }));
                }
                if (options.handleAttributes !== void 0) {
                    var attributes_1 = options.handleAttributes[handleNumber];
                    Object.keys(attributes_1).forEach((function(attribute) {
                        handle.setAttribute(attribute, attributes_1[attribute]);
                    }));
                }
                handle.setAttribute("role", "slider");
                handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");
                if (handleNumber === 0) addClass(handle, options.cssClasses.handleLower); else if (handleNumber === options.handles - 1) addClass(handle, options.cssClasses.handleUpper);
                origin.handle = handle;
                return origin;
            }
            function addConnect(base, add) {
                if (!add) return false;
                return addNodeTo(base, options.cssClasses.connect);
            }
            function addElements(connectOptions, base) {
                var connectBase = addNodeTo(base, options.cssClasses.connects);
                scope_Handles = [];
                scope_Connects = [];
                scope_Connects.push(addConnect(connectBase, connectOptions[0]));
                for (var i = 0; i < options.handles; i++) {
                    scope_Handles.push(addOrigin(base, i));
                    scope_HandleNumbers[i] = i;
                    scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
                }
            }
            function addSlider(addTarget) {
                addClass(addTarget, options.cssClasses.target);
                if (options.dir === 0) addClass(addTarget, options.cssClasses.ltr); else addClass(addTarget, options.cssClasses.rtl);
                if (options.ort === 0) addClass(addTarget, options.cssClasses.horizontal); else addClass(addTarget, options.cssClasses.vertical);
                var textDirection = getComputedStyle(addTarget).direction;
                if (textDirection === "rtl") addClass(addTarget, options.cssClasses.textDirectionRtl); else addClass(addTarget, options.cssClasses.textDirectionLtr);
                return addNodeTo(addTarget, options.cssClasses.base);
            }
            function addTooltip(handle, handleNumber) {
                if (!options.tooltips || !options.tooltips[handleNumber]) return false;
                return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
            }
            function isSliderDisabled() {
                return scope_Target.hasAttribute("disabled");
            }
            function isHandleDisabled(handleNumber) {
                var handleOrigin = scope_Handles[handleNumber];
                return handleOrigin.hasAttribute("disabled");
            }
            function disable(handleNumber) {
                if (handleNumber !== null && handleNumber !== void 0) {
                    scope_Handles[handleNumber].setAttribute("disabled", "");
                    scope_Handles[handleNumber].handle.removeAttribute("tabindex");
                } else {
                    scope_Target.setAttribute("disabled", "");
                    scope_Handles.forEach((function(handle) {
                        handle.handle.removeAttribute("tabindex");
                    }));
                }
            }
            function enable(handleNumber) {
                if (handleNumber !== null && handleNumber !== void 0) {
                    scope_Handles[handleNumber].removeAttribute("disabled");
                    scope_Handles[handleNumber].handle.setAttribute("tabindex", "0");
                } else {
                    scope_Target.removeAttribute("disabled");
                    scope_Handles.forEach((function(handle) {
                        handle.removeAttribute("disabled");
                        handle.handle.setAttribute("tabindex", "0");
                    }));
                }
            }
            function removeTooltips() {
                if (scope_Tooltips) {
                    removeEvent("update" + INTERNAL_EVENT_NS.tooltips);
                    scope_Tooltips.forEach((function(tooltip) {
                        if (tooltip) removeElement(tooltip);
                    }));
                    scope_Tooltips = null;
                }
            }
            function tooltips() {
                removeTooltips();
                scope_Tooltips = scope_Handles.map(addTooltip);
                bindEvent("update" + INTERNAL_EVENT_NS.tooltips, (function(values, handleNumber, unencoded) {
                    if (!scope_Tooltips || !options.tooltips) return;
                    if (scope_Tooltips[handleNumber] === false) return;
                    var formattedValue = values[handleNumber];
                    if (options.tooltips[handleNumber] !== true) formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
                    scope_Tooltips[handleNumber].innerHTML = formattedValue;
                }));
            }
            function aria() {
                removeEvent("update" + INTERNAL_EVENT_NS.aria);
                bindEvent("update" + INTERNAL_EVENT_NS.aria, (function(values, handleNumber, unencoded, tap, positions) {
                    scope_HandleNumbers.forEach((function(index) {
                        var handle = scope_Handles[index];
                        var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);
                        var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);
                        var now = positions[index];
                        var text = String(options.ariaFormat.to(unencoded[index]));
                        min = scope_Spectrum.fromStepping(min).toFixed(1);
                        max = scope_Spectrum.fromStepping(max).toFixed(1);
                        now = scope_Spectrum.fromStepping(now).toFixed(1);
                        handle.children[0].setAttribute("aria-valuemin", min);
                        handle.children[0].setAttribute("aria-valuemax", max);
                        handle.children[0].setAttribute("aria-valuenow", now);
                        handle.children[0].setAttribute("aria-valuetext", text);
                    }));
                }));
            }
            function getGroup(pips) {
                if (pips.mode === PipsMode.Range || pips.mode === PipsMode.Steps) return scope_Spectrum.xVal;
                if (pips.mode === PipsMode.Count) {
                    if (pips.values < 2) throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
                    var interval = pips.values - 1;
                    var spread = 100 / interval;
                    var values = [];
                    while (interval--) values[interval] = interval * spread;
                    values.push(100);
                    return mapToRange(values, pips.stepped);
                }
                if (pips.mode === PipsMode.Positions) return mapToRange(pips.values, pips.stepped);
                if (pips.mode === PipsMode.Values) {
                    if (pips.stepped) return pips.values.map((function(value) {
                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
                    }));
                    return pips.values;
                }
                return [];
            }
            function mapToRange(values, stepped) {
                return values.map((function(value) {
                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);
                }));
            }
            function generateSpread(pips) {
                function safeIncrement(value, increment) {
                    return Number((value + increment).toFixed(7));
                }
                var group = getGroup(pips);
                var indexes = {};
                var firstInRange = scope_Spectrum.xVal[0];
                var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
                var ignoreFirst = false;
                var ignoreLast = false;
                var prevPct = 0;
                group = unique(group.slice().sort((function(a, b) {
                    return a - b;
                })));
                if (group[0] !== firstInRange) {
                    group.unshift(firstInRange);
                    ignoreFirst = true;
                }
                if (group[group.length - 1] !== lastInRange) {
                    group.push(lastInRange);
                    ignoreLast = true;
                }
                group.forEach((function(current, index) {
                    var step;
                    var i;
                    var q;
                    var low = current;
                    var high = group[index + 1];
                    var newPct;
                    var pctDifference;
                    var pctPos;
                    var type;
                    var steps;
                    var realSteps;
                    var stepSize;
                    var isSteps = pips.mode === PipsMode.Steps;
                    if (isSteps) step = scope_Spectrum.xNumSteps[index];
                    if (!step) step = high - low;
                    if (high === void 0) high = low;
                    step = Math.max(step, 1e-7);
                    for (i = low; i <= high; i = safeIncrement(i, step)) {
                        newPct = scope_Spectrum.toStepping(i);
                        pctDifference = newPct - prevPct;
                        steps = pctDifference / (pips.density || 1);
                        realSteps = Math.round(steps);
                        stepSize = pctDifference / realSteps;
                        for (q = 1; q <= realSteps; q += 1) {
                            pctPos = prevPct + q * stepSize;
                            indexes[pctPos.toFixed(5)] = [ scope_Spectrum.fromStepping(pctPos), 0 ];
                        }
                        type = group.indexOf(i) > -1 ? PipsType.LargeValue : isSteps ? PipsType.SmallValue : PipsType.NoValue;
                        if (!index && ignoreFirst && i !== high) type = 0;
                        if (!(i === high && ignoreLast)) indexes[newPct.toFixed(5)] = [ i, type ];
                        prevPct = newPct;
                    }
                }));
                return indexes;
            }
            function addMarking(spread, filterFunc, formatter) {
                var _a, _b;
                var element = scope_Document.createElement("div");
                var valueSizeClasses = (_a = {}, _a[PipsType.None] = "", _a[PipsType.NoValue] = options.cssClasses.valueNormal, 
                _a[PipsType.LargeValue] = options.cssClasses.valueLarge, _a[PipsType.SmallValue] = options.cssClasses.valueSub, 
                _a);
                var markerSizeClasses = (_b = {}, _b[PipsType.None] = "", _b[PipsType.NoValue] = options.cssClasses.markerNormal, 
                _b[PipsType.LargeValue] = options.cssClasses.markerLarge, _b[PipsType.SmallValue] = options.cssClasses.markerSub, 
                _b);
                var valueOrientationClasses = [ options.cssClasses.valueHorizontal, options.cssClasses.valueVertical ];
                var markerOrientationClasses = [ options.cssClasses.markerHorizontal, options.cssClasses.markerVertical ];
                addClass(element, options.cssClasses.pips);
                addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
                function getClasses(type, source) {
                    var a = source === options.cssClasses.value;
                    var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
                    var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
                    return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];
                }
                function addSpread(offset, value, type) {
                    type = filterFunc ? filterFunc(value, type) : type;
                    if (type === PipsType.None) return;
                    var node = addNodeTo(element, false);
                    node.className = getClasses(type, options.cssClasses.marker);
                    node.style[options.style] = offset + "%";
                    if (type > PipsType.NoValue) {
                        node = addNodeTo(element, false);
                        node.className = getClasses(type, options.cssClasses.value);
                        node.setAttribute("data-value", String(value));
                        node.style[options.style] = offset + "%";
                        node.innerHTML = String(formatter.to(value));
                    }
                }
                Object.keys(spread).forEach((function(offset) {
                    addSpread(offset, spread[offset][0], spread[offset][1]);
                }));
                return element;
            }
            function removePips() {
                if (scope_Pips) {
                    removeElement(scope_Pips);
                    scope_Pips = null;
                }
            }
            function pips(pips) {
                removePips();
                var spread = generateSpread(pips);
                var filter = pips.filter;
                var format = pips.format || {
                    to: function(value) {
                        return String(Math.round(value));
                    }
                };
                scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));
                return scope_Pips;
            }
            function baseSize() {
                var rect = scope_Base.getBoundingClientRect();
                var alt = "offset" + [ "Width", "Height" ][options.ort];
                return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];
            }
            function attachEvent(events, element, callback, data) {
                var method = function(event) {
                    var e = fixEvent(event, data.pageOffset, data.target || element);
                    if (!e) return false;
                    if (isSliderDisabled() && !data.doNotReject) return false;
                    if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) return false;
                    if (events === actions.start && e.buttons !== void 0 && e.buttons > 1) return false;
                    if (data.hover && e.buttons) return false;
                    if (!supportsPassive) e.preventDefault();
                    e.calcPoint = e.points[options.ort];
                    callback(e, data);
                    return;
                };
                var methods = [];
                events.split(" ").forEach((function(eventName) {
                    element.addEventListener(eventName, method, supportsPassive ? {
                        passive: true
                    } : false);
                    methods.push([ eventName, method ]);
                }));
                return methods;
            }
            function fixEvent(e, pageOffset, eventTarget) {
                var touch = e.type.indexOf("touch") === 0;
                var mouse = e.type.indexOf("mouse") === 0;
                var pointer = e.type.indexOf("pointer") === 0;
                var x = 0;
                var y = 0;
                if (e.type.indexOf("MSPointer") === 0) pointer = true;
                if (e.type === "mousedown" && !e.buttons && !e.touches) return false;
                if (touch) {
                    var isTouchOnTarget = function(checkTouch) {
                        var target = checkTouch.target;
                        return target === eventTarget || eventTarget.contains(target) || e.composed && e.composedPath().shift() === eventTarget;
                    };
                    if (e.type === "touchstart") {
                        var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                        if (targetTouches.length > 1) return false;
                        x = targetTouches[0].pageX;
                        y = targetTouches[0].pageY;
                    } else {
                        var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                        if (!targetTouch) return false;
                        x = targetTouch.pageX;
                        y = targetTouch.pageY;
                    }
                }
                pageOffset = pageOffset || getPageOffset(scope_Document);
                if (mouse || pointer) {
                    x = e.clientX + pageOffset.x;
                    y = e.clientY + pageOffset.y;
                }
                e.pageOffset = pageOffset;
                e.points = [ x, y ];
                e.cursor = mouse || pointer;
                return e;
            }
            function calcPointToPercentage(calcPoint) {
                var location = calcPoint - offset(scope_Base, options.ort);
                var proposal = location * 100 / baseSize();
                proposal = limit(proposal);
                return options.dir ? 100 - proposal : proposal;
            }
            function getClosestHandle(clickedPosition) {
                var smallestDifference = 100;
                var handleNumber = false;
                scope_Handles.forEach((function(handle, index) {
                    if (isHandleDisabled(index)) return;
                    var handlePosition = scope_Locations[index];
                    var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);
                    var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;
                    var isCloser = differenceWithThisHandle < smallestDifference;
                    var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;
                    if (isCloser || isCloserAfter || clickAtEdge) {
                        handleNumber = index;
                        smallestDifference = differenceWithThisHandle;
                    }
                }));
                return handleNumber;
            }
            function documentLeave(event, data) {
                if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) eventEnd(event, data);
            }
            function eventMove(event, data) {
                if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) return eventEnd(event, data);
                var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
                var proposal = movement * 100 / data.baseSize;
                moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);
            }
            function eventEnd(event, data) {
                if (data.handle) {
                    removeClass(data.handle, options.cssClasses.active);
                    scope_ActiveHandlesCount -= 1;
                }
                data.listeners.forEach((function(c) {
                    scope_DocumentElement.removeEventListener(c[0], c[1]);
                }));
                if (scope_ActiveHandlesCount === 0) {
                    removeClass(scope_Target, options.cssClasses.drag);
                    setZindex();
                    if (event.cursor) {
                        scope_Body.style.cursor = "";
                        scope_Body.removeEventListener("selectstart", preventDefault);
                    }
                }
                if (options.events.smoothSteps) {
                    data.handleNumbers.forEach((function(handleNumber) {
                        setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);
                    }));
                    data.handleNumbers.forEach((function(handleNumber) {
                        fireEvent("update", handleNumber);
                    }));
                }
                data.handleNumbers.forEach((function(handleNumber) {
                    fireEvent("change", handleNumber);
                    fireEvent("set", handleNumber);
                    fireEvent("end", handleNumber);
                }));
            }
            function eventStart(event, data) {
                if (data.handleNumbers.some(isHandleDisabled)) return;
                var handle;
                if (data.handleNumbers.length === 1) {
                    var handleOrigin = scope_Handles[data.handleNumbers[0]];
                    handle = handleOrigin.children[0];
                    scope_ActiveHandlesCount += 1;
                    addClass(handle, options.cssClasses.active);
                }
                event.stopPropagation();
                var listeners = [];
                var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                    target: event.target,
                    handle,
                    connect: data.connect,
                    listeners,
                    startCalcPoint: event.calcPoint,
                    baseSize: baseSize(),
                    pageOffset: event.pageOffset,
                    handleNumbers: data.handleNumbers,
                    buttonsProperty: event.buttons,
                    locations: scope_Locations.slice()
                });
                var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                    target: event.target,
                    handle,
                    listeners,
                    doNotReject: true,
                    handleNumbers: data.handleNumbers
                });
                var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                    target: event.target,
                    handle,
                    listeners,
                    doNotReject: true,
                    handleNumbers: data.handleNumbers
                });
                listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
                if (event.cursor) {
                    scope_Body.style.cursor = getComputedStyle(event.target).cursor;
                    if (scope_Handles.length > 1) addClass(scope_Target, options.cssClasses.drag);
                    scope_Body.addEventListener("selectstart", preventDefault, false);
                }
                data.handleNumbers.forEach((function(handleNumber) {
                    fireEvent("start", handleNumber);
                }));
            }
            function eventTap(event) {
                event.stopPropagation();
                var proposal = calcPointToPercentage(event.calcPoint);
                var handleNumber = getClosestHandle(proposal);
                if (handleNumber === false) return;
                if (!options.events.snap) addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
                setHandle(handleNumber, proposal, true, true);
                setZindex();
                fireEvent("slide", handleNumber, true);
                fireEvent("update", handleNumber, true);
                if (!options.events.snap) {
                    fireEvent("change", handleNumber, true);
                    fireEvent("set", handleNumber, true);
                } else eventStart(event, {
                    handleNumbers: [ handleNumber ]
                });
            }
            function eventHover(event) {
                var proposal = calcPointToPercentage(event.calcPoint);
                var to = scope_Spectrum.getStep(proposal);
                var value = scope_Spectrum.fromStepping(to);
                Object.keys(scope_Events).forEach((function(targetEvent) {
                    if ("hover" === targetEvent.split(".")[0]) scope_Events[targetEvent].forEach((function(callback) {
                        callback.call(scope_Self, value);
                    }));
                }));
            }
            function eventKeydown(event, handleNumber) {
                if (isSliderDisabled() || isHandleDisabled(handleNumber)) return false;
                var horizontalKeys = [ "Left", "Right" ];
                var verticalKeys = [ "Down", "Up" ];
                var largeStepKeys = [ "PageDown", "PageUp" ];
                var edgeKeys = [ "Home", "End" ];
                if (options.dir && !options.ort) horizontalKeys.reverse(); else if (options.ort && !options.dir) {
                    verticalKeys.reverse();
                    largeStepKeys.reverse();
                }
                var key = event.key.replace("Arrow", "");
                var isLargeDown = key === largeStepKeys[0];
                var isLargeUp = key === largeStepKeys[1];
                var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;
                var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;
                var isMin = key === edgeKeys[0];
                var isMax = key === edgeKeys[1];
                if (!isDown && !isUp && !isMin && !isMax) return true;
                event.preventDefault();
                var to;
                if (isUp || isDown) {
                    var direction = isDown ? 0 : 1;
                    var steps = getNextStepsForHandle(handleNumber);
                    var step = steps[direction];
                    if (step === null) return false;
                    if (step === false) step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);
                    if (isLargeUp || isLargeDown) step *= options.keyboardPageMultiplier; else step *= options.keyboardMultiplier;
                    step = Math.max(step, 1e-7);
                    step *= isDown ? -1 : 1;
                    to = scope_Values[handleNumber] + step;
                } else if (isMax) to = options.spectrum.xVal[options.spectrum.xVal.length - 1]; else to = options.spectrum.xVal[0];
                setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);
                fireEvent("slide", handleNumber);
                fireEvent("update", handleNumber);
                fireEvent("change", handleNumber);
                fireEvent("set", handleNumber);
                return false;
            }
            function bindSliderEvents(behaviour) {
                if (!behaviour.fixed) scope_Handles.forEach((function(handle, index) {
                    attachEvent(actions.start, handle.children[0], eventStart, {
                        handleNumbers: [ index ]
                    });
                }));
                if (behaviour.tap) attachEvent(actions.start, scope_Base, eventTap, {});
                if (behaviour.hover) attachEvent(actions.move, scope_Base, eventHover, {
                    hover: true
                });
                if (behaviour.drag) scope_Connects.forEach((function(connect, index) {
                    if (connect === false || index === 0 || index === scope_Connects.length - 1) return;
                    var handleBefore = scope_Handles[index - 1];
                    var handleAfter = scope_Handles[index];
                    var eventHolders = [ connect ];
                    var handlesToDrag = [ handleBefore, handleAfter ];
                    var handleNumbersToDrag = [ index - 1, index ];
                    addClass(connect, options.cssClasses.draggable);
                    if (behaviour.fixed) {
                        eventHolders.push(handleBefore.children[0]);
                        eventHolders.push(handleAfter.children[0]);
                    }
                    if (behaviour.dragAll) {
                        handlesToDrag = scope_Handles;
                        handleNumbersToDrag = scope_HandleNumbers;
                    }
                    eventHolders.forEach((function(eventHolder) {
                        attachEvent(actions.start, eventHolder, eventStart, {
                            handles: handlesToDrag,
                            handleNumbers: handleNumbersToDrag,
                            connect
                        });
                    }));
                }));
            }
            function bindEvent(namespacedEvent, callback) {
                scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
                scope_Events[namespacedEvent].push(callback);
                if (namespacedEvent.split(".")[0] === "update") scope_Handles.forEach((function(a, index) {
                    fireEvent("update", index);
                }));
            }
            function isInternalNamespace(namespace) {
                return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;
            }
            function removeEvent(namespacedEvent) {
                var event = namespacedEvent && namespacedEvent.split(".")[0];
                var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;
                Object.keys(scope_Events).forEach((function(bind) {
                    var tEvent = bind.split(".")[0];
                    var tNamespace = bind.substring(tEvent.length);
                    if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) if (!isInternalNamespace(tNamespace) || namespace === tNamespace) delete scope_Events[bind];
                }));
            }
            function fireEvent(eventName, handleNumber, tap) {
                Object.keys(scope_Events).forEach((function(targetEvent) {
                    var eventType = targetEvent.split(".")[0];
                    if (eventName === eventType) scope_Events[targetEvent].forEach((function(callback) {
                        callback.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || false, scope_Locations.slice(), scope_Self);
                    }));
                }));
            }
            function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {
                var distance;
                if (scope_Handles.length > 1 && !options.events.unconstrained) {
                    if (lookBackward && handleNumber > 0) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);
                        to = Math.max(to, distance);
                    }
                    if (lookForward && handleNumber < scope_Handles.length - 1) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);
                        to = Math.min(to, distance);
                    }
                }
                if (scope_Handles.length > 1 && options.limit) {
                    if (lookBackward && handleNumber > 0) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);
                        to = Math.min(to, distance);
                    }
                    if (lookForward && handleNumber < scope_Handles.length - 1) {
                        distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);
                        to = Math.max(to, distance);
                    }
                }
                if (options.padding) {
                    if (handleNumber === 0) {
                        distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);
                        to = Math.max(to, distance);
                    }
                    if (handleNumber === scope_Handles.length - 1) {
                        distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);
                        to = Math.min(to, distance);
                    }
                }
                if (!smoothSteps) to = scope_Spectrum.getStep(to);
                to = limit(to);
                if (to === reference[handleNumber] && !getValue) return false;
                return to;
            }
            function inRuleOrder(v, a) {
                var o = options.ort;
                return (o ? a : v) + ", " + (o ? v : a);
            }
            function moveHandles(upward, proposal, locations, handleNumbers, connect) {
                var proposals = locations.slice();
                var firstHandle = handleNumbers[0];
                var smoothSteps = options.events.smoothSteps;
                var b = [ !upward, upward ];
                var f = [ upward, !upward ];
                handleNumbers = handleNumbers.slice();
                if (upward) handleNumbers.reverse();
                if (handleNumbers.length > 1) handleNumbers.forEach((function(handleNumber, o) {
                    var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps);
                    if (to === false) proposal = 0; else {
                        proposal = to - proposals[handleNumber];
                        proposals[handleNumber] = to;
                    }
                })); else b = f = [ true ];
                var state = false;
                handleNumbers.forEach((function(handleNumber, o) {
                    state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;
                }));
                if (state) {
                    handleNumbers.forEach((function(handleNumber) {
                        fireEvent("update", handleNumber);
                        fireEvent("slide", handleNumber);
                    }));
                    if (connect != void 0) fireEvent("drag", firstHandle);
                }
            }
            function transformDirection(a, b) {
                return options.dir ? 100 - a - b : a;
            }
            function updateHandlePosition(handleNumber, to) {
                scope_Locations[handleNumber] = to;
                scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
                var translation = transformDirection(to, 0) - scope_DirOffset;
                var translateRule = "translate(" + inRuleOrder(translation + "%", "0") + ")";
                scope_Handles[handleNumber].style[options.transformRule] = translateRule;
                updateConnect(handleNumber);
                updateConnect(handleNumber + 1);
            }
            function setZindex() {
                scope_HandleNumbers.forEach((function(handleNumber) {
                    var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
                    var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
                    scope_Handles[handleNumber].style.zIndex = String(zIndex);
                }));
            }
            function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {
                if (!exactInput) to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);
                if (to === false) return false;
                updateHandlePosition(handleNumber, to);
                return true;
            }
            function updateConnect(index) {
                if (!scope_Connects[index]) return;
                var l = 0;
                var h = 100;
                if (index !== 0) l = scope_Locations[index - 1];
                if (index !== scope_Connects.length - 1) h = scope_Locations[index];
                var connectWidth = h - l;
                var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";
                var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";
                scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;
            }
            function resolveToValue(to, handleNumber) {
                if (to === null || to === false || to === void 0) return scope_Locations[handleNumber];
                if (typeof to === "number") to = String(to);
                to = options.format.from(to);
                if (to !== false) to = scope_Spectrum.toStepping(to);
                if (to === false || isNaN(to)) return scope_Locations[handleNumber];
                return to;
            }
            function valueSet(input, fireSetEvent, exactInput) {
                var values = asArray(input);
                var isInit = scope_Locations[0] === void 0;
                fireSetEvent = fireSetEvent === void 0 ? true : fireSetEvent;
                if (options.animate && !isInit) addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
                scope_HandleNumbers.forEach((function(handleNumber) {
                    setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);
                }));
                var i = scope_HandleNumbers.length === 1 ? 0 : 1;
                if (isInit && scope_Spectrum.hasNoSize()) {
                    exactInput = true;
                    scope_Locations[0] = 0;
                    if (scope_HandleNumbers.length > 1) {
                        var space_1 = 100 / (scope_HandleNumbers.length - 1);
                        scope_HandleNumbers.forEach((function(handleNumber) {
                            scope_Locations[handleNumber] = handleNumber * space_1;
                        }));
                    }
                }
                for (;i < scope_HandleNumbers.length; ++i) scope_HandleNumbers.forEach((function(handleNumber) {
                    setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);
                }));
                setZindex();
                scope_HandleNumbers.forEach((function(handleNumber) {
                    fireEvent("update", handleNumber);
                    if (values[handleNumber] !== null && fireSetEvent) fireEvent("set", handleNumber);
                }));
            }
            function valueReset(fireSetEvent) {
                valueSet(options.start, fireSetEvent);
            }
            function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {
                handleNumber = Number(handleNumber);
                if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) throw new Error("noUiSlider: invalid handle number, got: " + handleNumber);
                setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);
                fireEvent("update", handleNumber);
                if (fireSetEvent) fireEvent("set", handleNumber);
            }
            function valueGet(unencoded) {
                if (unencoded === void 0) unencoded = false;
                if (unencoded) return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);
                var values = scope_Values.map(options.format.to);
                if (values.length === 1) return values[0];
                return values;
            }
            function destroy() {
                removeEvent(INTERNAL_EVENT_NS.aria);
                removeEvent(INTERNAL_EVENT_NS.tooltips);
                Object.keys(options.cssClasses).forEach((function(key) {
                    removeClass(scope_Target, options.cssClasses[key]);
                }));
                while (scope_Target.firstChild) scope_Target.removeChild(scope_Target.firstChild);
                delete scope_Target.noUiSlider;
            }
            function getNextStepsForHandle(handleNumber) {
                var location = scope_Locations[handleNumber];
                var nearbySteps = scope_Spectrum.getNearbySteps(location);
                var value = scope_Values[handleNumber];
                var increment = nearbySteps.thisStep.step;
                var decrement = null;
                if (options.snap) return [ value - nearbySteps.stepBefore.startValue || null, nearbySteps.stepAfter.startValue - value || null ];
                if (increment !== false) if (value + increment > nearbySteps.stepAfter.startValue) increment = nearbySteps.stepAfter.startValue - value;
                if (value > nearbySteps.thisStep.startValue) decrement = nearbySteps.thisStep.step; else if (nearbySteps.stepBefore.step === false) decrement = false; else decrement = value - nearbySteps.stepBefore.highestStep;
                if (location === 100) increment = null; else if (location === 0) decrement = null;
                var stepDecimals = scope_Spectrum.countStepDecimals();
                if (increment !== null && increment !== false) increment = Number(increment.toFixed(stepDecimals));
                if (decrement !== null && decrement !== false) decrement = Number(decrement.toFixed(stepDecimals));
                return [ decrement, increment ];
            }
            function getNextSteps() {
                return scope_HandleNumbers.map(getNextStepsForHandle);
            }
            function updateOptions(optionsToUpdate, fireSetEvent) {
                var v = valueGet();
                var updateAble = [ "margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips" ];
                updateAble.forEach((function(name) {
                    if (optionsToUpdate[name] !== void 0) originalOptions[name] = optionsToUpdate[name];
                }));
                var newOptions = testOptions(originalOptions);
                updateAble.forEach((function(name) {
                    if (optionsToUpdate[name] !== void 0) options[name] = newOptions[name];
                }));
                scope_Spectrum = newOptions.spectrum;
                options.margin = newOptions.margin;
                options.limit = newOptions.limit;
                options.padding = newOptions.padding;
                if (options.pips) pips(options.pips); else removePips();
                if (options.tooltips) tooltips(); else removeTooltips();
                scope_Locations = [];
                valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);
            }
            function setupSlider() {
                scope_Base = addSlider(scope_Target);
                addElements(options.connect, scope_Base);
                bindSliderEvents(options.events);
                valueSet(options.start);
                if (options.pips) pips(options.pips);
                if (options.tooltips) tooltips();
                aria();
            }
            setupSlider();
            var scope_Self = {
                destroy,
                steps: getNextSteps,
                on: bindEvent,
                off: removeEvent,
                get: valueGet,
                set: valueSet,
                setHandle: valueSetHandle,
                reset: valueReset,
                disable,
                enable,
                __moveHandles: function(upward, proposal, handleNumbers) {
                    moveHandles(upward, proposal, scope_Locations, handleNumbers);
                },
                options: originalOptions,
                updateOptions,
                target: scope_Target,
                removePips,
                removeTooltips,
                getPositions: function() {
                    return scope_Locations.slice();
                },
                getTooltips: function() {
                    return scope_Tooltips;
                },
                getOrigins: function() {
                    return scope_Handles;
                },
                pips
            };
            return scope_Self;
        }
        function initialize(target, originalOptions) {
            if (!target || !target.nodeName) throw new Error("noUiSlider: create requires a single element, got: " + target);
            if (target.noUiSlider) throw new Error("noUiSlider: Slider was already initialized.");
            var options = testOptions(originalOptions);
            var api = scope(target, options, originalOptions);
            target.noUiSlider = api;
            return api;
        }
        function rangeInit() {
            const priceSlider01 = document.querySelector("#range01");
            const priceSlider02 = document.querySelector("#range02");
            const priceSlider01Adv = document.querySelector("#range01-adv");
            const priceSlider02Adv = document.querySelector("#range02-adv");
            const priceSlider01m = document.querySelector("#range01m");
            const priceSlider02m = document.querySelector("#range02m");
            const priceSliderOtliv = document.querySelector("#range-otliv-filter");
            const priceSliderOtlivMobile = document.querySelector("#range-otliv-filter-mobile");
            if (priceSlider01) {
                initialize(priceSlider01, {
                    start: [ 3e4, 13e4 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 0 ],
                        max: [ 2e5 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                var snapValues = [ priceSlider01.closest(".range").querySelector("#lower-cost"), priceSlider01.closest(".range").querySelector("#upper-cost") ];
                priceSlider01.noUiSlider.on("update", (function(values, handle) {
                    snapValues[handle].innerHTML = values[handle];
                    priceSlider01.closest(".filter").querySelector(".filter__val-low").innerHTML = priceSlider01.closest(".filter__body").querySelector("#lower-cost").innerHTML;
                    priceSlider01.closest(".filter").querySelector(".filter__val-max").innerHTML = priceSlider01.closest(".filter__body").querySelector("#upper-cost").innerHTML;
                }));
            }
            if (priceSlider02) {
                initialize(priceSlider02, {
                    start: [ 60, 150 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 10 ],
                        max: [ 200 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                var snapValues02 = [ priceSlider02.closest(".range").querySelector("#lower-volume"), priceSlider02.closest(".range").querySelector("#upper-volume") ];
                priceSlider02.noUiSlider.on("update", (function(values, handle) {
                    snapValues02[handle].innerHTML = values[handle];
                    priceSlider02.closest(".filter").querySelector(".filter__val-low").innerHTML = priceSlider02.closest(".filter__body").querySelector("#lower-volume").innerHTML;
                    priceSlider02.closest(".filter").querySelector(".filter__val-max").innerHTML = priceSlider02.closest(".filter__body").querySelector("#upper-volume").innerHTML;
                }));
            }
            if (priceSlider01Adv) {
                initialize(priceSlider01Adv, {
                    start: [ 3e4, 16e4 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 0 ],
                        max: [ 2e5 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                var snapValues01Adv = [ priceSlider01Adv.closest(".range").querySelector("#lower-cost"), priceSlider01Adv.closest(".range").querySelector("#upper-cost") ];
                priceSlider01Adv.noUiSlider.on("update", (function(values, handle) {
                    snapValues01Adv[handle].innerHTML = values[handle];
                    priceSlider01Adv.closest(".filter").querySelector(".filter__val-low").innerHTML = priceSlider01Adv.closest(".filter__body").querySelector("#lower-cost").innerHTML;
                    priceSlider01Adv.closest(".filter").querySelector(".filter__val-max").innerHTML = priceSlider01Adv.closest(".filter__body").querySelector("#upper-cost").innerHTML;
                }));
            }
            if (priceSlider02Adv) {
                initialize(priceSlider02Adv, {
                    start: [ 40, 160 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 10 ],
                        max: [ 200 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                var snapValues02Adv = [ priceSlider02Adv.closest(".range").querySelector("#lower-volume"), priceSlider02Adv.closest(".range").querySelector("#upper-volume") ];
                priceSlider02Adv.noUiSlider.on("update", (function(values, handle) {
                    snapValues02Adv[handle].innerHTML = values[handle];
                    priceSlider02Adv.closest(".filter").querySelector(".filter__val-low").innerHTML = priceSlider02Adv.closest(".filter__body").querySelector("#lower-volume").innerHTML;
                    priceSlider02Adv.closest(".filter").querySelector(".filter__val-max").innerHTML = priceSlider02Adv.closest(".filter__body").querySelector("#upper-volume").innerHTML;
                }));
            }
            if (priceSlider01m) {
                initialize(priceSlider01m, {
                    start: [ 3e4, 13e4 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 0 ],
                        max: [ 2e5 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                var snapValues01m = [ priceSlider01m.closest(".submenu-filter__list").querySelector("#lower-cost"), priceSlider01m.closest(".submenu-filter__list").querySelector("#upper-cost") ];
                priceSlider01m.noUiSlider.on("update", (function(values, handle) {
                    snapValues01m[handle].innerHTML = values[handle];
                    priceSlider01m.closest(".popup__content").querySelector(".filtmodal-min").innerHTML = priceSlider01m.closest(".range").querySelector("#lower-cost").innerHTML;
                    priceSlider01m.closest(".popup__content").querySelector(".filtmodal-max").innerHTML = priceSlider01m.closest(".range").querySelector("#upper-cost").innerHTML;
                }));
                priceSlider01m.noUiSlider.on("change", (function(values, handle) {
                    snapValues01m[handle].innerHTML = values[handle];
                    priceSlider01m.closest(".popup__content").querySelector(".filtmodal__item_cost").classList.add("_backcolor");
                }));
            }
            if (priceSlider02m) {
                initialize(priceSlider02m, {
                    start: [ 60, 150 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 10 ],
                        max: [ 200 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                var snapValues02m = [ priceSlider02m.closest(".submenu-filter__list").querySelector("#lower-volume"), priceSlider02m.closest(".submenu-filter__list").querySelector("#upper-volume") ];
                priceSlider02m.noUiSlider.on("update", (function(values, handle) {
                    snapValues02m[handle].innerHTML = values[handle];
                    priceSlider02m.closest(".popup__content").querySelector(".filtmodal__item_volume .filtmodal-min").innerHTML = priceSlider02m.closest(".range").querySelector("#lower-volume").innerHTML;
                    priceSlider02m.closest(".popup__content").querySelector(".filtmodal__item_volume .filtmodal-max").innerHTML = priceSlider02m.closest(".range").querySelector("#upper-volume").innerHTML;
                }));
                priceSlider02m.noUiSlider.on("change", (function(values, handle) {
                    snapValues02m[handle].innerHTML = values[handle];
                    priceSlider02m.closest(".popup__content").querySelector(".filtmodal__item.filtmodal__item_volume").classList.add("_backcolor");
                }));
            }
            if (priceSliderOtliv) {
                initialize(priceSliderOtliv, {
                    start: [ 5e3, 15e3 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 0 ],
                        max: [ 2e4 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                snapValues = [ priceSliderOtliv.closest(".range").querySelector("#lower-cost"), priceSliderOtliv.closest(".range").querySelector("#upper-cost") ];
                priceSliderOtliv.noUiSlider.on("update", (function(values, handle) {
                    snapValues[handle].innerHTML = values[handle];
                    priceSliderOtliv.closest(".filter").querySelector(".filter__val-low").innerHTML = priceSliderOtliv.closest(".filter__body").querySelector("#lower-cost").innerHTML;
                    priceSliderOtliv.closest(".filter").querySelector(".filter__val-max").innerHTML = priceSliderOtliv.closest(".filter__body").querySelector("#upper-cost").innerHTML;
                }));
            }
            if (priceSliderOtlivMobile) {
                initialize(priceSliderOtlivMobile, {
                    start: [ 5e3, 15e3 ],
                    connect: [ false, true, false ],
                    range: {
                        min: [ 0 ],
                        max: [ 2e4 ]
                    },
                    format: wNumb({
                        decimals: 0,
                        thousand: " "
                    })
                });
                var snapValuesotliv = [ priceSliderOtlivMobile.closest(".range").querySelector("#lower-cost"), priceSliderOtlivMobile.closest(".range").querySelector("#upper-cost") ];
                priceSliderOtlivMobile.noUiSlider.on("update", (function(values, handle) {
                    snapValuesotliv[handle].innerHTML = values[handle];
                    priceSliderOtlivMobile.closest(".popup__content").querySelector(".filtmodal__item_cost .filtmodal-min").innerHTML = priceSliderOtlivMobile.closest(".range").querySelector("#lower-cost").innerHTML;
                    priceSliderOtlivMobile.closest(".popup__content").querySelector(".filtmodal__item_cost .filtmodal-max").innerHTML = priceSliderOtlivMobile.closest(".range").querySelector("#upper-cost").innerHTML;
                }));
                priceSliderOtlivMobile.noUiSlider.on("change", (function(values, handle) {
                    snapValuesotliv[handle].innerHTML = values[handle];
                    priceSliderOtlivMobile.closest(".popup__content").querySelector(".filtmodal__item.filtmodal__item_cost").classList.add("_backcolor");
                }));
            }
            document.addEventListener("click", documentActionsRange);
            function documentActionsRange(e) {
                const targetEl = e.target;
                if (targetEl.closest(".filter__reset") && targetEl.closest(".filters__filter").querySelector(".range__slider")) targetEl.closest(".filters__filter").querySelector(".range__slider").noUiSlider.reset();
                if (targetEl.closest("#reset-filternoUi")) targetEl.closest(".filtmodal__submenu").querySelector(".range__slider").noUiSlider.reset();
                if (targetEl.closest("#reset-filterall")) {
                    const noUirange = document.querySelectorAll(".range__slider");
                    noUirange.forEach((element => {
                        element.noUiSlider.reset();
                    }));
                }
            }
        }
        rangeInit();
        function getWindow_getWindow(node) {
            if (node == null) return window;
            if (node.toString() !== "[object Window]") {
                var ownerDocument = node.ownerDocument;
                return ownerDocument ? ownerDocument.defaultView || window : window;
            }
            return node;
        }
        function isElement(node) {
            var OwnElement = getWindow_getWindow(node).Element;
            return node instanceof OwnElement || node instanceof Element;
        }
        function isHTMLElement(node) {
            var OwnElement = getWindow_getWindow(node).HTMLElement;
            return node instanceof OwnElement || node instanceof HTMLElement;
        }
        function isShadowRoot(node) {
            if (typeof ShadowRoot === "undefined") return false;
            var OwnElement = getWindow_getWindow(node).ShadowRoot;
            return node instanceof OwnElement || node instanceof ShadowRoot;
        }
        var math_max = Math.max;
        var math_min = Math.min;
        var round = Math.round;
        function getUAString() {
            var uaData = navigator.userAgentData;
            if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) return uaData.brands.map((function(item) {
                return item.brand + "/" + item.version;
            })).join(" ");
            return navigator.userAgent;
        }
        function isLayoutViewport() {
            return !/^((?!chrome|android).)*safari/i.test(getUAString());
        }
        function getBoundingClientRect(element, includeScale, isFixedStrategy) {
            if (includeScale === void 0) includeScale = false;
            if (isFixedStrategy === void 0) isFixedStrategy = false;
            var clientRect = element.getBoundingClientRect();
            var scaleX = 1;
            var scaleY = 1;
            if (includeScale && isHTMLElement(element)) {
                scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
                scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
            }
            var _ref = isElement(element) ? getWindow_getWindow(element) : window, visualViewport = _ref.visualViewport;
            var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
            var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
            var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
            var width = clientRect.width / scaleX;
            var height = clientRect.height / scaleY;
            return {
                width,
                height,
                top: y,
                right: x + width,
                bottom: y + height,
                left: x,
                x,
                y
            };
        }
        function getWindowScroll(node) {
            var win = getWindow_getWindow(node);
            var scrollLeft = win.pageXOffset;
            var scrollTop = win.pageYOffset;
            return {
                scrollLeft,
                scrollTop
            };
        }
        function getHTMLElementScroll(element) {
            return {
                scrollLeft: element.scrollLeft,
                scrollTop: element.scrollTop
            };
        }
        function getNodeScroll(node) {
            if (node === getWindow_getWindow(node) || !isHTMLElement(node)) return getWindowScroll(node); else return getHTMLElementScroll(node);
        }
        function getNodeName(element) {
            return element ? (element.nodeName || "").toLowerCase() : null;
        }
        function getDocumentElement(element) {
            return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
        }
        function getWindowScrollBarX(element) {
            return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
        }
        function getComputedStyle_getComputedStyle(element) {
            return getWindow_getWindow(element).getComputedStyle(element);
        }
        function isScrollParent(element) {
            var _getComputedStyle = getComputedStyle_getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
            return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
        }
        function isElementScaled(element) {
            var rect = element.getBoundingClientRect();
            var scaleX = round(rect.width) / element.offsetWidth || 1;
            var scaleY = round(rect.height) / element.offsetHeight || 1;
            return scaleX !== 1 || scaleY !== 1;
        }
        function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
            if (isFixed === void 0) isFixed = false;
            var isOffsetParentAnElement = isHTMLElement(offsetParent);
            var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
            var documentElement = getDocumentElement(offsetParent);
            var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
            var scroll = {
                scrollLeft: 0,
                scrollTop: 0
            };
            var offsets = {
                x: 0,
                y: 0
            };
            if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
                if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) scroll = getNodeScroll(offsetParent);
                if (isHTMLElement(offsetParent)) {
                    offsets = getBoundingClientRect(offsetParent, true);
                    offsets.x += offsetParent.clientLeft;
                    offsets.y += offsetParent.clientTop;
                } else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
            }
            return {
                x: rect.left + scroll.scrollLeft - offsets.x,
                y: rect.top + scroll.scrollTop - offsets.y,
                width: rect.width,
                height: rect.height
            };
        }
        function getLayoutRect(element) {
            var clientRect = getBoundingClientRect(element);
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
            if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
            return {
                x: element.offsetLeft,
                y: element.offsetTop,
                width,
                height
            };
        }
        function getParentNode(element) {
            if (getNodeName(element) === "html") return element;
            return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
        }
        function getScrollParent(node) {
            if ([ "html", "body", "#document" ].indexOf(getNodeName(node)) >= 0) return node.ownerDocument.body;
            if (isHTMLElement(node) && isScrollParent(node)) return node;
            return getScrollParent(getParentNode(node));
        }
        function listScrollParents(element, list) {
            var _element$ownerDocumen;
            if (list === void 0) list = [];
            var scrollParent = getScrollParent(element);
            var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
            var win = getWindow_getWindow(scrollParent);
            var target = isBody ? [ win ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
            var updatedList = list.concat(target);
            return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
        }
        function isTableElement(element) {
            return [ "table", "td", "th" ].indexOf(getNodeName(element)) >= 0;
        }
        function getTrueOffsetParent(element) {
            if (!isHTMLElement(element) || getComputedStyle_getComputedStyle(element).position === "fixed") return null;
            return element.offsetParent;
        }
        function getContainingBlock(element) {
            var isFirefox = /firefox/i.test(getUAString());
            var isIE = /Trident/i.test(getUAString());
            if (isIE && isHTMLElement(element)) {
                var elementCss = getComputedStyle_getComputedStyle(element);
                if (elementCss.position === "fixed") return null;
            }
            var currentNode = getParentNode(element);
            if (isShadowRoot(currentNode)) currentNode = currentNode.host;
            while (isHTMLElement(currentNode) && [ "html", "body" ].indexOf(getNodeName(currentNode)) < 0) {
                var css = getComputedStyle_getComputedStyle(currentNode);
                if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [ "transform", "perspective" ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode; else currentNode = currentNode.parentNode;
            }
            return null;
        }
        function getOffsetParent(element) {
            var window = getWindow_getWindow(element);
            var offsetParent = getTrueOffsetParent(element);
            while (offsetParent && isTableElement(offsetParent) && getComputedStyle_getComputedStyle(offsetParent).position === "static") offsetParent = getTrueOffsetParent(offsetParent);
            if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle_getComputedStyle(offsetParent).position === "static")) return window;
            return offsetParent || getContainingBlock(element) || window;
        }
        var enums_top = "top";
        var bottom = "bottom";
        var right = "right";
        var left = "left";
        var auto = "auto";
        var basePlacements = [ enums_top, bottom, right, left ];
        var start = "start";
        var end = "end";
        var clippingParents = "clippingParents";
        var viewport = "viewport";
        var popper = "popper";
        var reference = "reference";
        var variationPlacements = basePlacements.reduce((function(acc, placement) {
            return acc.concat([ placement + "-" + start, placement + "-" + end ]);
        }), []);
        var enums_placements = [].concat(basePlacements, [ auto ]).reduce((function(acc, placement) {
            return acc.concat([ placement, placement + "-" + start, placement + "-" + end ]);
        }), []);
        var beforeRead = "beforeRead";
        var read = "read";
        var afterRead = "afterRead";
        var beforeMain = "beforeMain";
        var main = "main";
        var afterMain = "afterMain";
        var beforeWrite = "beforeWrite";
        var write = "write";
        var afterWrite = "afterWrite";
        var modifierPhases = [ beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite ];
        function order(modifiers) {
            var map = new Map;
            var visited = new Set;
            var result = [];
            modifiers.forEach((function(modifier) {
                map.set(modifier.name, modifier);
            }));
            function sort(modifier) {
                visited.add(modifier.name);
                var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
                requires.forEach((function(dep) {
                    if (!visited.has(dep)) {
                        var depModifier = map.get(dep);
                        if (depModifier) sort(depModifier);
                    }
                }));
                result.push(modifier);
            }
            modifiers.forEach((function(modifier) {
                if (!visited.has(modifier.name)) sort(modifier);
            }));
            return result;
        }
        function orderModifiers(modifiers) {
            var orderedModifiers = order(modifiers);
            return modifierPhases.reduce((function(acc, phase) {
                return acc.concat(orderedModifiers.filter((function(modifier) {
                    return modifier.phase === phase;
                })));
            }), []);
        }
        function debounce(fn) {
            var pending;
            return function() {
                if (!pending) pending = new Promise((function(resolve) {
                    Promise.resolve().then((function() {
                        pending = void 0;
                        resolve(fn());
                    }));
                }));
                return pending;
            };
        }
        function mergeByName(modifiers) {
            var merged = modifiers.reduce((function(merged, current) {
                var existing = merged[current.name];
                merged[current.name] = existing ? Object.assign({}, existing, current, {
                    options: Object.assign({}, existing.options, current.options),
                    data: Object.assign({}, existing.data, current.data)
                }) : current;
                return merged;
            }), {});
            return Object.keys(merged).map((function(key) {
                return merged[key];
            }));
        }
        var DEFAULT_OPTIONS = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };
        function areValidElements() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return !args.some((function(element) {
                return !(element && typeof element.getBoundingClientRect === "function");
            }));
        }
        function popperGenerator(generatorOptions) {
            if (generatorOptions === void 0) generatorOptions = {};
            var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
            return function createPopper(reference, popper, options) {
                if (options === void 0) options = defaultOptions;
                var state = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
                    modifiersData: {},
                    elements: {
                        reference,
                        popper
                    },
                    attributes: {},
                    styles: {}
                };
                var effectCleanupFns = [];
                var isDestroyed = false;
                var instance = {
                    state,
                    setOptions: function setOptions(setOptionsAction) {
                        var options = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                        cleanupModifierEffects();
                        state.options = Object.assign({}, defaultOptions, state.options, options);
                        state.scrollParents = {
                            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                            popper: listScrollParents(popper)
                        };
                        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
                        state.orderedModifiers = orderedModifiers.filter((function(m) {
                            return m.enabled;
                        }));
                        runModifierEffects();
                        return instance.update();
                    },
                    forceUpdate: function forceUpdate() {
                        if (isDestroyed) return;
                        var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper;
                        if (!areValidElements(reference, popper)) return;
                        state.rects = {
                            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === "fixed"),
                            popper: getLayoutRect(popper)
                        };
                        state.reset = false;
                        state.placement = state.options.placement;
                        state.orderedModifiers.forEach((function(modifier) {
                            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                        }));
                        for (var index = 0; index < state.orderedModifiers.length; index++) {
                            if (state.reset === true) {
                                state.reset = false;
                                index = -1;
                                continue;
                            }
                            var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                            if (typeof fn === "function") state = fn({
                                state,
                                options: _options,
                                name,
                                instance
                            }) || state;
                        }
                    },
                    update: debounce((function() {
                        return new Promise((function(resolve) {
                            instance.forceUpdate();
                            resolve(state);
                        }));
                    })),
                    destroy: function destroy() {
                        cleanupModifierEffects();
                        isDestroyed = true;
                    }
                };
                if (!areValidElements(reference, popper)) return instance;
                instance.setOptions(options).then((function(state) {
                    if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state);
                }));
                function runModifierEffects() {
                    state.orderedModifiers.forEach((function(_ref) {
                        var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, effect = _ref.effect;
                        if (typeof effect === "function") {
                            var cleanupFn = effect({
                                state,
                                name,
                                instance,
                                options
                            });
                            var noopFn = function noopFn() {};
                            effectCleanupFns.push(cleanupFn || noopFn);
                        }
                    }));
                }
                function cleanupModifierEffects() {
                    effectCleanupFns.forEach((function(fn) {
                        return fn();
                    }));
                    effectCleanupFns = [];
                }
                return instance;
            };
        }
        null && popperGenerator();
        var passive = {
            passive: true
        };
        function effect(_ref) {
            var state = _ref.state, instance = _ref.instance, options = _ref.options;
            var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
            var window = getWindow_getWindow(state.elements.popper);
            var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
            if (scroll) scrollParents.forEach((function(scrollParent) {
                scrollParent.addEventListener("scroll", instance.update, passive);
            }));
            if (resize) window.addEventListener("resize", instance.update, passive);
            return function() {
                if (scroll) scrollParents.forEach((function(scrollParent) {
                    scrollParent.removeEventListener("scroll", instance.update, passive);
                }));
                if (resize) window.removeEventListener("resize", instance.update, passive);
            };
        }
        const eventListeners = {
            name: "eventListeners",
            enabled: true,
            phase: "write",
            fn: function fn() {},
            effect,
            data: {}
        };
        function getBasePlacement(placement) {
            return placement.split("-")[0];
        }
        function getVariation(placement) {
            return placement.split("-")[1];
        }
        function getMainAxisFromPlacement(placement) {
            return [ "top", "bottom" ].indexOf(placement) >= 0 ? "x" : "y";
        }
        function computeOffsets(_ref) {
            var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
            var basePlacement = placement ? getBasePlacement(placement) : null;
            var variation = placement ? getVariation(placement) : null;
            var commonX = reference.x + reference.width / 2 - element.width / 2;
            var commonY = reference.y + reference.height / 2 - element.height / 2;
            var offsets;
            switch (basePlacement) {
              case enums_top:
                offsets = {
                    x: commonX,
                    y: reference.y - element.height
                };
                break;

              case bottom:
                offsets = {
                    x: commonX,
                    y: reference.y + reference.height
                };
                break;

              case right:
                offsets = {
                    x: reference.x + reference.width,
                    y: commonY
                };
                break;

              case left:
                offsets = {
                    x: reference.x - element.width,
                    y: commonY
                };
                break;

              default:
                offsets = {
                    x: reference.x,
                    y: reference.y
                };
            }
            var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
            if (mainAxis != null) {
                var len = mainAxis === "y" ? "height" : "width";
                switch (variation) {
                  case start:
                    offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                    break;

                  case end:
                    offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                    break;

                  default:
                }
            }
            return offsets;
        }
        function popperOffsets(_ref) {
            var state = _ref.state, name = _ref.name;
            state.modifiersData[name] = computeOffsets({
                reference: state.rects.reference,
                element: state.rects.popper,
                strategy: "absolute",
                placement: state.placement
            });
        }
        const modifiers_popperOffsets = {
            name: "popperOffsets",
            enabled: true,
            phase: "read",
            fn: popperOffsets,
            data: {}
        };
        var unsetSides = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };
        function roundOffsetsByDPR(_ref, win) {
            var x = _ref.x, y = _ref.y;
            var dpr = win.devicePixelRatio || 1;
            return {
                x: round(x * dpr) / dpr || 0,
                y: round(y * dpr) / dpr || 0
            };
        }
        function mapToStyles(_ref2) {
            var _Object$assign2;
            var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
            var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
            var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
                x,
                y
            }) : {
                x,
                y
            };
            x = _ref3.x;
            y = _ref3.y;
            var hasX = offsets.hasOwnProperty("x");
            var hasY = offsets.hasOwnProperty("y");
            var sideX = left;
            var sideY = enums_top;
            var win = window;
            if (adaptive) {
                var offsetParent = getOffsetParent(popper);
                var heightProp = "clientHeight";
                var widthProp = "clientWidth";
                if (offsetParent === getWindow_getWindow(popper)) {
                    offsetParent = getDocumentElement(popper);
                    if (getComputedStyle_getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
                        heightProp = "scrollHeight";
                        widthProp = "scrollWidth";
                    }
                }
                offsetParent;
                if (placement === enums_top || (placement === left || placement === right) && variation === end) {
                    sideY = bottom;
                    var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
                    y -= offsetY - popperRect.height;
                    y *= gpuAcceleration ? 1 : -1;
                }
                if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
                    sideX = right;
                    var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
                    x -= offsetX - popperRect.width;
                    x *= gpuAcceleration ? 1 : -1;
                }
            }
            var commonStyles = Object.assign({
                position
            }, adaptive && unsetSides);
            var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
                x,
                y
            }, getWindow_getWindow(popper)) : {
                x,
                y
            };
            x = _ref4.x;
            y = _ref4.y;
            if (gpuAcceleration) {
                var _Object$assign;
                return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", 
                _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", 
                _Object$assign));
            }
            return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", 
            _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
        }
        function computeStyles(_ref5) {
            var state = _ref5.state, options = _ref5.options;
            var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
            var commonStyles = {
                placement: getBasePlacement(state.placement),
                variation: getVariation(state.placement),
                popper: state.elements.popper,
                popperRect: state.rects.popper,
                gpuAcceleration,
                isFixed: state.options.strategy === "fixed"
            };
            if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.popperOffsets,
                position: state.options.strategy,
                adaptive,
                roundOffsets
            })));
            if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.arrow,
                position: "absolute",
                adaptive: false,
                roundOffsets
            })));
            state.attributes.popper = Object.assign({}, state.attributes.popper, {
                "data-popper-placement": state.placement
            });
        }
        const modifiers_computeStyles = {
            name: "computeStyles",
            enabled: true,
            phase: "beforeWrite",
            fn: computeStyles,
            data: {}
        };
        function applyStyles(_ref) {
            var state = _ref.state;
            Object.keys(state.elements).forEach((function(name) {
                var style = state.styles[name] || {};
                var attributes = state.attributes[name] || {};
                var element = state.elements[name];
                if (!isHTMLElement(element) || !getNodeName(element)) return;
                Object.assign(element.style, style);
                Object.keys(attributes).forEach((function(name) {
                    var value = attributes[name];
                    if (value === false) element.removeAttribute(name); else element.setAttribute(name, value === true ? "" : value);
                }));
            }));
        }
        function applyStyles_effect(_ref2) {
            var state = _ref2.state;
            var initialStyles = {
                popper: {
                    position: state.options.strategy,
                    left: "0",
                    top: "0",
                    margin: "0"
                },
                arrow: {
                    position: "absolute"
                },
                reference: {}
            };
            Object.assign(state.elements.popper.style, initialStyles.popper);
            state.styles = initialStyles;
            if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
            return function() {
                Object.keys(state.elements).forEach((function(name) {
                    var element = state.elements[name];
                    var attributes = state.attributes[name] || {};
                    var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                    var style = styleProperties.reduce((function(style, property) {
                        style[property] = "";
                        return style;
                    }), {});
                    if (!isHTMLElement(element) || !getNodeName(element)) return;
                    Object.assign(element.style, style);
                    Object.keys(attributes).forEach((function(attribute) {
                        element.removeAttribute(attribute);
                    }));
                }));
            };
        }
        const modifiers_applyStyles = {
            name: "applyStyles",
            enabled: true,
            phase: "write",
            fn: applyStyles,
            effect: applyStyles_effect,
            requires: [ "computeStyles" ]
        };
        function distanceAndSkiddingToXY(placement, rects, offset) {
            var basePlacement = getBasePlacement(placement);
            var invertDistance = [ left, enums_top ].indexOf(basePlacement) >= 0 ? -1 : 1;
            var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
                placement
            })) : offset, skidding = _ref[0], distance = _ref[1];
            skidding = skidding || 0;
            distance = (distance || 0) * invertDistance;
            return [ left, right ].indexOf(basePlacement) >= 0 ? {
                x: distance,
                y: skidding
            } : {
                x: skidding,
                y: distance
            };
        }
        function offset_offset(_ref2) {
            var state = _ref2.state, options = _ref2.options, name = _ref2.name;
            var _options$offset = options.offset, offset = _options$offset === void 0 ? [ 0, 0 ] : _options$offset;
            var data = enums_placements.reduce((function(acc, placement) {
                acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
                return acc;
            }), {});
            var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
            if (state.modifiersData.popperOffsets != null) {
                state.modifiersData.popperOffsets.x += x;
                state.modifiersData.popperOffsets.y += y;
            }
            state.modifiersData[name] = data;
        }
        const modifiers_offset = {
            name: "offset",
            enabled: true,
            phase: "main",
            requires: [ "popperOffsets" ],
            fn: offset_offset
        };
        var hash = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        function getOppositePlacement(placement) {
            return placement.replace(/left|right|bottom|top/g, (function(matched) {
                return hash[matched];
            }));
        }
        var getOppositeVariationPlacement_hash = {
            start: "end",
            end: "start"
        };
        function getOppositeVariationPlacement(placement) {
            return placement.replace(/start|end/g, (function(matched) {
                return getOppositeVariationPlacement_hash[matched];
            }));
        }
        function getViewportRect(element, strategy) {
            var win = getWindow_getWindow(element);
            var html = getDocumentElement(element);
            var visualViewport = win.visualViewport;
            var width = html.clientWidth;
            var height = html.clientHeight;
            var x = 0;
            var y = 0;
            if (visualViewport) {
                width = visualViewport.width;
                height = visualViewport.height;
                var layoutViewport = isLayoutViewport();
                if (layoutViewport || !layoutViewport && strategy === "fixed") {
                    x = visualViewport.offsetLeft;
                    y = visualViewport.offsetTop;
                }
            }
            return {
                width,
                height,
                x: x + getWindowScrollBarX(element),
                y
            };
        }
        function getDocumentRect(element) {
            var _element$ownerDocumen;
            var html = getDocumentElement(element);
            var winScroll = getWindowScroll(element);
            var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
            var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
            var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
            var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
            var y = -winScroll.scrollTop;
            if (getComputedStyle_getComputedStyle(body || html).direction === "rtl") x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
            return {
                width,
                height,
                x,
                y
            };
        }
        function contains(parent, child) {
            var rootNode = child.getRootNode && child.getRootNode();
            if (parent.contains(child)) return true; else if (rootNode && isShadowRoot(rootNode)) {
                var next = child;
                do {
                    if (next && parent.isSameNode(next)) return true;
                    next = next.parentNode || next.host;
                } while (next);
            }
            return false;
        }
        function rectToClientRect(rect) {
            return Object.assign({}, rect, {
                left: rect.x,
                top: rect.y,
                right: rect.x + rect.width,
                bottom: rect.y + rect.height
            });
        }
        function getInnerBoundingClientRect(element, strategy) {
            var rect = getBoundingClientRect(element, false, strategy === "fixed");
            rect.top = rect.top + element.clientTop;
            rect.left = rect.left + element.clientLeft;
            rect.bottom = rect.top + element.clientHeight;
            rect.right = rect.left + element.clientWidth;
            rect.width = element.clientWidth;
            rect.height = element.clientHeight;
            rect.x = rect.left;
            rect.y = rect.top;
            return rect;
        }
        function getClientRectFromMixedType(element, clippingParent, strategy) {
            return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
        }
        function getClippingParents(element) {
            var clippingParents = listScrollParents(getParentNode(element));
            var canEscapeClipping = [ "absolute", "fixed" ].indexOf(getComputedStyle_getComputedStyle(element).position) >= 0;
            var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
            if (!isElement(clipperElement)) return [];
            return clippingParents.filter((function(clippingParent) {
                return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
            }));
        }
        function getClippingRect(element, boundary, rootBoundary, strategy) {
            var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
            var clippingParents = [].concat(mainClippingParents, [ rootBoundary ]);
            var firstClippingParent = clippingParents[0];
            var clippingRect = clippingParents.reduce((function(accRect, clippingParent) {
                var rect = getClientRectFromMixedType(element, clippingParent, strategy);
                accRect.top = math_max(rect.top, accRect.top);
                accRect.right = math_min(rect.right, accRect.right);
                accRect.bottom = math_min(rect.bottom, accRect.bottom);
                accRect.left = math_max(rect.left, accRect.left);
                return accRect;
            }), getClientRectFromMixedType(element, firstClippingParent, strategy));
            clippingRect.width = clippingRect.right - clippingRect.left;
            clippingRect.height = clippingRect.bottom - clippingRect.top;
            clippingRect.x = clippingRect.left;
            clippingRect.y = clippingRect.top;
            return clippingRect;
        }
        function getFreshSideObject() {
            return {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            };
        }
        function mergePaddingObject(paddingObject) {
            return Object.assign({}, getFreshSideObject(), paddingObject);
        }
        function expandToHashMap(value, keys) {
            return keys.reduce((function(hashMap, key) {
                hashMap[key] = value;
                return hashMap;
            }), {});
        }
        function detectOverflow(state, options) {
            if (options === void 0) options = {};
            var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
            var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
            var altContext = elementContext === popper ? reference : popper;
            var popperRect = state.rects.popper;
            var element = state.elements[altBoundary ? altContext : elementContext];
            var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
            var referenceClientRect = getBoundingClientRect(state.elements.reference);
            var popperOffsets = computeOffsets({
                reference: referenceClientRect,
                element: popperRect,
                strategy: "absolute",
                placement
            });
            var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
            var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
            var overflowOffsets = {
                top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
                bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
                left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
                right: elementClientRect.right - clippingClientRect.right + paddingObject.right
            };
            var offsetData = state.modifiersData.offset;
            if (elementContext === popper && offsetData) {
                var offset = offsetData[placement];
                Object.keys(overflowOffsets).forEach((function(key) {
                    var multiply = [ right, bottom ].indexOf(key) >= 0 ? 1 : -1;
                    var axis = [ enums_top, bottom ].indexOf(key) >= 0 ? "y" : "x";
                    overflowOffsets[key] += offset[axis] * multiply;
                }));
            }
            return overflowOffsets;
        }
        function computeAutoPlacement(state, options) {
            if (options === void 0) options = {};
            var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
            var variation = getVariation(placement);
            var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter((function(placement) {
                return getVariation(placement) === variation;
            })) : basePlacements;
            var allowedPlacements = placements.filter((function(placement) {
                return allowedAutoPlacements.indexOf(placement) >= 0;
            }));
            if (allowedPlacements.length === 0) allowedPlacements = placements;
            var overflows = allowedPlacements.reduce((function(acc, placement) {
                acc[placement] = detectOverflow(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding
                })[getBasePlacement(placement)];
                return acc;
            }), {});
            return Object.keys(overflows).sort((function(a, b) {
                return overflows[a] - overflows[b];
            }));
        }
        function getExpandedFallbackPlacements(placement) {
            if (getBasePlacement(placement) === auto) return [];
            var oppositePlacement = getOppositePlacement(placement);
            return [ getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement) ];
        }
        function flip(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            if (state.modifiersData[name]._skip) return;
            var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
            var preferredPlacement = state.options.placement;
            var basePlacement = getBasePlacement(preferredPlacement);
            var isBasePlacement = basePlacement === preferredPlacement;
            var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [ getOppositePlacement(preferredPlacement) ] : getExpandedFallbackPlacements(preferredPlacement));
            var placements = [ preferredPlacement ].concat(fallbackPlacements).reduce((function(acc, placement) {
                return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding,
                    flipVariations,
                    allowedAutoPlacements
                }) : placement);
            }), []);
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var checksMap = new Map;
            var makeFallbackChecks = true;
            var firstFittingPlacement = placements[0];
            for (var i = 0; i < placements.length; i++) {
                var placement = placements[i];
                var _basePlacement = getBasePlacement(placement);
                var isStartVariation = getVariation(placement) === start;
                var isVertical = [ enums_top, bottom ].indexOf(_basePlacement) >= 0;
                var len = isVertical ? "width" : "height";
                var overflow = detectOverflow(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    altBoundary,
                    padding
                });
                var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;
                if (referenceRect[len] > popperRect[len]) mainVariationSide = getOppositePlacement(mainVariationSide);
                var altVariationSide = getOppositePlacement(mainVariationSide);
                var checks = [];
                if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
                if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
                if (checks.every((function(check) {
                    return check;
                }))) {
                    firstFittingPlacement = placement;
                    makeFallbackChecks = false;
                    break;
                }
                checksMap.set(placement, checks);
            }
            if (makeFallbackChecks) {
                var numberOfChecks = flipVariations ? 3 : 1;
                var _loop = function _loop(_i) {
                    var fittingPlacement = placements.find((function(placement) {
                        var checks = checksMap.get(placement);
                        if (checks) return checks.slice(0, _i).every((function(check) {
                            return check;
                        }));
                    }));
                    if (fittingPlacement) {
                        firstFittingPlacement = fittingPlacement;
                        return "break";
                    }
                };
                for (var _i = numberOfChecks; _i > 0; _i--) {
                    var _ret = _loop(_i);
                    if (_ret === "break") break;
                }
            }
            if (state.placement !== firstFittingPlacement) {
                state.modifiersData[name]._skip = true;
                state.placement = firstFittingPlacement;
                state.reset = true;
            }
        }
        const modifiers_flip = {
            name: "flip",
            enabled: true,
            phase: "main",
            fn: flip,
            requiresIfExists: [ "offset" ],
            data: {
                _skip: false
            }
        };
        function getAltAxis(axis) {
            return axis === "x" ? "y" : "x";
        }
        function within(min, value, max) {
            return math_max(min, math_min(value, max));
        }
        function withinMaxClamp(min, value, max) {
            var v = within(min, value, max);
            return v > max ? max : v;
        }
        function preventOverflow(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
            var overflow = detectOverflow(state, {
                boundary,
                rootBoundary,
                padding,
                altBoundary
            });
            var basePlacement = getBasePlacement(state.placement);
            var variation = getVariation(state.placement);
            var isBasePlacement = !variation;
            var mainAxis = getMainAxisFromPlacement(basePlacement);
            var altAxis = getAltAxis(mainAxis);
            var popperOffsets = state.modifiersData.popperOffsets;
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
                placement: state.placement
            })) : tetherOffset;
            var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
                mainAxis: tetherOffsetValue,
                altAxis: tetherOffsetValue
            } : Object.assign({
                mainAxis: 0,
                altAxis: 0
            }, tetherOffsetValue);
            var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
            var data = {
                x: 0,
                y: 0
            };
            if (!popperOffsets) return;
            if (checkMainAxis) {
                var _offsetModifierState$;
                var mainSide = mainAxis === "y" ? enums_top : left;
                var altSide = mainAxis === "y" ? bottom : right;
                var len = mainAxis === "y" ? "height" : "width";
                var offset = popperOffsets[mainAxis];
                var min = offset + overflow[mainSide];
                var max = offset - overflow[altSide];
                var additive = tether ? -popperRect[len] / 2 : 0;
                var minLen = variation === start ? referenceRect[len] : popperRect[len];
                var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
                var arrowElement = state.elements.arrow;
                var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                    width: 0,
                    height: 0
                };
                var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
                var arrowPaddingMin = arrowPaddingObject[mainSide];
                var arrowPaddingMax = arrowPaddingObject[altSide];
                var arrowLen = within(0, referenceRect[len], arrowRect[len]);
                var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
                var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
                var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
                var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
                var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
                var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
                var tetherMax = offset + maxOffset - offsetModifierValue;
                var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
                popperOffsets[mainAxis] = preventedOffset;
                data[mainAxis] = preventedOffset - offset;
            }
            if (checkAltAxis) {
                var _offsetModifierState$2;
                var _mainSide = mainAxis === "x" ? enums_top : left;
                var _altSide = mainAxis === "x" ? bottom : right;
                var _offset = popperOffsets[altAxis];
                var _len = altAxis === "y" ? "height" : "width";
                var _min = _offset + overflow[_mainSide];
                var _max = _offset - overflow[_altSide];
                var isOriginSide = [ enums_top, left ].indexOf(basePlacement) !== -1;
                var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
                var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
                var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
                var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
                popperOffsets[altAxis] = _preventedOffset;
                data[altAxis] = _preventedOffset - _offset;
            }
            state.modifiersData[name] = data;
        }
        const modifiers_preventOverflow = {
            name: "preventOverflow",
            enabled: true,
            phase: "main",
            fn: preventOverflow,
            requiresIfExists: [ "offset" ]
        };
        var toPaddingObject = function toPaddingObject(padding, state) {
            padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
                placement: state.placement
            })) : padding;
            return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
        };
        function arrow(_ref) {
            var _state$modifiersData$;
            var state = _ref.state, name = _ref.name, options = _ref.options;
            var arrowElement = state.elements.arrow;
            var popperOffsets = state.modifiersData.popperOffsets;
            var basePlacement = getBasePlacement(state.placement);
            var axis = getMainAxisFromPlacement(basePlacement);
            var isVertical = [ left, right ].indexOf(basePlacement) >= 0;
            var len = isVertical ? "height" : "width";
            if (!arrowElement || !popperOffsets) return;
            var paddingObject = toPaddingObject(options.padding, state);
            var arrowRect = getLayoutRect(arrowElement);
            var minProp = axis === "y" ? enums_top : left;
            var maxProp = axis === "y" ? bottom : right;
            var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
            var startDiff = popperOffsets[axis] - state.rects.reference[axis];
            var arrowOffsetParent = getOffsetParent(arrowElement);
            var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
            var centerToReference = endDiff / 2 - startDiff / 2;
            var min = paddingObject[minProp];
            var max = clientSize - arrowRect[len] - paddingObject[maxProp];
            var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
            var offset = within(min, center, max);
            var axisProp = axis;
            state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, 
            _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
        }
        function arrow_effect(_ref2) {
            var state = _ref2.state, options = _ref2.options;
            var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
            if (arrowElement == null) return;
            if (typeof arrowElement === "string") {
                arrowElement = state.elements.popper.querySelector(arrowElement);
                if (!arrowElement) return;
            }
            if (!contains(state.elements.popper, arrowElement)) return;
            state.elements.arrow = arrowElement;
        }
        const modifiers_arrow = {
            name: "arrow",
            enabled: true,
            phase: "main",
            fn: arrow,
            effect: arrow_effect,
            requires: [ "popperOffsets" ],
            requiresIfExists: [ "preventOverflow" ]
        };
        function getSideOffsets(overflow, rect, preventedOffsets) {
            if (preventedOffsets === void 0) preventedOffsets = {
                x: 0,
                y: 0
            };
            return {
                top: overflow.top - rect.height - preventedOffsets.y,
                right: overflow.right - rect.width + preventedOffsets.x,
                bottom: overflow.bottom - rect.height + preventedOffsets.y,
                left: overflow.left - rect.width - preventedOffsets.x
            };
        }
        function isAnySideFullyClipped(overflow) {
            return [ enums_top, right, bottom, left ].some((function(side) {
                return overflow[side] >= 0;
            }));
        }
        function hide(_ref) {
            var state = _ref.state, name = _ref.name;
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var preventedOffsets = state.modifiersData.preventOverflow;
            var referenceOverflow = detectOverflow(state, {
                elementContext: "reference"
            });
            var popperAltOverflow = detectOverflow(state, {
                altBoundary: true
            });
            var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
            var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
            var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
            var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
            state.modifiersData[name] = {
                referenceClippingOffsets,
                popperEscapeOffsets,
                isReferenceHidden,
                hasPopperEscaped
            };
            state.attributes.popper = Object.assign({}, state.attributes.popper, {
                "data-popper-reference-hidden": isReferenceHidden,
                "data-popper-escaped": hasPopperEscaped
            });
        }
        const modifiers_hide = {
            name: "hide",
            enabled: true,
            phase: "main",
            requiresIfExists: [ "preventOverflow" ],
            fn: hide
        };
        var defaultModifiers = [ eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide ];
        var popper_createPopper = popperGenerator({
            defaultModifiers
        });
        var BOX_CLASS = "tippy-box";
        var CONTENT_CLASS = "tippy-content";
        var BACKDROP_CLASS = "tippy-backdrop";
        var ARROW_CLASS = "tippy-arrow";
        var SVG_ARROW_CLASS = "tippy-svg-arrow";
        var TOUCH_OPTIONS = {
            passive: true,
            capture: true
        };
        var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
            return document.body;
        };
        function getValueAtIndexOrReturn(value, index, defaultValue) {
            if (Array.isArray(value)) {
                var v = value[index];
                return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
            }
            return value;
        }
        function isType(value, type) {
            var str = {}.toString.call(value);
            return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
        }
        function invokeWithArgsOrReturn(value, args) {
            return typeof value === "function" ? value.apply(void 0, args) : value;
        }
        function tippy_esm_debounce(fn, ms) {
            if (ms === 0) return fn;
            var timeout;
            return function(arg) {
                clearTimeout(timeout);
                timeout = setTimeout((function() {
                    fn(arg);
                }), ms);
            };
        }
        function splitBySpaces(value) {
            return value.split(/\s+/).filter(Boolean);
        }
        function normalizeToArray(value) {
            return [].concat(value);
        }
        function pushIfUnique(arr, value) {
            if (arr.indexOf(value) === -1) arr.push(value);
        }
        function tippy_esm_unique(arr) {
            return arr.filter((function(item, index) {
                return arr.indexOf(item) === index;
            }));
        }
        function tippy_esm_getBasePlacement(placement) {
            return placement.split("-")[0];
        }
        function arrayFrom(value) {
            return [].slice.call(value);
        }
        function removeUndefinedProps(obj) {
            return Object.keys(obj).reduce((function(acc, key) {
                if (obj[key] !== void 0) acc[key] = obj[key];
                return acc;
            }), {});
        }
        function div() {
            return document.createElement("div");
        }
        function tippy_esm_isElement(value) {
            return [ "Element", "Fragment" ].some((function(type) {
                return isType(value, type);
            }));
        }
        function isNodeList(value) {
            return isType(value, "NodeList");
        }
        function isMouseEvent(value) {
            return isType(value, "MouseEvent");
        }
        function isReferenceElement(value) {
            return !!(value && value._tippy && value._tippy.reference === value);
        }
        function getArrayOfElements(value) {
            if (tippy_esm_isElement(value)) return [ value ];
            if (isNodeList(value)) return arrayFrom(value);
            if (Array.isArray(value)) return value;
            return arrayFrom(document.querySelectorAll(value));
        }
        function setTransitionDuration(els, value) {
            els.forEach((function(el) {
                if (el) el.style.transitionDuration = value + "ms";
            }));
        }
        function setVisibilityState(els, state) {
            els.forEach((function(el) {
                if (el) el.setAttribute("data-state", state);
            }));
        }
        function getOwnerDocument(elementOrElements) {
            var _element$ownerDocumen;
            var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
            return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
        }
        function isCursorOutsideInteractiveBorder(popperTreeData, event) {
            var clientX = event.clientX, clientY = event.clientY;
            return popperTreeData.every((function(_ref) {
                var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
                var interactiveBorder = props.interactiveBorder;
                var basePlacement = tippy_esm_getBasePlacement(popperState.placement);
                var offsetData = popperState.modifiersData.offset;
                if (!offsetData) return true;
                var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
                var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
                var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
                var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
                var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
                var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
                var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
                var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
                return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
            }));
        }
        function updateTransitionEndListener(box, action, listener) {
            var method = action + "EventListener";
            [ "transitionend", "webkitTransitionEnd" ].forEach((function(event) {
                box[method](event, listener);
            }));
        }
        function actualContains(parent, child) {
            var target = child;
            while (target) {
                var _target$getRootNode;
                if (parent.contains(target)) return true;
                target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
            }
            return false;
        }
        var currentInput = {
            isTouch: false
        };
        var lastMouseMoveTime = 0;
        function onDocumentTouchStart() {
            if (currentInput.isTouch) return;
            currentInput.isTouch = true;
            if (window.performance) document.addEventListener("mousemove", onDocumentMouseMove);
        }
        function onDocumentMouseMove() {
            var now = performance.now();
            if (now - lastMouseMoveTime < 20) {
                currentInput.isTouch = false;
                document.removeEventListener("mousemove", onDocumentMouseMove);
            }
            lastMouseMoveTime = now;
        }
        function onWindowBlur() {
            var activeElement = document.activeElement;
            if (isReferenceElement(activeElement)) {
                var instance = activeElement._tippy;
                if (activeElement.blur && !instance.state.isVisible) activeElement.blur();
            }
        }
        function bindGlobalEventListeners() {
            document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
            window.addEventListener("blur", onWindowBlur);
        }
        var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
        var isIE11 = isBrowser ? !!window.msCrypto : false;
        if (false) ;
        var pluginProps = {
            animateFill: false,
            followCursor: false,
            inlinePositioning: false,
            sticky: false
        };
        var renderProps = {
            allowHTML: false,
            animation: "fade",
            arrow: true,
            content: "",
            inertia: false,
            maxWidth: 350,
            role: "tooltip",
            theme: "",
            zIndex: 9999
        };
        var defaultProps = Object.assign({
            appendTo: TIPPY_DEFAULT_APPEND_TO,
            aria: {
                content: "auto",
                expanded: "auto"
            },
            delay: 0,
            duration: [ 300, 250 ],
            getReferenceClientRect: null,
            hideOnClick: true,
            ignoreAttributes: false,
            interactive: false,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: "",
            offset: [ 0, 10 ],
            onAfterUpdate: function onAfterUpdate() {},
            onBeforeUpdate: function onBeforeUpdate() {},
            onCreate: function onCreate() {},
            onDestroy: function onDestroy() {},
            onHidden: function onHidden() {},
            onHide: function onHide() {},
            onMount: function onMount() {},
            onShow: function onShow() {},
            onShown: function onShown() {},
            onTrigger: function onTrigger() {},
            onUntrigger: function onUntrigger() {},
            onClickOutside: function onClickOutside() {},
            placement: "top",
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: false,
            touch: true,
            trigger: "mouseenter focus",
            triggerTarget: null
        }, pluginProps, renderProps);
        var defaultKeys = Object.keys(defaultProps);
        var setDefaultProps = function setDefaultProps(partialProps) {
            if (false) ;
            var keys = Object.keys(partialProps);
            keys.forEach((function(key) {
                defaultProps[key] = partialProps[key];
            }));
        };
        function getExtendedPassedProps(passedProps) {
            var plugins = passedProps.plugins || [];
            var pluginProps = plugins.reduce((function(acc, plugin) {
                var name = plugin.name, defaultValue = plugin.defaultValue;
                if (name) {
                    var _name;
                    acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
                }
                return acc;
            }), {});
            return Object.assign({}, passedProps, pluginProps);
        }
        function getDataAttributeProps(reference, plugins) {
            var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
                plugins
            }))) : defaultKeys;
            var props = propKeys.reduce((function(acc, key) {
                var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
                if (!valueAsString) return acc;
                if (key === "content") acc[key] = valueAsString; else try {
                    acc[key] = JSON.parse(valueAsString);
                } catch (e) {
                    acc[key] = valueAsString;
                }
                return acc;
            }), {});
            return props;
        }
        function evaluateProps(reference, props) {
            var out = Object.assign({}, props, {
                content: invokeWithArgsOrReturn(props.content, [ reference ])
            }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
            out.aria = Object.assign({}, defaultProps.aria, out.aria);
            out.aria = {
                expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
                content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
            };
            return out;
        }
        var innerHTML = function innerHTML() {
            return "innerHTML";
        };
        function dangerouslySetInnerHTML(element, html) {
            element[innerHTML()] = html;
        }
        function createArrowElement(value) {
            var arrow = div();
            if (value === true) arrow.className = ARROW_CLASS; else {
                arrow.className = SVG_ARROW_CLASS;
                if (tippy_esm_isElement(value)) arrow.appendChild(value); else dangerouslySetInnerHTML(arrow, value);
            }
            return arrow;
        }
        function setContent(content, props) {
            if (tippy_esm_isElement(props.content)) {
                dangerouslySetInnerHTML(content, "");
                content.appendChild(props.content);
            } else if (typeof props.content !== "function") if (props.allowHTML) dangerouslySetInnerHTML(content, props.content); else content.textContent = props.content;
        }
        function getChildren(popper) {
            var box = popper.firstElementChild;
            var boxChildren = arrayFrom(box.children);
            return {
                box,
                content: boxChildren.find((function(node) {
                    return node.classList.contains(CONTENT_CLASS);
                })),
                arrow: boxChildren.find((function(node) {
                    return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
                })),
                backdrop: boxChildren.find((function(node) {
                    return node.classList.contains(BACKDROP_CLASS);
                }))
            };
        }
        function render(instance) {
            var popper = div();
            var box = div();
            box.className = BOX_CLASS;
            box.setAttribute("data-state", "hidden");
            box.setAttribute("tabindex", "-1");
            var content = div();
            content.className = CONTENT_CLASS;
            content.setAttribute("data-state", "hidden");
            setContent(content, instance.props);
            popper.appendChild(box);
            box.appendChild(content);
            onUpdate(instance.props, instance.props);
            function onUpdate(prevProps, nextProps) {
                var _getChildren = getChildren(popper), box = _getChildren.box, content = _getChildren.content, arrow = _getChildren.arrow;
                if (nextProps.theme) box.setAttribute("data-theme", nextProps.theme); else box.removeAttribute("data-theme");
                if (typeof nextProps.animation === "string") box.setAttribute("data-animation", nextProps.animation); else box.removeAttribute("data-animation");
                if (nextProps.inertia) box.setAttribute("data-inertia", ""); else box.removeAttribute("data-inertia");
                box.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
                if (nextProps.role) box.setAttribute("role", nextProps.role); else box.removeAttribute("role");
                if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) setContent(content, instance.props);
                if (nextProps.arrow) {
                    if (!arrow) box.appendChild(createArrowElement(nextProps.arrow)); else if (prevProps.arrow !== nextProps.arrow) {
                        box.removeChild(arrow);
                        box.appendChild(createArrowElement(nextProps.arrow));
                    }
                } else if (arrow) box.removeChild(arrow);
            }
            return {
                popper,
                onUpdate
            };
        }
        render.$$tippy = true;
        var idCounter = 1;
        var mouseMoveListeners = [];
        var mountedInstances = [];
        function createTippy(reference, passedProps) {
            var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
            var showTimeout;
            var hideTimeout;
            var scheduleHideAnimationFrame;
            var isVisibleFromClick = false;
            var didHideDueToDocumentMouseDown = false;
            var didTouchMove = false;
            var ignoreOnFirstUpdate = false;
            var lastTriggerEvent;
            var currentTransitionEndListener;
            var onFirstUpdate;
            var listeners = [];
            var debouncedOnMouseMove = tippy_esm_debounce(onMouseMove, props.interactiveDebounce);
            var currentTarget;
            var id = idCounter++;
            var popperInstance = null;
            var plugins = tippy_esm_unique(props.plugins);
            var state = {
                isEnabled: true,
                isVisible: false,
                isDestroyed: false,
                isMounted: false,
                isShown: false
            };
            var instance = {
                id,
                reference,
                popper: div(),
                popperInstance,
                props,
                state,
                plugins,
                clearDelayTimeouts,
                setProps,
                setContent,
                show,
                hide,
                hideWithInteractivity,
                enable,
                disable,
                unmount,
                destroy
            };
            if (!props.render) {
                if (false) ;
                return instance;
            }
            var _props$render = props.render(instance), popper = _props$render.popper, onUpdate = _props$render.onUpdate;
            popper.setAttribute("data-tippy-root", "");
            popper.id = "tippy-" + instance.id;
            instance.popper = popper;
            reference._tippy = instance;
            popper._tippy = instance;
            var pluginsHooks = plugins.map((function(plugin) {
                return plugin.fn(instance);
            }));
            var hasAriaExpanded = reference.hasAttribute("aria-expanded");
            addListeners();
            handleAriaExpandedAttribute();
            handleStyles();
            invokeHook("onCreate", [ instance ]);
            if (props.showOnCreate) scheduleShow();
            popper.addEventListener("mouseenter", (function() {
                if (instance.props.interactive && instance.state.isVisible) instance.clearDelayTimeouts();
            }));
            popper.addEventListener("mouseleave", (function() {
                if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) getDocument().addEventListener("mousemove", debouncedOnMouseMove);
            }));
            return instance;
            function getNormalizedTouchSettings() {
                var touch = instance.props.touch;
                return Array.isArray(touch) ? touch : [ touch, 0 ];
            }
            function getIsCustomTouchBehavior() {
                return getNormalizedTouchSettings()[0] === "hold";
            }
            function getIsDefaultRenderFn() {
                var _instance$props$rende;
                return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
            }
            function getCurrentTarget() {
                return currentTarget || reference;
            }
            function getDocument() {
                var parent = getCurrentTarget().parentNode;
                return parent ? getOwnerDocument(parent) : document;
            }
            function getDefaultTemplateChildren() {
                return getChildren(popper);
            }
            function getDelay(isShow) {
                if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") return 0;
                return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
            }
            function handleStyles(fromHide) {
                if (fromHide === void 0) fromHide = false;
                popper.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
                popper.style.zIndex = "" + instance.props.zIndex;
            }
            function invokeHook(hook, args, shouldInvokePropsHook) {
                if (shouldInvokePropsHook === void 0) shouldInvokePropsHook = true;
                pluginsHooks.forEach((function(pluginHooks) {
                    if (pluginHooks[hook]) pluginHooks[hook].apply(pluginHooks, args);
                }));
                if (shouldInvokePropsHook) {
                    var _instance$props;
                    (_instance$props = instance.props)[hook].apply(_instance$props, args);
                }
            }
            function handleAriaContentAttribute() {
                var aria = instance.props.aria;
                if (!aria.content) return;
                var attr = "aria-" + aria.content;
                var id = popper.id;
                var nodes = normalizeToArray(instance.props.triggerTarget || reference);
                nodes.forEach((function(node) {
                    var currentValue = node.getAttribute(attr);
                    if (instance.state.isVisible) node.setAttribute(attr, currentValue ? currentValue + " " + id : id); else {
                        var nextValue = currentValue && currentValue.replace(id, "").trim();
                        if (nextValue) node.setAttribute(attr, nextValue); else node.removeAttribute(attr);
                    }
                }));
            }
            function handleAriaExpandedAttribute() {
                if (hasAriaExpanded || !instance.props.aria.expanded) return;
                var nodes = normalizeToArray(instance.props.triggerTarget || reference);
                nodes.forEach((function(node) {
                    if (instance.props.interactive) node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false"); else node.removeAttribute("aria-expanded");
                }));
            }
            function cleanupInteractiveMouseListeners() {
                getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
                mouseMoveListeners = mouseMoveListeners.filter((function(listener) {
                    return listener !== debouncedOnMouseMove;
                }));
            }
            function onDocumentPress(event) {
                if (currentInput.isTouch) if (didTouchMove || event.type === "mousedown") return;
                var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
                if (instance.props.interactive && actualContains(popper, actualTarget)) return;
                if (normalizeToArray(instance.props.triggerTarget || reference).some((function(el) {
                    return actualContains(el, actualTarget);
                }))) {
                    if (currentInput.isTouch) return;
                    if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) return;
                } else invokeHook("onClickOutside", [ instance, event ]);
                if (instance.props.hideOnClick === true) {
                    instance.clearDelayTimeouts();
                    instance.hide();
                    didHideDueToDocumentMouseDown = true;
                    setTimeout((function() {
                        didHideDueToDocumentMouseDown = false;
                    }));
                    if (!instance.state.isMounted) removeDocumentPress();
                }
            }
            function onTouchMove() {
                didTouchMove = true;
            }
            function onTouchStart() {
                didTouchMove = false;
            }
            function addDocumentPress() {
                var doc = getDocument();
                doc.addEventListener("mousedown", onDocumentPress, true);
                doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
                doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
                doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
            }
            function removeDocumentPress() {
                var doc = getDocument();
                doc.removeEventListener("mousedown", onDocumentPress, true);
                doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
                doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
                doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
            }
            function onTransitionedOut(duration, callback) {
                onTransitionEnd(duration, (function() {
                    if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) callback();
                }));
            }
            function onTransitionedIn(duration, callback) {
                onTransitionEnd(duration, callback);
            }
            function onTransitionEnd(duration, callback) {
                var box = getDefaultTemplateChildren().box;
                function listener(event) {
                    if (event.target === box) {
                        updateTransitionEndListener(box, "remove", listener);
                        callback();
                    }
                }
                if (duration === 0) return callback();
                updateTransitionEndListener(box, "remove", currentTransitionEndListener);
                updateTransitionEndListener(box, "add", listener);
                currentTransitionEndListener = listener;
            }
            function on(eventType, handler, options) {
                if (options === void 0) options = false;
                var nodes = normalizeToArray(instance.props.triggerTarget || reference);
                nodes.forEach((function(node) {
                    node.addEventListener(eventType, handler, options);
                    listeners.push({
                        node,
                        eventType,
                        handler,
                        options
                    });
                }));
            }
            function addListeners() {
                if (getIsCustomTouchBehavior()) {
                    on("touchstart", onTrigger, {
                        passive: true
                    });
                    on("touchend", onMouseLeave, {
                        passive: true
                    });
                }
                splitBySpaces(instance.props.trigger).forEach((function(eventType) {
                    if (eventType === "manual") return;
                    on(eventType, onTrigger);
                    switch (eventType) {
                      case "mouseenter":
                        on("mouseleave", onMouseLeave);
                        break;

                      case "focus":
                        on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
                        break;

                      case "focusin":
                        on("focusout", onBlurOrFocusOut);
                        break;
                    }
                }));
            }
            function removeListeners() {
                listeners.forEach((function(_ref) {
                    var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
                    node.removeEventListener(eventType, handler, options);
                }));
                listeners = [];
            }
            function onTrigger(event) {
                var _lastTriggerEvent;
                var shouldScheduleClickHide = false;
                if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) return;
                var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
                lastTriggerEvent = event;
                currentTarget = event.currentTarget;
                handleAriaExpandedAttribute();
                if (!instance.state.isVisible && isMouseEvent(event)) mouseMoveListeners.forEach((function(listener) {
                    return listener(event);
                }));
                if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) shouldScheduleClickHide = true; else scheduleShow(event);
                if (event.type === "click") isVisibleFromClick = !shouldScheduleClickHide;
                if (shouldScheduleClickHide && !wasFocused) scheduleHide(event);
            }
            function onMouseMove(event) {
                var target = event.target;
                var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
                if (event.type === "mousemove" && isCursorOverReferenceOrPopper) return;
                var popperTreeData = getNestedPopperTree().concat(popper).map((function(popper) {
                    var _instance$popperInsta;
                    var instance = popper._tippy;
                    var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;
                    if (state) return {
                        popperRect: popper.getBoundingClientRect(),
                        popperState: state,
                        props
                    };
                    return null;
                })).filter(Boolean);
                if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
                    cleanupInteractiveMouseListeners();
                    scheduleHide(event);
                }
            }
            function onMouseLeave(event) {
                var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
                if (shouldBail) return;
                if (instance.props.interactive) {
                    instance.hideWithInteractivity(event);
                    return;
                }
                scheduleHide(event);
            }
            function onBlurOrFocusOut(event) {
                if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) return;
                if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) return;
                scheduleHide(event);
            }
            function isEventListenerStopped(event) {
                return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
            }
            function createPopperInstance() {
                destroyPopperInstance();
                var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
                var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
                var computedReference = getReferenceClientRect ? {
                    getBoundingClientRect: getReferenceClientRect,
                    contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
                } : reference;
                var tippyModifier = {
                    name: "$$tippy",
                    enabled: true,
                    phase: "beforeWrite",
                    requires: [ "computeStyles" ],
                    fn: function fn(_ref2) {
                        var state = _ref2.state;
                        if (getIsDefaultRenderFn()) {
                            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
                            [ "placement", "reference-hidden", "escaped" ].forEach((function(attr) {
                                if (attr === "placement") box.setAttribute("data-placement", state.placement); else if (state.attributes.popper["data-popper-" + attr]) box.setAttribute("data-" + attr, ""); else box.removeAttribute("data-" + attr);
                            }));
                            state.attributes.popper = {};
                        }
                    }
                };
                var modifiers = [ {
                    name: "offset",
                    options: {
                        offset
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        padding: {
                            top: 2,
                            bottom: 2,
                            left: 5,
                            right: 5
                        }
                    }
                }, {
                    name: "flip",
                    options: {
                        padding: 5
                    }
                }, {
                    name: "computeStyles",
                    options: {
                        adaptive: !moveTransition
                    }
                }, tippyModifier ];
                if (getIsDefaultRenderFn() && arrow) modifiers.push({
                    name: "arrow",
                    options: {
                        element: arrow,
                        padding: 3
                    }
                });
                modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
                instance.popperInstance = popper_createPopper(computedReference, popper, Object.assign({}, popperOptions, {
                    placement,
                    onFirstUpdate,
                    modifiers
                }));
            }
            function destroyPopperInstance() {
                if (instance.popperInstance) {
                    instance.popperInstance.destroy();
                    instance.popperInstance = null;
                }
            }
            function mount() {
                var appendTo = instance.props.appendTo;
                var parentNode;
                var node = getCurrentTarget();
                if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") parentNode = node.parentNode; else parentNode = invokeWithArgsOrReturn(appendTo, [ node ]);
                if (!parentNode.contains(popper)) parentNode.appendChild(popper);
                instance.state.isMounted = true;
                createPopperInstance();
                if (false) ;
            }
            function getNestedPopperTree() {
                return arrayFrom(popper.querySelectorAll("[data-tippy-root]"));
            }
            function scheduleShow(event) {
                instance.clearDelayTimeouts();
                if (event) invokeHook("onTrigger", [ instance, event ]);
                addDocumentPress();
                var delay = getDelay(true);
                var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
                if (currentInput.isTouch && touchValue === "hold" && touchDelay) delay = touchDelay;
                if (delay) showTimeout = setTimeout((function() {
                    instance.show();
                }), delay); else instance.show();
            }
            function scheduleHide(event) {
                instance.clearDelayTimeouts();
                invokeHook("onUntrigger", [ instance, event ]);
                if (!instance.state.isVisible) {
                    removeDocumentPress();
                    return;
                }
                if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && [ "mouseleave", "mousemove" ].indexOf(event.type) >= 0 && isVisibleFromClick) return;
                var delay = getDelay(false);
                if (delay) hideTimeout = setTimeout((function() {
                    if (instance.state.isVisible) instance.hide();
                }), delay); else scheduleHideAnimationFrame = requestAnimationFrame((function() {
                    instance.hide();
                }));
            }
            function enable() {
                instance.state.isEnabled = true;
            }
            function disable() {
                instance.hide();
                instance.state.isEnabled = false;
            }
            function clearDelayTimeouts() {
                clearTimeout(showTimeout);
                clearTimeout(hideTimeout);
                cancelAnimationFrame(scheduleHideAnimationFrame);
            }
            function setProps(partialProps) {
                if (false) ;
                if (instance.state.isDestroyed) return;
                invokeHook("onBeforeUpdate", [ instance, partialProps ]);
                removeListeners();
                var prevProps = instance.props;
                var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
                    ignoreAttributes: true
                }));
                instance.props = nextProps;
                addListeners();
                if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
                    cleanupInteractiveMouseListeners();
                    debouncedOnMouseMove = tippy_esm_debounce(onMouseMove, nextProps.interactiveDebounce);
                }
                if (prevProps.triggerTarget && !nextProps.triggerTarget) normalizeToArray(prevProps.triggerTarget).forEach((function(node) {
                    node.removeAttribute("aria-expanded");
                })); else if (nextProps.triggerTarget) reference.removeAttribute("aria-expanded");
                handleAriaExpandedAttribute();
                handleStyles();
                if (onUpdate) onUpdate(prevProps, nextProps);
                if (instance.popperInstance) {
                    createPopperInstance();
                    getNestedPopperTree().forEach((function(nestedPopper) {
                        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
                    }));
                }
                invokeHook("onAfterUpdate", [ instance, partialProps ]);
            }
            function setContent(content) {
                instance.setProps({
                    content
                });
            }
            function show() {
                if (false) ;
                var isAlreadyVisible = instance.state.isVisible;
                var isDestroyed = instance.state.isDestroyed;
                var isDisabled = !instance.state.isEnabled;
                var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
                var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
                if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) return;
                if (getCurrentTarget().hasAttribute("disabled")) return;
                invokeHook("onShow", [ instance ], false);
                if (instance.props.onShow(instance) === false) return;
                instance.state.isVisible = true;
                if (getIsDefaultRenderFn()) popper.style.visibility = "visible";
                handleStyles();
                addDocumentPress();
                if (!instance.state.isMounted) popper.style.transition = "none";
                if (getIsDefaultRenderFn()) {
                    var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
                    setTransitionDuration([ box, content ], 0);
                }
                onFirstUpdate = function onFirstUpdate() {
                    var _instance$popperInsta2;
                    if (!instance.state.isVisible || ignoreOnFirstUpdate) return;
                    ignoreOnFirstUpdate = true;
                    void popper.offsetHeight;
                    popper.style.transition = instance.props.moveTransition;
                    if (getIsDefaultRenderFn() && instance.props.animation) {
                        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
                        setTransitionDuration([ _box, _content ], duration);
                        setVisibilityState([ _box, _content ], "visible");
                    }
                    handleAriaContentAttribute();
                    handleAriaExpandedAttribute();
                    pushIfUnique(mountedInstances, instance);
                    (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
                    invokeHook("onMount", [ instance ]);
                    if (instance.props.animation && getIsDefaultRenderFn()) onTransitionedIn(duration, (function() {
                        instance.state.isShown = true;
                        invokeHook("onShown", [ instance ]);
                    }));
                };
                mount();
            }
            function hide() {
                if (false) ;
                var isAlreadyHidden = !instance.state.isVisible;
                var isDestroyed = instance.state.isDestroyed;
                var isDisabled = !instance.state.isEnabled;
                var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
                if (isAlreadyHidden || isDestroyed || isDisabled) return;
                invokeHook("onHide", [ instance ], false);
                if (instance.props.onHide(instance) === false) return;
                instance.state.isVisible = false;
                instance.state.isShown = false;
                ignoreOnFirstUpdate = false;
                isVisibleFromClick = false;
                if (getIsDefaultRenderFn()) popper.style.visibility = "hidden";
                cleanupInteractiveMouseListeners();
                removeDocumentPress();
                handleStyles(true);
                if (getIsDefaultRenderFn()) {
                    var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
                    if (instance.props.animation) {
                        setTransitionDuration([ box, content ], duration);
                        setVisibilityState([ box, content ], "hidden");
                    }
                }
                handleAriaContentAttribute();
                handleAriaExpandedAttribute();
                if (instance.props.animation) {
                    if (getIsDefaultRenderFn()) onTransitionedOut(duration, instance.unmount);
                } else instance.unmount();
            }
            function hideWithInteractivity(event) {
                if (false) ;
                getDocument().addEventListener("mousemove", debouncedOnMouseMove);
                pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
                debouncedOnMouseMove(event);
            }
            function unmount() {
                if (false) ;
                if (instance.state.isVisible) instance.hide();
                if (!instance.state.isMounted) return;
                destroyPopperInstance();
                getNestedPopperTree().forEach((function(nestedPopper) {
                    nestedPopper._tippy.unmount();
                }));
                if (popper.parentNode) popper.parentNode.removeChild(popper);
                mountedInstances = mountedInstances.filter((function(i) {
                    return i !== instance;
                }));
                instance.state.isMounted = false;
                invokeHook("onHidden", [ instance ]);
            }
            function destroy() {
                if (false) ;
                if (instance.state.isDestroyed) return;
                instance.clearDelayTimeouts();
                instance.unmount();
                removeListeners();
                delete reference._tippy;
                instance.state.isDestroyed = true;
                invokeHook("onDestroy", [ instance ]);
            }
        }
        function tippy(targets, optionalProps) {
            if (optionalProps === void 0) optionalProps = {};
            var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
            if (false) ;
            bindGlobalEventListeners();
            var passedProps = Object.assign({}, optionalProps, {
                plugins
            });
            var elements = getArrayOfElements(targets);
            if (false) ;
            var instances = elements.reduce((function(acc, reference) {
                var instance = reference && createTippy(reference, passedProps);
                if (instance) acc.push(instance);
                return acc;
            }), []);
            return tippy_esm_isElement(targets) ? instances[0] : instances;
        }
        tippy.defaultProps = defaultProps;
        tippy.setDefaultProps = setDefaultProps;
        tippy.currentInput = currentInput;
        Object.assign({}, modifiers_applyStyles, {
            effect: function effect(_ref) {
                var state = _ref.state;
                var initialStyles = {
                    popper: {
                        position: state.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
                Object.assign(state.elements.popper.style, initialStyles.popper);
                state.styles = initialStyles;
                if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
            }
        });
        tippy.setDefaultProps({
            render
        });
        const tippy_esm = tippy;
        modules_flsModules.tippy = tippy_esm("[data-tippy-content-nab]", {
            arrow: true,
            placement: "right",
            allowHTML: true,
            content: '<div class="tippy__wrapper"><div class="tippy__top"><div class="tippy__title">подсказка</div><div class="tippy__close"></div><div class="tippy__content">Набор - это совокупность нескольких товаров одного и того же аромата, упакованных в подарочную коробку. Как правило, производители объединяют в набор парфюмерию и различного рода средства для ухода за телом (гели, лосьоны, дезодоранты, прочие). Считается, что одновременное использование нескольких средств позволяет добиться более стойкого аромата после их применения</div></div></div>'
        });
        modules_flsModules.tippy = tippy_esm("[data-tippy-content-testers]", {
            arrow: true,
            placement: "right",
            allowHTML: true,
            content: '<div class="tippy__wrapper"><div class="tippy__top"><div class="tippy__title">подсказка</div><div class="tippy__close"></div><div class="tippy__content">Тестер - это демонстрационный образец, отличительной особенностью которого является упрощенная упаковка или ее отсутствие. С точки зрения содержимого флакона отличий от товара в обычной упаковке нет. С пометкой «тестер» также может продаваться товар, упаковка которого не соответствует подарочному виду (например, подмятый уголок коробки, надорванный или потертый целлофан). Флакон тестера иногда может не иметь дизайнерской крышки.</div></div></div>'
        });
        modules_flsModules.tippy = tippy_esm("[data-tippy-content-miniature]", {
            arrow: true,
            placement: "right",
            allowHTML: true,
            content: '<div class="tippy__wrapper"><div class="tippy__top"><div class="tippy__title">подсказка</div><div class="tippy__close"></div><div class="tippy__content">Миниатюра - это минимальный объем представленного товара(до 10 мл), который позволит Вам познакомится с ароматом перед покупкой флакона большого объема.В силу своего небольшого размера подобная форма выпуска аромата зачастую позволяет покупателям иметь с собой сразу несколько ароматов для повседневного использования."</div></div></div>'
        });
        modules_flsModules.tippy = tippy_esm("[data-tippy-content-otliv]", {
            arrow: true,
            placement: "right",
            allowHTML: true,
            content: '<div class="tippy__wrapper"><div class="tippy__top"><div class="tippy__title">подсказка</div><div class="tippy__close"></div><div class="tippy__content">Отливантом называют аромат, часть которого перелили из флакона в емкость со спреем. Такой метод называют «распив парфюмерии». Емкость для отливанта называется атомайзер. Обычно он вмещает объем от 5 до 30 мл, но купить можно даже меньше: от 2 мл."</div></div></div>'
        });
        modules_flsModules.tippy = tippy_esm("[data-tippy-content-birthday]", {
            arrow: true,
            placement: "bottom",
            allowHTML: true,
            content: '<div class="tippy__wrapper"><div class="tippy__top tippy__top_lk"><div class="tippy__title tippy__title_lk">Подтверждение даты рождения</div><div class="tippy__close"></div><div class="tippy__content">Загрузите скан копию документа, подтверждающего дату Вашего рождения</div></div></div>'
        });
        function isObject(obj) {
            return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target, src) {
            if (target === void 0) target = {};
            if (src === void 0) src = {};
            Object.keys(src).forEach((key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            }));
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = typeof document !== "undefined" ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if (typeof setTimeout === "undefined") {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if (typeof setTimeout === "undefined") return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = typeof window !== "undefined" ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function utils_classesToTokens(classes) {
            if (classes === void 0) classes = "";
            return classes.trim().split(" ").filter((c => !!c.trim()));
        }
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function utils_nextTick(callback, delay) {
            if (delay === void 0) delay = 0;
            return setTimeout(callback, delay);
        }
        function utils_now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis) {
            if (axis === void 0) axis = "x";
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if (axis === "y") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function utils_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
        }
        function isNode(node) {
            if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
            return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function utils_extend() {
            const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < arguments.length; i += 1) {
                const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== void 0 && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll(_ref) {
            let {swiper, targetPosition, side} = _ref;
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (startTime === null) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        function utils_elementChildren(element, selector) {
            if (selector === void 0) selector = "";
            return [ ...element.children ].filter((el => el.matches(selector)));
        }
        function showWarning(text) {
            try {
                console.warn(text);
                return;
            } catch (err) {}
        }
        function utils_createElement(tag, classes) {
            if (classes === void 0) classes = [];
            const el = document.createElement(tag);
            el.classList.add(...Array.isArray(classes) ? classes : utils_classesToTokens(classes));
            return el;
        }
        function elementPrevAll(el, selector) {
            const prevEls = [];
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (prev.matches(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return prevEls;
        }
        function elementNextAll(el, selector) {
            const nextEls = [];
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (next.matches(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return nextEls;
        }
        function elementStyle(el, prop) {
            const window = ssr_window_esm_getWindow();
            return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function utils_elementIndex(el) {
            let child = el;
            let i;
            if (child) {
                i = 0;
                while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i += 1;
                return i;
            }
            return;
        }
        function utils_elementParents(el, selector) {
            const parents = [];
            let parent = el.parentElement;
            while (parent) {
                if (selector) {
                    if (parent.matches(selector)) parents.push(parent);
                } else parents.push(parent);
                parent = parent.parentElement;
            }
            return parents;
        }
        function elementOuterSize(el, size, includeMargins) {
            const window = ssr_window_esm_getWindow();
            if (includeMargins) return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
            return el.offsetWidth;
        }
        function utils_makeElementsArray(el) {
            return (Array.isArray(el) ? el : [ el ]).filter((e => !!e));
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice(_temp) {
            let {userAgent} = _temp === void 0 ? {} : _temp;
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = platform === "Win32";
            let macos = platform === "MacIntel";
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides) {
            if (overrides === void 0) overrides = {};
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            const device = getDevice();
            let needPerspectiveFix = false;
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            if (isSafari()) {
                const ua = String(window.navigator.userAgent);
                if (ua.includes("Version/")) {
                    const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num => Number(num)));
                    needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                }
            }
            const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
            const isSafariBrowser = isSafari();
            const need3dFix = isSafariBrowser || isWebView && device.ios;
            return {
                isSafari: needPerspectiveFix || isSafariBrowser,
                needPerspectiveFix,
                need3dFix,
                isWebView
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize(_ref) {
            let {swiper, on, emit} = _ref;
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((_ref2 => {
                            let {contentBoxSize, contentRect, target} = _ref2;
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function Observer(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = function(target, options) {
                if (options === void 0) options = {};
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (swiper.__preventObserver__) return;
                    if (mutations.length === 1) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                    childList: typeof options.childList === "undefined" ? true : options.childList,
                    characterData: typeof options.characterData === "undefined" ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = utils_elementParents(swiper.hostEl);
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.hostEl, {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.wrapperEl, {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        var eventsEmitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                function onceHandler() {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if (typeof handler === "undefined") self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit() {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                if (typeof args[0] === "string" || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const el = swiper.el;
            if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
            if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
            if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
            width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
            height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if (typeof swiperSize === "undefined") return;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            swiper.virtualSize = -spaceBetween;
            slides.forEach((slideEl => {
                if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
                slideEl.style.marginBottom = "";
                slideEl.style.marginTop = "";
            }));
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slides); else if (swiper.grid) swiper.grid.unsetSlides();
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key => typeof params.breakpoints[key].slidesPerView !== "undefined")).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                let slide;
                if (slides[i]) slide = slides[i];
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slides);
                if (slides[i] && elementStyle(slide, "display") === "none") continue;
                if (params.slidesPerView === "auto") {
                    if (shouldResetSlideSize) slides[i].style[swiper.getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) slide.style.transform = "none";
                    if (currentWebKitTransform) slide.style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? elementOuterSize(slide, "width", true) : elementOuterSize(slide, "height", true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide.style.transform = currentTransform;
                    if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
            if (params.setWrapperSize) wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (isVirtual && params.loop) {
                const size = slidesSizesGrid[0] + spaceBetween;
                if (params.slidesPerGroup > 1) {
                    const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                    const groupSize = size * params.slidesPerGroup;
                    for (let i = 0; i < groups; i += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                }
                for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                    if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                    slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                    swiper.virtualSize += size;
                }
            }
            if (snapGrid.length === 0) snapGrid = [ 0 ];
            if (spaceBetween !== 0) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode || params.loop) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).forEach((slideEl => {
                    slideEl.style[key] = `${spaceBetween}px`;
                }));
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const maxSnap = allSlidesSize - swiperSize;
                snapGrid = snapGrid.map((snap => {
                    if (snap <= 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                if (allSlidesSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            swiper.emit("slidesUpdated");
            if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
                return swiper.slides[index];
            };
            if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if (typeof activeSlides[i] !== "undefined") {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
        }
        function updateSlidesProgress(translate) {
            if (translate === void 0) translate = this && this.translate || 0;
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (slides.length === 0) return;
            if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass);
            }));
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            let spaceBetween = params.spaceBetween;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides[i].classList.add(params.slideVisibleClass);
                }
                if (isFullyVisible) slides[i].classList.add(params.slideFullyVisibleClass);
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
        }
        function updateProgress(translate) {
            const swiper = this;
            if (typeof translate === "undefined") {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd, progressLoop} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (translatesDiff === 0) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                isBeginning = isBeginningRounded || progress <= 0;
                isEnd = isEndRounded || progress >= 1;
                if (isBeginningRounded) progress = 0;
                if (isEndRounded) progress = 1;
            }
            if (params.loop) {
                const firstSlideIndex = swiper.getSlideIndexByData(0);
                const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                const translateAbs = Math.abs(translate);
                if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                if (progressLoop > 1) progressLoop -= 1;
            }
            Object.assign(swiper, {
                progress,
                progressLoop,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, slidesEl, activeIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            const getFilteredSlide = selector => utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            }));
            let activeSlide;
            let prevSlide;
            let nextSlide;
            if (isVirtual) if (params.loop) {
                let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else if (gridEnabled) {
                activeSlide = slides.filter((slideEl => slideEl.column === activeIndex))[0];
                nextSlide = slides.filter((slideEl => slideEl.column === activeIndex + 1))[0];
                prevSlide = slides.filter((slideEl => slideEl.column === activeIndex - 1))[0];
            } else activeSlide = slides[activeIndex];
            if (activeSlide) {
                activeSlide.classList.add(params.slideActiveClass);
                if (gridEnabled) {
                    if (nextSlide) nextSlide.classList.add(params.slideNextClass);
                    if (prevSlide) prevSlide.classList.add(params.slidePrevClass);
                } else {
                    nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                    if (params.loop && !nextSlide) nextSlide = slides[0];
                    if (nextSlide) nextSlide.classList.add(params.slideNextClass);
                    prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                    if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
                    if (prevSlide) prevSlide.classList.add(params.slidePrevClass);
                }
            }
            swiper.emitSlidesClasses();
        }
        const processLazyPreloader = (swiper, imageEl) => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
            const slideEl = imageEl.closest(slideSelector());
            if (slideEl) {
                let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (!lazyEl && swiper.isElement) if (slideEl.shadowRoot) lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`); else requestAnimationFrame((() => {
                    if (slideEl.shadowRoot) {
                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                        if (lazyEl) lazyEl.remove();
                    }
                }));
                if (lazyEl) lazyEl.remove();
            }
        };
        const unlazy = (swiper, index) => {
            if (!swiper.slides[index]) return;
            const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
            if (imageEl) imageEl.removeAttribute("loading");
        };
        const preload = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            let amount = swiper.params.lazyPreloadPrevNext;
            const len = swiper.slides.length;
            if (!len || !amount || amount < 0) return;
            amount = Math.min(amount, len);
            const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
            const activeIndex = swiper.activeIndex;
            if (swiper.params.grid && swiper.params.grid.rows > 1) {
                const activeColumn = activeIndex;
                const preloadColumns = [ activeColumn - amount ];
                preloadColumns.push(...Array.from({
                    length: amount
                }).map(((_, i) => activeColumn + slidesPerView + i)));
                swiper.slides.forEach(((slideEl, i) => {
                    if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
                }));
                return;
            }
            const slideIndexLastInView = activeIndex + slidesPerView - 1;
            if (swiper.params.rewind || swiper.params.loop) for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                const realIndex = (i % len + len) % len;
                if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
            } else for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) unlazy(swiper, i);
        };
        function getActiveIndexByTranslate(swiper) {
            const {slidesGrid, params} = swiper;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            let activeIndex;
            for (let i = 0; i < slidesGrid.length; i += 1) if (typeof slidesGrid[i + 1] !== "undefined") {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
            } else if (translate >= slidesGrid[i]) activeIndex = i;
            if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
            return activeIndex;
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            const getVirtualRealIndex = aIndex => {
                let realIndex = aIndex - swiper.virtual.slidesBefore;
                if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;
                if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;
                return realIndex;
            };
            if (typeof activeIndex === "undefined") activeIndex = getActiveIndexByTranslate(swiper);
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex && !swiper.params.loop) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                return;
            }
            if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
                swiper.realIndex = getVirtualRealIndex(activeIndex);
                return;
            }
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            let realIndex;
            if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (gridEnabled) {
                const firstSlideInColumn = swiper.slides.filter((slideEl => slideEl.column === activeIndex))[0];
                let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
                if (Number.isNaN(activeSlideIndex)) activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
                realIndex = Math.floor(activeSlideIndex / params.grid.rows);
            } else if (swiper.slides[activeIndex]) {
                const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
                if (slideIndex) realIndex = parseInt(slideIndex, 10); else realIndex = activeIndex;
            } else realIndex = activeIndex;
            Object.assign(swiper, {
                previousSnapIndex,
                snapIndex,
                previousRealIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            if (swiper.initialized) preload(swiper);
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) {
                if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
                swiper.emit("slideChange");
            }
        }
        function updateClickedSlide(el, path) {
            const swiper = this;
            const params = swiper.params;
            let slide = el.closest(`.${params.slideClass}, swiper-slide`);
            if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) [ ...path.slice(path.indexOf(el) + 1, path.length) ].forEach((pathEl => {
                if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) slide = pathEl;
            }));
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        var update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis) {
            if (axis === void 0) axis = this.isHorizontal() ? "x" : "y";
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate(wrapperEl, axis);
            currentTranslate += swiper.cssOverflowAdjustment();
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) {
                if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment(); else y -= swiper.cssOverflowAdjustment();
                wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            }
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
            if (translate === void 0) translate = 0;
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            if (translateBounds === void 0) translateBounds = true;
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (speed === 0) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        var translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) {
                swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
                swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
            }
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit(_ref) {
            let {swiper, runCallbacks, direction, step} = _ref;
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === "reset") {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        var transition = {
            setTransition,
            transitionStart,
            transitionEnd
        };
        function slideTo(index, speed, runCallbacks, internal, initial) {
            if (index === void 0) index = 0;
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") index = parseInt(index, 10);
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial || swiper.destroyed) return false;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if (params.effect !== "slide") swiper.setTranslate(translate);
                if (direction !== "reset") {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (speed === 0) {
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                        swiper._cssModeVirtualInitialSet = true;
                        requestAnimationFrame((() => {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        }));
                    } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._immediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index, speed, runCallbacks, internal) {
            if (index === void 0) index = 0;
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") {
                const indexAsNumber = parseInt(index, 10);
                index = indexAsNumber;
            }
            const swiper = this;
            if (swiper.destroyed) return;
            const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
            let newIndex = index;
            if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else {
                let targetSlideIndex;
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    targetSlideIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
                } else targetSlideIndex = swiper.getSlideIndexByData(newIndex);
                const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
                const {centeredSlides} = swiper.params;
                let slidesPerView = swiper.params.slidesPerView;
                if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                    slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                    if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
                }
                let needLoopFix = cols - targetSlideIndex < slidesPerView;
                if (centeredSlides) needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
                if (needLoopFix) {
                    const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
                    swiper.loopFix({
                        direction,
                        slideTo: true,
                        activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                        slideRealIndex: direction === "next" ? swiper.realIndex : void 0
                    });
                }
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    newIndex = swiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex))[0].column;
                } else newIndex = swiper.getSlideIndexByData(newIndex);
            }
            requestAnimationFrame((() => {
                swiper.slideTo(newIndex, speed, runCallbacks, internal);
            }));
            return swiper;
        }
        function slideNext(speed, runCallbacks, internal) {
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {enabled, params, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "next"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
                if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
                    requestAnimationFrame((() => {
                        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
                    }));
                    return true;
                }
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed, runCallbacks, internal) {
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params, snapGrid, slidesGrid, rtlTranslate, enabled, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "prev"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if (typeof prevSnap === "undefined" && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if (typeof prevSnapIndex !== "undefined") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if (typeof prevSnap !== "undefined") {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
                requestAnimationFrame((() => {
                    swiper.slideTo(prevIndex, speed, runCallbacks, internal);
                }));
                return true;
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed, runCallbacks, internal) {
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            if (swiper.destroyed) return;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed, runCallbacks, internal, threshold) {
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            if (threshold === void 0) threshold = .5;
            const swiper = this;
            if (swiper.destroyed) return;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            if (swiper.destroyed) return;
            const {params, slidesEl} = swiper;
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        var slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate(slideRealIndex) {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            const initSlides = () => {
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                slides.forEach(((el, index) => {
                    el.setAttribute("data-swiper-slide-index", index);
                }));
            };
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
            const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
            const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
            const addBlankSlides = amountOfSlides => {
                for (let i = 0; i < amountOfSlides; i += 1) {
                    const slideEl = swiper.isElement ? utils_createElement("swiper-slide", [ params.slideBlankClass ]) : utils_createElement("div", [ params.slideClass, params.slideBlankClass ]);
                    swiper.slidesEl.append(slideEl);
                }
            };
            if (shouldFillGroup) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else if (shouldFillGrid) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else initSlides();
            swiper.loopFix({
                slideRealIndex,
                direction: params.centeredSlides ? void 0 : "next"
            });
        }
        function loopFix(_temp) {
            let {slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel} = _temp === void 0 ? {} : _temp;
            const swiper = this;
            if (!swiper.params.loop) return;
            swiper.emit("beforeLoopFix");
            const {slides, allowSlidePrev, allowSlideNext, slidesEl, params} = swiper;
            const {centeredSlides} = params;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            if (swiper.virtual && params.virtual.enabled) {
                if (slideTo) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                swiper.emit("loopFix");
                return;
            }
            let slidesPerView = params.slidesPerView;
            if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
                if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
            }
            const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
            let loopedSlides = slidesPerGroup;
            if (loopedSlides % slidesPerGroup !== 0) loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
            loopedSlides += params.loopAdditionalSlides;
            swiper.loopedSlides = loopedSlides;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            if (slides.length < slidesPerView + loopedSlides) showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"); else if (gridEnabled && params.grid.fill === "row") showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
            const prependSlidesIndexes = [];
            const appendSlidesIndexes = [];
            let activeIndex = swiper.activeIndex;
            if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(slides.filter((el => el.classList.contains(params.slideActiveClass)))[0]); else activeIndex = activeSlideIndex;
            const isNext = direction === "next" || !direction;
            const isPrev = direction === "prev" || !direction;
            let slidesPrepended = 0;
            let slidesAppended = 0;
            const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
            const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
            const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === "undefined" ? -slidesPerView / 2 + .5 : 0);
            if (activeColIndexWithShift < loopedSlides) {
                slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
                for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) {
                        const colIndexToPrepend = cols - index - 1;
                        for (let i = slides.length - 1; i >= 0; i -= 1) if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
                    } else prependSlidesIndexes.push(cols - index - 1);
                }
            } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
                slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
                for (let i = 0; i < slidesAppended; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) slides.forEach(((slide, slideIndex) => {
                        if (slide.column === index) appendSlidesIndexes.push(slideIndex);
                    })); else appendSlidesIndexes.push(index);
                }
            }
            swiper.__preventObserver__ = true;
            requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
            if (isPrev) prependSlidesIndexes.forEach((index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.prepend(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            }));
            if (isNext) appendSlidesIndexes.forEach((index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.append(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            }));
            swiper.recalcSlides();
            if (params.slidesPerView === "auto") swiper.updateSlides(); else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) swiper.slides.forEach(((slide, slideIndex) => {
                swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
            }));
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (slideTo) if (prependSlidesIndexes.length > 0 && isPrev) {
                if (typeof slideRealIndex === "undefined") {
                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                    const diff = newSlideTranslate - currentSlideTranslate;
                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
                        if (setTranslate) {
                            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                        }
                    }
                } else if (setTranslate) {
                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                    swiper.touchEventsData.currentTranslate = swiper.translate;
                }
            } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.controller && swiper.controller.control && !byController) {
                const loopParams = {
                    slideRealIndex,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController: true
                };
                if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c => {
                    if (!c.destroyed && c.params.loop) c.loopFix({
                        ...loopParams,
                        slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                    });
                })); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix({
                    ...loopParams,
                    slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
                });
            }
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            swiper.recalcSlides();
            const newSlidesOrder = [];
            swiper.slides.forEach((slideEl => {
                const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
                newSlidesOrder[index] = slideEl;
            }));
            swiper.slides.forEach((slideEl => {
                slideEl.removeAttribute("data-swiper-slide-index");
            }));
            newSlidesOrder.forEach((slideEl => {
                slidesEl.append(slideEl);
            }));
            swiper.recalcSlides();
            swiper.slideTo(swiper.realIndex, 0);
        }
        var loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        var grabCursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base) {
            if (base === void 0) base = this;
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function preventEdgeSwipe(swiper, event, startX) {
            const window = ssr_window_esm_getWindow();
            const {params} = swiper;
            const edgeSwipeDetection = params.edgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
                if (edgeSwipeDetection === "prevent") {
                    event.preventDefault();
                    return true;
                }
                return false;
            }
            return true;
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            const data = swiper.touchEventsData;
            if (e.type === "pointerdown") {
                if (data.pointerId !== null && data.pointerId !== e.pointerId) return;
                data.pointerId = e.pointerId;
            } else if (e.type === "touchstart" && e.targetTouches.length === 1) data.touchId = e.targetTouches[0].identifier;
            if (e.type === "touchstart") {
                preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
                return;
            }
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let targetEl = e.target;
            if (params.touchEventsTarget === "wrapper") if (!swiper.wrapperEl.contains(targetEl)) return;
            if ("which" in e && e.which === 3) return;
            if ("button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
            const eventPath = e.composedPath ? e.composedPath() : e.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
            touches.currentX = e.pageX;
            touches.currentY = e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            if (!preventEdgeSwipe(swiper, e, startX)) return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = utils_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(data.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === "SELECT") data.isTouched = false;
            }
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (e.type === "pointermove") {
                if (data.touchId !== null) return;
                const id = e.pointerId;
                if (id !== data.pointerId) return;
            }
            let targetTouch;
            if (e.type === "touchmove") {
                targetTouch = [ ...e.changedTouches ].filter((t => t.identifier === data.touchId))[0];
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            } else targetTouch = e;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = utils_now();
                }
                return;
            }
            if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (document.activeElement) if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            touches.previousX = touches.currentX;
            touches.previousY = touches.currentY;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if (typeof data.isScrolling === "undefined") {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            let diff = swiper.isHorizontal() ? diffX : diffY;
            let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
            if (params.oneWayMovement) {
                diff = Math.abs(diff) * (rtl ? 1 : -1);
                touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
            }
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) {
                diff = -diff;
                touchesDiff = -touchesDiff;
            }
            const prevTouchesDirection = swiper.touchesDirection;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
            const isLoop = swiper.params.loop && !params.cssMode;
            const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
            if (!data.isMoved) {
                if (isLoop && allowLoopFix) swiper.loopFix({
                    direction: swiper.swipeDirection
                });
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) {
                    const evt = new window.CustomEvent("transitionend", {
                        bubbles: true,
                        cancelable: true
                    });
                    swiper.wrapperEl.dispatchEvent(evt);
                }
                data.allowMomentumBounce = false;
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            let loopFixed;
            (new Date).getTime();
            if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
                Object.assign(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY,
                    startTranslate: data.currentTranslate
                });
                data.loopSwapReset = true;
                data.startTranslate = data.currentTranslate;
                return;
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) swiper.loopFix({
                    direction: "prev",
                    setTranslate: true,
                    activeSlideIndex: 0
                });
                if (data.currentTranslate > swiper.minTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                }
            } else if (diff < 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) swiper.loopFix({
                    direction: "next",
                    setTranslate: true,
                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                });
                if (data.currentTranslate < swiper.maxTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                }
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let targetTouch;
            const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
            if (!isTouchEvent) {
                if (data.touchId !== null) return;
                if (e.pointerId !== data.pointerId) return;
                targetTouch = e;
            } else {
                targetTouch = [ ...e.changedTouches ].filter((t => t.identifier === data.touchId))[0];
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            }
            if ([ "pointercancel", "pointerout", "pointerleave", "contextmenu" ].includes(e.type)) {
                const proceed = [ "pointercancel", "contextmenu" ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) return;
            }
            data.pointerId = null;
            data.touchId = null;
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
            const touchEndTime = utils_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = utils_now();
            utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== "undefined") {
                    if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (swipeToLast || currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && el.offsetWidth === 0) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            const isVirtualLoop = isVirtual && params.loop;
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                clearTimeout(swiper.autoplay.resizeTimeout);
                swiper.autoplay.resizeTimeout = setTimeout((() => {
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
                }), 500);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (swiper.translate === 0) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        function onLoad(e) {
            const swiper = this;
            processLazyPreloader(swiper, e.target);
            if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
            swiper.update();
        }
        function swiper_core_onDocumentTouchStart() {
            const swiper = this;
            if (swiper.documentTouchHandlerProceeded) return;
            swiper.documentTouchHandlerProceeded = true;
            if (swiper.params.touchReleaseOnEdges) swiper.el.style.touchAction = "auto";
        }
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, el, wrapperEl, device} = swiper;
            const capture = !!params.nested;
            const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            document[domMethod]("touchstart", swiper.onDocumentTouchStart, {
                passive: false,
                capture
            });
            el[domMethod]("touchstart", swiper.onTouchStart, {
                passive: false
            });
            el[domMethod]("pointerdown", swiper.onTouchStart, {
                passive: false
            });
            document[domMethod]("touchmove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("pointermove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("touchend", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerup", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointercancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("touchcancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerout", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerleave", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("contextmenu", swiper.onTouchEnd, {
                passive: true
            });
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
            el[domMethod]("load", swiper.onLoad, {
                capture: true
            });
        };
        function attachEvents() {
            const swiper = this;
            const {params} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            swiper.onDocumentTouchStart = swiper_core_onDocumentTouchStart.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            swiper.onLoad = onLoad.bind(swiper);
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        var events$1 = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {realIndex, initialized, params, el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                el.classList.add(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
                if (typeof breakpointParams[prop] === "undefined") return;
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            }));
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            const wasLoop = params.loop;
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            const hasLoop = swiper.params.loop;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (initialized) if (needsReLoop) {
                swiper.loopDestroy();
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (!wasLoop && hasLoop) {
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (wasLoop && !hasLoop) swiper.loopDestroy();
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base, containerEl) {
            if (base === void 0) base = "window";
            if (!breakpoints || base === "container" && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if (typeof point === "string" && point.indexOf("@") === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if (base === "window") {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        var breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if (typeof item === "object") Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if (typeof item === "string") resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, el, device} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            el.classList.add(...classNames);
            swiper.emitContainerClasses();
        }
        function swiper_core_removeClasses() {
            const swiper = this;
            const {el, classNames} = swiper;
            el.classList.remove(...classNames);
            swiper.emitContainerClasses();
        }
        var classes = {
            addClasses,
            removeClasses: swiper_core_removeClasses
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = swiper.snapGrid.length === 1;
            if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
            if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        var checkOverflow$1 = {
            checkOverflow
        };
        var defaults = {
            init: true,
            direction: "horizontal",
            oneWayMovement: false,
            swiperElementNodeName: "SWIPER-CONTAINER",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            eventsPrefix: "swiper",
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 5,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loop: false,
            loopAddBlankSlides: true,
            loopAdditionalSlides: 0,
            loopPreventsSliding: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-blank",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideFullyVisibleClass: "swiper-slide-fully-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj) {
                if (obj === void 0) obj = {};
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (params[moduleParamName] === true) params[moduleParamName] = {
                    enabled: true
                };
                if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) params[moduleParamName].auto = true;
                if ([ "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) params[moduleParamName].auto = true;
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter,
            update,
            translate,
            transition,
            slide,
            loop,
            grabCursor,
            events: events$1,
            breakpoints,
            checkOverflow: checkOverflow$1,
            classes
        };
        const extendedDefaults = {};
        class swiper_core_Swiper {
            constructor() {
                let el;
                let params;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                const document = ssr_window_esm_getDocument();
                if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
                    const swipers = [];
                    document.querySelectorAll(params.el).forEach((containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new swiper_core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        params,
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return swiper.params.direction === "horizontal";
                    },
                    isVertical() {
                        return swiper.params.direction === "vertical";
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                    },
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        pointerId: null,
                        touchId: null
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            getDirectionLabel(property) {
                if (this.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            getSlideIndex(slideEl) {
                const {slidesEl, params} = this;
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                const firstSlideIndex = utils_elementIndex(slides[0]);
                return utils_elementIndex(slideEl) - firstSlideIndex;
            }
            getSlideIndexByData(index) {
                return this.getSlideIndex(this.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index))[0]);
            }
            recalcSlides() {
                const swiper = this;
                const {slidesEl, params} = swiper;
                swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter((className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0)).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.forEach((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view, exact) {
                if (view === void 0) view = "current";
                if (exact === void 0) exact = false;
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (typeof params.slidesPerView === "number") return params.slidesPerView;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += Math.ceil(slides[i].swiperSlideSize);
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if (view === "current") for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl);
                }));
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
                    setTranslate();
                    if (params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                        translated = swiper.slideTo(slides.length - 1, 0, false, true);
                    } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate) {
                if (needUpdate === void 0) needUpdate = true;
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
                if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
                swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.forEach((slideEl => {
                    if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
                swiper.rtl = direction === "rtl";
                swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
                if (swiper.rtl) {
                    swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(element) {
                const swiper = this;
                if (swiper.mounted) return true;
                let el = element || swiper.params.el;
                if (typeof el === "string") el = document.querySelector(el);
                if (!el) return false;
                el.swiper = swiper;
                if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) swiper.isElement = true;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = el.shadowRoot.querySelector(getWrapperSelector());
                        return res;
                    }
                    return utils_elementChildren(el, getWrapperSelector())[0];
                };
                let wrapperEl = getWrapper();
                if (!wrapperEl && swiper.params.createElements) {
                    wrapperEl = utils_createElement("div", swiper.params.wrapperClass);
                    el.append(wrapperEl);
                    utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl => {
                        wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    el,
                    wrapperEl,
                    slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
                    hostEl: swiper.isElement ? el.parentNode.host : el,
                    mounted: true,
                    rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
                    rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
                    wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (mounted === false) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                if (swiper.params.loop) swiper.loopCreate();
                swiper.attachEvents();
                const lazyElements = [ ...swiper.el.querySelectorAll('[loading="lazy"]') ];
                if (swiper.isElement) lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
                lazyElements.forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", (e => {
                        processLazyPreloader(swiper, e.target);
                    }));
                }));
                preload(swiper);
                swiper.initialized = true;
                preload(swiper);
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance, cleanStyles) {
                if (deleteInstance === void 0) deleteInstance = true;
                if (cleanStyles === void 0) cleanStyles = true;
                const swiper = this;
                const {params, el, wrapperEl, slides} = swiper;
                if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    el.removeAttribute("style");
                    wrapperEl.removeAttribute("style");
                    if (slides && slides.length) slides.forEach((slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                        slideEl.removeAttribute("style");
                        slideEl.removeAttribute("data-swiper-slide-index");
                    }));
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (deleteInstance !== false) {
                    swiper.el.swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!swiper_core_Swiper.prototype.__modules__) swiper_core_Swiper.prototype.__modules__ = [];
                const modules = swiper_core_Swiper.prototype.__modules__;
                if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => swiper_core_Swiper.installModule(m)));
                    return swiper_core_Swiper;
                }
                swiper_core_Swiper.installModule(module);
                return swiper_core_Swiper;
            }
        }
        Object.keys(prototypes).forEach((prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
                swiper_core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }));
        }));
        swiper_core_Swiper.use([ Resize, Observer ]);
        function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
                if (!params[key] && params.auto === true) {
                    let element = utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                    if (!element) {
                        element = utils_createElement("div", checkProps[key]);
                        element.className = checkProps[key];
                        swiper.el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            }));
            return params;
        }
        function Navigation(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            extendParams({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: false,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            });
            swiper.navigation = {
                nextEl: null,
                prevEl: null
            };
            function getEl(el) {
                let res;
                if (el && typeof el === "string" && swiper.isElement) {
                    res = swiper.el.querySelector(el);
                    if (res) return res;
                }
                if (el) {
                    if (typeof el === "string") res = [ ...document.querySelectorAll(el) ];
                    if (swiper.params.uniqueNavElements && typeof el === "string" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el);
                }
                if (el && !res) return el;
                return res;
            }
            function toggleEl(el, disabled) {
                const params = swiper.params.navigation;
                el = utils_makeElementsArray(el);
                el.forEach((subEl => {
                    if (subEl) {
                        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                        if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                    }
                }));
            }
            function update() {
                const {nextEl, prevEl} = swiper.navigation;
                if (swiper.params.loop) {
                    toggleEl(prevEl, false);
                    toggleEl(nextEl, false);
                    return;
                }
                toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
                toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
            }
            function onPrevClick(e) {
                e.preventDefault();
                if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slidePrev();
                emit("navigationPrev");
            }
            function onNextClick(e) {
                e.preventDefault();
                if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slideNext();
                emit("navigationNext");
            }
            function init() {
                const params = swiper.params.navigation;
                swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                });
                if (!(params.nextEl || params.prevEl)) return;
                let nextEl = getEl(params.nextEl);
                let prevEl = getEl(params.prevEl);
                Object.assign(swiper.navigation, {
                    nextEl,
                    prevEl
                });
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                const initButton = (el, dir) => {
                    if (el) el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(" "));
                };
                nextEl.forEach((el => initButton(el, "next")));
                prevEl.forEach((el => initButton(el, "prev")));
            }
            function destroy() {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                const destroyButton = (el, dir) => {
                    el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
                };
                nextEl.forEach((el => destroyButton(el, "next")));
                prevEl.forEach((el => destroyButton(el, "prev")));
            }
            on("init", (() => {
                if (swiper.params.navigation.enabled === false) disable(); else {
                    init();
                    update();
                }
            }));
            on("toEdge fromEdge lock unlock", (() => {
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                if (swiper.enabled) {
                    update();
                    return;
                }
                [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.add(swiper.params.navigation.lockClass)));
            }));
            on("click", ((_s, e) => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = utils_makeElementsArray(nextEl);
                prevEl = utils_makeElementsArray(prevEl);
                const targetEl = e.target;
                if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
                    if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                    let isHidden;
                    if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass); else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
                    if (isHidden === true) emit("navigationShow"); else emit("navigationHide");
                    [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.toggle(swiper.params.navigation.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
                init();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
                destroy();
            };
            Object.assign(swiper.navigation, {
                enable,
                disable,
                update,
                init,
                destroy
            });
        }
        function classes_to_selector_classesToSelector(classes) {
            if (classes === void 0) classes = "";
            return `.${classes.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
        }
        function Pagination(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const pfx = "swiper-pagination";
            extendParams({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: false,
                    hideOnClick: false,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: false,
                    type: "bullets",
                    dynamicBullets: false,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: number => number,
                    formatFractionTotal: number => number,
                    bulletClass: `${pfx}-bullet`,
                    bulletActiveClass: `${pfx}-bullet-active`,
                    modifierClass: `${pfx}-`,
                    currentClass: `${pfx}-current`,
                    totalClass: `${pfx}-total`,
                    hiddenClass: `${pfx}-hidden`,
                    progressbarFillClass: `${pfx}-progressbar-fill`,
                    progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                    clickableClass: `${pfx}-clickable`,
                    lockClass: `${pfx}-lock`,
                    horizontalClass: `${pfx}-horizontal`,
                    verticalClass: `${pfx}-vertical`,
                    paginationDisabledClass: `${pfx}-disabled`
                }
            });
            swiper.pagination = {
                el: null,
                bullets: []
            };
            let bulletSize;
            let dynamicBulletIndex = 0;
            function isPaginationDisabled() {
                return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
            }
            function setSideBullets(bulletEl, position) {
                const {bulletActiveClass} = swiper.params.pagination;
                if (!bulletEl) return;
                bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                if (bulletEl) {
                    bulletEl.classList.add(`${bulletActiveClass}-${position}`);
                    bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                    if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
                }
            }
            function onBulletClick(e) {
                const bulletEl = e.target.closest(classes_to_selector_classesToSelector(swiper.params.pagination.bulletClass));
                if (!bulletEl) return;
                e.preventDefault();
                const index = utils_elementIndex(bulletEl) * swiper.params.slidesPerGroup;
                if (swiper.params.loop) {
                    if (swiper.realIndex === index) return;
                    swiper.slideToLoop(index);
                } else swiper.slideTo(index);
            }
            function update() {
                const rtl = swiper.rtl;
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                el = utils_makeElementsArray(el);
                let current;
                let previousIndex;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.loop) {
                    previousIndex = swiper.previousRealIndex || 0;
                    current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
                } else if (typeof swiper.snapIndex !== "undefined") {
                    current = swiper.snapIndex;
                    previousIndex = swiper.previousSnapIndex;
                } else {
                    previousIndex = swiper.previousIndex || 0;
                    current = swiper.activeIndex || 0;
                }
                if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                    const bullets = swiper.pagination.bullets;
                    let firstIndex;
                    let lastIndex;
                    let midIndex;
                    if (params.dynamicBullets) {
                        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
                        el.forEach((subEl => {
                            subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                        }));
                        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
                            dynamicBulletIndex += current - (previousIndex || 0);
                            if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
                        }
                        firstIndex = Math.max(current - dynamicBulletIndex, 0);
                        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                        midIndex = (lastIndex + firstIndex) / 2;
                    }
                    bullets.forEach((bulletEl => {
                        const classesToRemove = [ ...[ "", "-next", "-next-next", "-prev", "-prev-prev", "-main" ].map((suffix => `${params.bulletActiveClass}${suffix}`)) ].map((s => typeof s === "string" && s.includes(" ") ? s.split(" ") : s)).flat();
                        bulletEl.classList.remove(...classesToRemove);
                    }));
                    if (el.length > 1) bullets.forEach((bullet => {
                        const bulletIndex = utils_elementIndex(bullet);
                        if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(" ")); else if (swiper.isElement) bullet.setAttribute("part", "bullet");
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            if (bulletIndex === firstIndex) setSideBullets(bullet, "prev");
                            if (bulletIndex === lastIndex) setSideBullets(bullet, "next");
                        }
                    })); else {
                        const bullet = bullets[current];
                        if (bullet) bullet.classList.add(...params.bulletActiveClass.split(" "));
                        if (swiper.isElement) bullets.forEach(((bulletEl, bulletIndex) => {
                            bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
                        }));
                        if (params.dynamicBullets) {
                            const firstDisplayedBullet = bullets[firstIndex];
                            const lastDisplayedBullet = bullets[lastIndex];
                            for (let i = firstIndex; i <= lastIndex; i += 1) if (bullets[i]) bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            setSideBullets(firstDisplayedBullet, "prev");
                            setSideBullets(lastDisplayedBullet, "next");
                        }
                    }
                    if (params.dynamicBullets) {
                        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                        const offsetProp = rtl ? "right" : "left";
                        bullets.forEach((bullet => {
                            bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
                        }));
                    }
                }
                el.forEach(((subEl, subElIndex) => {
                    if (params.type === "fraction") {
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.currentClass)).forEach((fractionEl => {
                            fractionEl.textContent = params.formatFractionCurrent(current + 1);
                        }));
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.totalClass)).forEach((totalEl => {
                            totalEl.textContent = params.formatFractionTotal(total);
                        }));
                    }
                    if (params.type === "progressbar") {
                        let progressbarDirection;
                        if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                        const scale = (current + 1) / total;
                        let scaleX = 1;
                        let scaleY = 1;
                        if (progressbarDirection === "horizontal") scaleX = scale; else scaleY = scale;
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.progressbarFillClass)).forEach((progressEl => {
                            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                        }));
                    }
                    if (params.type === "custom" && params.renderCustom) {
                        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
                        if (subElIndex === 0) emit("paginationRender", subEl);
                    } else {
                        if (subElIndex === 0) emit("paginationRender", subEl);
                        emit("paginationUpdate", subEl);
                    }
                    if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                }));
            }
            function render() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
                let el = swiper.pagination.el;
                el = utils_makeElementsArray(el);
                let paginationHTML = "";
                if (params.type === "bullets") {
                    let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                    if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
                    for (let i = 0; i < numberOfBullets; i += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass); else paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
                }
                if (params.type === "fraction") if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`;
                if (params.type === "progressbar") if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                swiper.pagination.bullets = [];
                el.forEach((subEl => {
                    if (params.type !== "custom") subEl.innerHTML = paginationHTML || "";
                    if (params.type === "bullets") swiper.pagination.bullets.push(...subEl.querySelectorAll(classes_to_selector_classesToSelector(params.bulletClass)));
                }));
                if (params.type !== "custom") emit("paginationRender", el[0]);
            }
            function init() {
                swiper.params.pagination = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                    el: "swiper-pagination"
                });
                const params = swiper.params.pagination;
                if (!params.el) return;
                let el;
                if (typeof params.el === "string" && swiper.isElement) el = swiper.el.querySelector(params.el);
                if (!el && typeof params.el === "string") el = [ ...document.querySelectorAll(params.el) ];
                if (!el) el = params.el;
                if (!el || el.length === 0) return;
                if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
                    el = [ ...swiper.el.querySelectorAll(params.el) ];
                    if (el.length > 1) el = el.filter((subEl => {
                        if (utils_elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
                        return true;
                    }))[0];
                }
                if (Array.isArray(el) && el.length === 1) el = el[0];
                Object.assign(swiper.pagination, {
                    el
                });
                el = utils_makeElementsArray(el);
                el.forEach((subEl => {
                    if (params.type === "bullets" && params.clickable) subEl.classList.add(...(params.clickableClass || "").split(" "));
                    subEl.classList.add(params.modifierClass + params.type);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                    if (params.type === "bullets" && params.dynamicBullets) {
                        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                        dynamicBulletIndex = 0;
                        if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
                    }
                    if (params.type === "progressbar" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);
                    if (params.clickable) subEl.addEventListener("click", onBulletClick);
                    if (!swiper.enabled) subEl.classList.add(params.lockClass);
                }));
            }
            function destroy() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => {
                        subEl.classList.remove(params.hiddenClass);
                        subEl.classList.remove(params.modifierClass + params.type);
                        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                        if (params.clickable) {
                            subEl.classList.remove(...(params.clickableClass || "").split(" "));
                            subEl.removeEventListener("click", onBulletClick);
                        }
                    }));
                }
                if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl => subEl.classList.remove(...params.bulletActiveClass.split(" "))));
            }
            on("changeDirection", (() => {
                if (!swiper.pagination || !swiper.pagination.el) return;
                const params = swiper.params.pagination;
                let {el} = swiper.pagination;
                el = utils_makeElementsArray(el);
                el.forEach((subEl => {
                    subEl.classList.remove(params.horizontalClass, params.verticalClass);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                }));
            }));
            on("init", (() => {
                if (swiper.params.pagination.enabled === false) disable(); else {
                    init();
                    render();
                    update();
                }
            }));
            on("activeIndexChange", (() => {
                if (typeof swiper.snapIndex === "undefined") update();
            }));
            on("snapIndexChange", (() => {
                update();
            }));
            on("snapGridLengthChange", (() => {
                render();
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass)));
                }
            }));
            on("lock unlock", (() => {
                update();
            }));
            on("click", ((_s, e) => {
                const targetEl = e.target;
                const el = utils_makeElementsArray(swiper.pagination.el);
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
                    if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                    const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
                    if (isHidden === true) emit("paginationShow"); else emit("paginationHide");
                    el.forEach((subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass)));
                }
                init();
                render();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach((subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass)));
                }
                destroy();
            };
            Object.assign(swiper.pagination, {
                enable,
                disable,
                render,
                update,
                init,
                destroy
            });
        }
        function Autoplay(_ref) {
            let {swiper, extendParams, on, emit, params} = _ref;
            swiper.autoplay = {
                running: false,
                paused: false,
                timeLeft: 0
            };
            extendParams({
                autoplay: {
                    enabled: false,
                    delay: 3e3,
                    waitForTransition: true,
                    disableOnInteraction: false,
                    stopOnLastSlide: false,
                    reverseDirection: false,
                    pauseOnMouseEnter: false
                }
            });
            let timeout;
            let raf;
            let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
            let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
            let autoplayTimeLeft;
            let autoplayStartTime = (new Date).getTime();
            let wasPaused;
            let isTouched;
            let pausedByTouch;
            let touchStartTimeout;
            let slideChanged;
            let pausedByInteraction;
            let pausedByPointerEnter;
            function onTransitionEnd(e) {
                if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
                if (e.target !== swiper.wrapperEl) return;
                swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
                if (pausedByPointerEnter) return;
                resume();
            }
            const calcTimeLeft = () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (swiper.autoplay.paused) wasPaused = true; else if (wasPaused) {
                    autoplayDelayCurrent = autoplayTimeLeft;
                    wasPaused = false;
                }
                const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (new Date).getTime();
                swiper.autoplay.timeLeft = timeLeft;
                emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
                raf = requestAnimationFrame((() => {
                    calcTimeLeft();
                }));
            };
            const getSlideDelay = () => {
                let activeSlideEl;
                if (swiper.virtual && swiper.params.virtual.enabled) activeSlideEl = swiper.slides.filter((slideEl => slideEl.classList.contains("swiper-slide-active")))[0]; else activeSlideEl = swiper.slides[swiper.activeIndex];
                if (!activeSlideEl) return;
                const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
                return currentSlideDelay;
            };
            const run = delayForce => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                cancelAnimationFrame(raf);
                calcTimeLeft();
                let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
                autoplayDelayTotal = swiper.params.autoplay.delay;
                autoplayDelayCurrent = swiper.params.autoplay.delay;
                const currentSlideDelay = getSlideDelay();
                if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
                    delay = currentSlideDelay;
                    autoplayDelayTotal = currentSlideDelay;
                    autoplayDelayCurrent = currentSlideDelay;
                }
                autoplayTimeLeft = delay;
                const speed = swiper.params.speed;
                const proceed = () => {
                    if (!swiper || swiper.destroyed) return;
                    if (swiper.params.autoplay.reverseDirection) {
                        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                            swiper.slidePrev(speed, true, true);
                            emit("autoplay");
                        } else if (!swiper.params.autoplay.stopOnLastSlide) {
                            swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                            emit("autoplay");
                        }
                    } else if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                        swiper.slideNext(speed, true, true);
                        emit("autoplay");
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        swiper.slideTo(0, speed, true, true);
                        emit("autoplay");
                    }
                    if (swiper.params.cssMode) {
                        autoplayStartTime = (new Date).getTime();
                        requestAnimationFrame((() => {
                            run();
                        }));
                    }
                };
                if (delay > 0) {
                    clearTimeout(timeout);
                    timeout = setTimeout((() => {
                        proceed();
                    }), delay);
                } else requestAnimationFrame((() => {
                    proceed();
                }));
                return delay;
            };
            const start = () => {
                autoplayStartTime = (new Date).getTime();
                swiper.autoplay.running = true;
                run();
                emit("autoplayStart");
            };
            const stop = () => {
                swiper.autoplay.running = false;
                clearTimeout(timeout);
                cancelAnimationFrame(raf);
                emit("autoplayStop");
            };
            const pause = (internal, reset) => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                clearTimeout(timeout);
                if (!internal) pausedByInteraction = true;
                const proceed = () => {
                    emit("autoplayPause");
                    if (swiper.params.autoplay.waitForTransition) swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd); else resume();
                };
                swiper.autoplay.paused = true;
                if (reset) {
                    if (slideChanged) autoplayTimeLeft = swiper.params.autoplay.delay;
                    slideChanged = false;
                    proceed();
                    return;
                }
                const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
                autoplayTimeLeft = delay - ((new Date).getTime() - autoplayStartTime);
                if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
                if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
                proceed();
            };
            const resume = () => {
                if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
                autoplayStartTime = (new Date).getTime();
                if (pausedByInteraction) {
                    pausedByInteraction = false;
                    run(autoplayTimeLeft);
                } else run();
                swiper.autoplay.paused = false;
                emit("autoplayResume");
            };
            const onVisibilityChange = () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                const document = ssr_window_esm_getDocument();
                if (document.visibilityState === "hidden") {
                    pausedByInteraction = true;
                    pause(true);
                }
                if (document.visibilityState === "visible") resume();
            };
            const onPointerEnter = e => {
                if (e.pointerType !== "mouse") return;
                pausedByInteraction = true;
                pausedByPointerEnter = true;
                if (swiper.animating || swiper.autoplay.paused) return;
                pause(true);
            };
            const onPointerLeave = e => {
                if (e.pointerType !== "mouse") return;
                pausedByPointerEnter = false;
                if (swiper.autoplay.paused) resume();
            };
            const attachMouseEvents = () => {
                if (swiper.params.autoplay.pauseOnMouseEnter) {
                    swiper.el.addEventListener("pointerenter", onPointerEnter);
                    swiper.el.addEventListener("pointerleave", onPointerLeave);
                }
            };
            const detachMouseEvents = () => {
                swiper.el.removeEventListener("pointerenter", onPointerEnter);
                swiper.el.removeEventListener("pointerleave", onPointerLeave);
            };
            const attachDocumentEvents = () => {
                const document = ssr_window_esm_getDocument();
                document.addEventListener("visibilitychange", onVisibilityChange);
            };
            const detachDocumentEvents = () => {
                const document = ssr_window_esm_getDocument();
                document.removeEventListener("visibilitychange", onVisibilityChange);
            };
            on("init", (() => {
                if (swiper.params.autoplay.enabled) {
                    attachMouseEvents();
                    attachDocumentEvents();
                    start();
                }
            }));
            on("destroy", (() => {
                detachMouseEvents();
                detachDocumentEvents();
                if (swiper.autoplay.running) stop();
            }));
            on("_freeModeStaticRelease", (() => {
                if (pausedByTouch || pausedByInteraction) resume();
            }));
            on("_freeModeNoMomentumRelease", (() => {
                if (!swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
            }));
            on("beforeTransitionStart", ((_s, speed, internal) => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (internal || !swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
            }));
            on("sliderFirstMove", (() => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (swiper.params.autoplay.disableOnInteraction) {
                    stop();
                    return;
                }
                isTouched = true;
                pausedByTouch = false;
                pausedByInteraction = false;
                touchStartTimeout = setTimeout((() => {
                    pausedByInteraction = true;
                    pausedByTouch = true;
                    pause(true);
                }), 200);
            }));
            on("touchEnd", (() => {
                if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
                clearTimeout(touchStartTimeout);
                clearTimeout(timeout);
                if (swiper.params.autoplay.disableOnInteraction) {
                    pausedByTouch = false;
                    isTouched = false;
                    return;
                }
                if (pausedByTouch && swiper.params.cssMode) resume();
                pausedByTouch = false;
                isTouched = false;
            }));
            on("slideChange", (() => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                slideChanged = true;
            }));
            Object.assign(swiper.autoplay, {
                start,
                stop,
                pause,
                resume
            });
        }
        function Thumb(_ref) {
            let {swiper, extendParams, on} = _ref;
            extendParams({
                thumbs: {
                    swiper: null,
                    multipleActiveThumbs: true,
                    autoScrollOffset: 0,
                    slideThumbActiveClass: "swiper-slide-thumb-active",
                    thumbsContainerClass: "swiper-thumbs"
                }
            });
            let initialized = false;
            let swiperCreated = false;
            swiper.thumbs = {
                swiper: null
            };
            function onThumbClick() {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                const clickedIndex = thumbsSwiper.clickedIndex;
                const clickedSlide = thumbsSwiper.clickedSlide;
                if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
                if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
                let slideToIndex;
                if (thumbsSwiper.params.loop) slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10); else slideToIndex = clickedIndex;
                if (swiper.params.loop) swiper.slideToLoop(slideToIndex); else swiper.slideTo(slideToIndex);
            }
            function init() {
                const {thumbs: thumbsParams} = swiper.params;
                if (initialized) return false;
                initialized = true;
                const SwiperClass = swiper.constructor;
                if (thumbsParams.swiper instanceof SwiperClass) {
                    swiper.thumbs.swiper = thumbsParams.swiper;
                    Object.assign(swiper.thumbs.swiper.originalParams, {
                        watchSlidesProgress: true,
                        slideToClickedSlide: false
                    });
                    Object.assign(swiper.thumbs.swiper.params, {
                        watchSlidesProgress: true,
                        slideToClickedSlide: false
                    });
                    swiper.thumbs.swiper.update();
                } else if (utils_isObject(thumbsParams.swiper)) {
                    const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                    Object.assign(thumbsSwiperParams, {
                        watchSlidesProgress: true,
                        slideToClickedSlide: false
                    });
                    swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
                    swiperCreated = true;
                }
                swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
                swiper.thumbs.swiper.on("tap", onThumbClick);
                return true;
            }
            function update(initial) {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
                let thumbsToActivate = 1;
                const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
                if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) thumbsToActivate = swiper.params.slidesPerView;
                if (!swiper.params.thumbs.multipleActiveThumbs) thumbsToActivate = 1;
                thumbsToActivate = Math.floor(thumbsToActivate);
                thumbsSwiper.slides.forEach((slideEl => slideEl.classList.remove(thumbActiveClass)));
                if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) for (let i = 0; i < thumbsToActivate; i += 1) utils_elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach((slideEl => {
                    slideEl.classList.add(thumbActiveClass);
                })); else for (let i = 0; i < thumbsToActivate; i += 1) if (thumbsSwiper.slides[swiper.realIndex + i]) thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
                const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
                const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
                if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
                    const currentThumbsIndex = thumbsSwiper.activeIndex;
                    let newThumbsIndex;
                    let direction;
                    if (thumbsSwiper.params.loop) {
                        const newThumbsSlide = thumbsSwiper.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") === `${swiper.realIndex}`))[0];
                        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                        direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
                    } else {
                        newThumbsIndex = swiper.realIndex;
                        direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
                    }
                    if (useOffset) newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
                    if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                        if (thumbsSwiper.params.centeredSlides) if (newThumbsIndex > currentThumbsIndex) newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1; else newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1; else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
                        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
                    }
                }
            }
            on("beforeInit", (() => {
                const {thumbs} = swiper.params;
                if (!thumbs || !thumbs.swiper) return;
                if (typeof thumbs.swiper === "string" || thumbs.swiper instanceof HTMLElement) {
                    const document = ssr_window_esm_getDocument();
                    const getThumbsElementAndInit = () => {
                        const thumbsElement = typeof thumbs.swiper === "string" ? document.querySelector(thumbs.swiper) : thumbs.swiper;
                        if (thumbsElement && thumbsElement.swiper) {
                            thumbs.swiper = thumbsElement.swiper;
                            init();
                            update(true);
                        } else if (thumbsElement) {
                            const onThumbsSwiper = e => {
                                thumbs.swiper = e.detail[0];
                                thumbsElement.removeEventListener("init", onThumbsSwiper);
                                init();
                                update(true);
                                thumbs.swiper.update();
                                swiper.update();
                            };
                            thumbsElement.addEventListener("init", onThumbsSwiper);
                        }
                        return thumbsElement;
                    };
                    const watchForThumbsToAppear = () => {
                        if (swiper.destroyed) return;
                        const thumbsElement = getThumbsElementAndInit();
                        if (!thumbsElement) requestAnimationFrame(watchForThumbsToAppear);
                    };
                    requestAnimationFrame(watchForThumbsToAppear);
                } else {
                    init();
                    update(true);
                }
            }));
            on("slideChange update resize observerUpdate", (() => {
                update();
            }));
            on("setTransition", ((_s, duration) => {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                thumbsSwiper.setTransition(duration);
            }));
            on("beforeDestroy", (() => {
                const thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                if (swiperCreated) thumbsSwiper.destroy();
            }));
            Object.assign(swiper.thumbs, {
                init,
                update
            });
        }
        function initSliders() {
            if (document.querySelector(".banners__slider")) new swiper_core_Swiper(".banners__slider", {
                modules: [ Pagination, Autoplay ],
                observer: true,
                observeParents: true,
                slidesPerView: 1,
                spaceBetween: 0,
                speed: 800,
                loop: true,
                autoplay: {
                    delay: 5e3
                },
                pagination: {
                    el: ".swiper-pagination",
                    clickable: true
                },
                on: {}
            });
            if (document.querySelector(".tabs__slider")) new swiper_core_Swiper(".tabs__slider", {
                modules: [ Navigation, Pagination ],
                observer: true,
                observeParents: true,
                slidesPerView: 6,
                spaceBetween: 20,
                speed: 800,
                pagination: {
                    el: ".swiper-products-pagination",
                    clickable: true
                },
                navigation: {
                    prevEl: ".swiper-tabs-prev",
                    nextEl: ".swiper-tabs-next"
                },
                breakpoints: {
                    300: {
                        slidesPerView: 1,
                        spaceBetween: 20
                    },
                    360: {
                        slidesPerView: 2,
                        spaceBetween: 20
                    },
                    768: {
                        slidesPerView: 3,
                        spaceBetween: 26
                    },
                    1001: {
                        slidesPerView: 5,
                        spaceBetween: 26
                    },
                    1680: {
                        slidesPerView: 6,
                        spaceBetween: 20
                    }
                },
                on: {}
            });
            if (document.querySelector(".video__slider")) new swiper_core_Swiper(".video__slider", {
                modules: [ Navigation, Pagination ],
                observer: true,
                observeParents: true,
                slidesPerView: 3,
                spaceBetween: 20,
                speed: 800,
                loop: false,
                pagination: {
                    el: ".swiper-video-pagination",
                    clickable: true
                },
                navigation: {
                    prevEl: ".swiper-video-prev",
                    nextEl: ".swiper-video-next"
                },
                breakpoints: {
                    300: {
                        slidesPerView: 1,
                        spaceBetween: 20
                    },
                    360: {
                        slidesPerView: 1.3,
                        spaceBetween: 17
                    },
                    1001: {
                        slidesPerView: 3,
                        spaceBetween: 20
                    }
                }
            });
            if (document.querySelector(".otlivant-article__slider")) new swiper_core_Swiper(".otlivant-article__slider", {
                modules: [ Navigation, Pagination ],
                observer: true,
                observeParents: true,
                spaceBetween: 20,
                speed: 800,
                loop: false,
                pagination: {
                    el: ".swiper-otlivant-pagination",
                    clickable: true
                },
                navigation: {
                    prevEl: ".swiper-article-prev",
                    nextEl: ".swiper-article-next"
                },
                breakpoints: {
                    300: {
                        slidesPerView: 1.17,
                        spaceBetween: 20
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 20
                    },
                    1001: {
                        slidesPerView: 4,
                        spaceBetween: 20
                    }
                }
            });
            if (document.querySelector(".device-article__slider")) new swiper_core_Swiper(".device-article__slider", {
                modules: [ Navigation, Pagination ],
                observer: true,
                observeParents: true,
                spaceBetween: 20,
                speed: 800,
                loop: false,
                pagination: {
                    el: ".swiper-device-pagination",
                    clickable: true
                },
                navigation: {
                    prevEl: ".device-article-prev",
                    nextEl: ".device-article-next"
                },
                breakpoints: {
                    300: {
                        slidesPerView: 1.17,
                        spaceBetween: 20
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 20
                    },
                    1001: {
                        slidesPerView: 2,
                        spaceBetween: 20
                    },
                    1280: {
                        slidesPerView: 3,
                        spaceBetween: 20
                    }
                }
            });
            if (document.querySelector(".otliv__slider-thumbs")) {
                const otlivThumbs = new swiper_core_Swiper(".otliv__slider-thumbs", {
                    modules: [ Thumb ],
                    observer: true,
                    observeParents: true,
                    speed: 400,
                    spaceBetween: 20,
                    slidesPerView: 3,
                    direction: "vertical"
                });
                new swiper_core_Swiper(".otliv__slider-main", {
                    modules: [ Pagination, Thumb, Navigation ],
                    thumbs: {
                        swiper: otlivThumbs
                    },
                    observer: true,
                    observeParents: true,
                    slidesPerView: 1,
                    speed: 400,
                    navigation: {
                        prevEl: ".otlivant-thumbs-prev",
                        nextEl: ".otlivant-thumbs-next"
                    },
                    pagination: {
                        el: ".otlivant-photo-pagination",
                        clickable: true
                    }
                });
            }
            if (document.querySelector(".photos-response__slider")) new swiper_core_Swiper(".photos-response__slider", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                spaceBetween: 20,
                speed: 400,
                navigation: {
                    prevEl: ".photo-prod-prev",
                    nextEl: ".photo-prod-next"
                },
                breakpoints: {
                    300: {
                        slidesPerView: 4,
                        spaceBetween: 10
                    },
                    768: {
                        slidesPerView: 6
                    },
                    1001: {
                        slidesPerView: 6,
                        spaceBetween: 20
                    },
                    1281: {
                        slidesPerView: 7
                    }
                }
            });
            if (document.querySelector(".video-review-product__slider")) new swiper_core_Swiper(".video-review-product__slider", {
                modules: [ Navigation, Pagination ],
                observer: true,
                observeParents: true,
                speed: 400,
                loop: true,
                pagination: {
                    el: ".device-review-video-pagination",
                    clickable: true
                },
                navigation: {
                    prevEl: ".video-review-prev",
                    nextEl: ".video-review-next"
                },
                breakpoints: {
                    300: {
                        slidesPerView: 4,
                        spaceBetween: 15
                    },
                    480: {
                        slidesPerView: 4,
                        spaceBetween: 20
                    },
                    768: {
                        slidesPerView: 5,
                        spaceBetween: 20
                    },
                    1001: {
                        slidesPerView: 8,
                        spaceBetween: 20
                    },
                    1281: {
                        slidesPerView: 8,
                        spaceBetween: 46
                    }
                }
            });
            if (document.querySelector(".more-video__slider")) new swiper_core_Swiper(".more-video__slider", {
                modules: [ Navigation, Pagination ],
                observer: true,
                observeParents: true,
                slidesPerView: 3,
                spaceBetween: 20,
                speed: 800,
                loop: false,
                pagination: {
                    el: ".more-video-product",
                    clickable: true
                },
                navigation: {
                    prevEl: ".video-more-product-prev",
                    nextEl: ".video-more-product-next"
                },
                breakpoints: {
                    300: {
                        slidesPerView: 1.3,
                        spaceBetween: 20
                    },
                    768: {
                        slidesPerView: 2,
                        spaceBetween: 17
                    },
                    1001: {
                        slidesPerView: 3,
                        spaceBetween: 20
                    }
                }
            });
            if (document.querySelector(".photo-product__slider-thumbs")) {
                const productThumbs = new swiper_core_Swiper(".photo-product__slider-thumbs", {
                    modules: [ Thumb, Navigation ],
                    direction: "vertical",
                    speed: 400,
                    spaceBetween: 15,
                    slidesPerView: 5
                });
                new swiper_core_Swiper(".photo-product__slider", {
                    modules: [ Pagination, Thumb, Navigation ],
                    thumbs: {
                        swiper: productThumbs
                    },
                    slidesPerView: 1,
                    autoHeight: true,
                    speed: 400,
                    navigation: {
                        prevEl: ".otlivant-thumbs-prev",
                        nextEl: ".otlivant-thumbs-next"
                    },
                    pagination: {
                        el: ".otlivant-photo-pagination",
                        clickable: true
                    }
                });
            }
        }
        window.addEventListener("load", (function(e) {
            initSliders();
            if (document.querySelector(".page__products")) {
                const resizableSwiper = (breakpoint, swiperClass, swiperSettings, callback) => {
                    let swiper;
                    breakpoint = window.matchMedia(breakpoint);
                    const enableSwiper = function(className, settings) {
                        swiper = new swiper_core_Swiper(className, settings);
                        if (callback) callback(swiper);
                    };
                    const checker = function() {
                        if (breakpoint.matches) return enableSwiper(swiperClass, swiperSettings); else {
                            if (swiper !== void 0) swiper.destroy(true, true);
                            return;
                        }
                    };
                    breakpoint.addEventListener("change", checker);
                    checker();
                };
                resizableSwiper("(max-width: 767.98px)", ".discounts__slider", {
                    modules: [ Pagination, Autoplay ],
                    observer: true,
                    observeParents: true,
                    spaceBetween: 20,
                    speed: 800,
                    pagination: {
                        el: ".swiper-discount-pagination",
                        clickable: true
                    },
                    breakpoints: {
                        360: {
                            slidesPerView: 1.15,
                            spaceBetween: 20
                        }
                    }
                });
            }
            if (document.querySelector(".point")) {
                const resizableSwiper = (breakpoint, swiperClass, swiperSettings, callback) => {
                    let swiper;
                    breakpoint = window.matchMedia(breakpoint);
                    const enableSwiper = function(className, settings) {
                        swiper = new swiper_core_Swiper(className, settings);
                        if (callback) callback(swiper);
                    };
                    const checker = function() {
                        if (breakpoint.matches) return enableSwiper(swiperClass, swiperSettings); else {
                            if (swiper !== void 0) swiper.destroy(true, true);
                            return;
                        }
                    };
                    breakpoint.addEventListener("change", checker);
                    checker();
                };
                resizableSwiper("(max-width: 1001.98px)", ".aside-point__content", {
                    modules: [ Pagination, Autoplay, Navigation ],
                    observer: true,
                    observeParents: true,
                    spaceBetween: 20,
                    speed: 800,
                    pagination: {
                        el: ".aside-point__pagination",
                        clickable: true
                    },
                    navigation: {
                        prevEl: ".swiper-point-prev",
                        nextEl: ".swiper-point-next"
                    },
                    breakpoints: {
                        360: {
                            slidesPerView: 1.15,
                            spaceBetween: 20
                        },
                        768: {
                            slidesPerView: 2,
                            spaceBetween: 20
                        }
                    }
                });
            }
            if (document.querySelector(".otlvant-review")) {
                const resizableSwiper = (breakpoint, swiperClass, swiperSettings, callback) => {
                    let swiper;
                    breakpoint = window.matchMedia(breakpoint);
                    const enableSwiper = function(className, settings) {
                        swiper = new swiper_core_Swiper(className, settings);
                        if (callback) callback(swiper);
                    };
                    const checker = function() {
                        if (breakpoint.matches) return enableSwiper(swiperClass, swiperSettings); else {
                            if (swiper !== void 0) swiper.destroy(true, true);
                            return;
                        }
                    };
                    breakpoint.addEventListener("change", checker);
                    checker();
                };
                resizableSwiper("(min-width: 767.98px)", ".otlvant-review__slider", {
                    modules: [ Pagination, Navigation ],
                    observer: true,
                    observeParents: true,
                    spaceBetween: 20,
                    speed: 800,
                    pagination: {
                        el: ".review-otlivant-pagination",
                        clickable: true
                    },
                    navigation: {
                        prevEl: ".otlivant-review-prev",
                        nextEl: ".otlivant-review-next"
                    },
                    breakpoints: {
                        768: {
                            slidesPerView: 2,
                            spaceBetween: 20
                        },
                        1001.98: {
                            slidesPerView: 3,
                            spaceBetween: 20
                        }
                    }
                });
            }
            if (document.querySelector(".popular-products__content")) {
                const resizableSwiper = (breakpoint, swiperClass, swiperSettings, callback) => {
                    let swiper;
                    breakpoint = window.matchMedia(breakpoint);
                    const enableSwiper = function(className, settings) {
                        swiper = new swiper_core_Swiper(className, settings);
                        if (callback) callback(swiper);
                    };
                    const checker = function() {
                        if (breakpoint.matches) return enableSwiper(swiperClass, swiperSettings); else {
                            if (swiper !== void 0) swiper.destroy(true, true);
                            return;
                        }
                    };
                    breakpoint.addEventListener("change", checker);
                    checker();
                };
                resizableSwiper("(max-width: 1001.97px)", ".popular-products__content", {
                    modules: [ Pagination ],
                    observer: true,
                    observeParents: true,
                    spaceBetween: 20,
                    speed: 800,
                    pagination: {
                        el: ".popular-products__pagination",
                        clickable: true
                    },
                    breakpoints: {
                        360: {
                            slidesPerView: 2,
                            spaceBetween: 20
                        },
                        768: {
                            slidesPerView: 3,
                            spaceBetween: 30
                        }
                    }
                });
            }
            if (document.querySelector(".certificates")) {
                const resizableSwiper = (breakpoint, swiperClass, swiperSettings, callback) => {
                    let swiper;
                    breakpoint = window.matchMedia(breakpoint);
                    const enableSwiper = function(className, settings) {
                        swiper = new swiper_core_Swiper(className, settings);
                        if (callback) callback(swiper);
                    };
                    const checker = function() {
                        if (breakpoint.matches) return enableSwiper(swiperClass, swiperSettings); else {
                            if (swiper !== void 0) swiper.destroy(true, true);
                            return;
                        }
                    };
                    breakpoint.addEventListener("change", checker);
                    checker();
                };
                resizableSwiper("(min-width: 767.98px)", ".certificates__slider", {
                    modules: [ Pagination, Navigation ],
                    observer: true,
                    observeParents: true,
                    spaceBetween: 20,
                    speed: 800,
                    pagination: {
                        el: ".review-otlivant-pagination",
                        clickable: true
                    },
                    navigation: {
                        prevEl: ".otlivant-review-prev",
                        nextEl: ".otlivant-review-next"
                    },
                    breakpoints: {
                        768: {
                            slidesPerView: 2,
                            spaceBetween: 20
                        },
                        1001.98: {
                            slidesPerView: 3,
                            spaceBetween: 20
                        }
                    }
                });
            }
            if (document.querySelector(".device-review__slider")) {
                const resizableSwiper = (breakpoint, swiperClass, swiperSettings, callback) => {
                    let swiper;
                    breakpoint = window.matchMedia(breakpoint);
                    const enableSwiper = function(className, settings) {
                        swiper = new swiper_core_Swiper(className, settings);
                        if (callback) callback(swiper);
                    };
                    const checker = function() {
                        if (breakpoint.matches) return enableSwiper(swiperClass, swiperSettings); else {
                            if (swiper !== void 0) swiper.destroy(true, true);
                            return;
                        }
                    };
                    breakpoint.addEventListener("change", checker);
                    checker();
                };
                resizableSwiper("(min-width: 767.98px)", ".device-review__slider", {
                    modules: [ Pagination, Navigation ],
                    observer: true,
                    observeParents: true,
                    spaceBetween: 20,
                    speed: 800,
                    pagination: {
                        el: ".review-device-pagination",
                        clickable: true
                    },
                    navigation: {
                        prevEl: ".device-review-prev",
                        nextEl: ".device-review-next"
                    },
                    breakpoints: {
                        768: {
                            slidesPerView: 2,
                            spaceBetween: 20
                        },
                        1001.98: {
                            slidesPerView: 3,
                            spaceBetween: 20
                        }
                    }
                });
            }
            if (document.querySelector(".other-device__slider")) {
                const resizableSwiper = (breakpoint, swiperClass, swiperSettings, callback) => {
                    let swiper;
                    breakpoint = window.matchMedia(breakpoint);
                    const enableSwiper = function(className, settings) {
                        swiper = new swiper_core_Swiper(className, settings);
                        if (callback) callback(swiper);
                    };
                    const checker = function() {
                        if (breakpoint.matches) return enableSwiper(swiperClass, swiperSettings); else {
                            if (swiper !== void 0) swiper.destroy(true, true);
                            return;
                        }
                    };
                    breakpoint.addEventListener("change", checker);
                    checker();
                };
                resizableSwiper("(min-width: 767.98px)", ".other-device__slider", {
                    modules: [ Navigation ],
                    observer: true,
                    observeParents: true,
                    spaceBetween: 20,
                    speed: 800,
                    navigation: {
                        prevEl: ".device-other-prev",
                        nextEl: ".device-other-next"
                    },
                    breakpoints: {
                        768: {
                            slidesPerView: 3,
                            spaceBetween: 20
                        },
                        1001: {
                            slidesPerView: 5,
                            spaceBetween: 30
                        },
                        1280: {
                            slidesPerView: 6,
                            spaceBetween: 20
                        }
                    }
                });
            }
        }));
        let addWindowScrollEvent = false;
        function pageNavigation() {
            document.addEventListener("click", pageNavigationAction);
            document.addEventListener("watcherCallback", pageNavigationAction);
            function pageNavigationAction(e) {
                if (e.type === "click") {
                    const targetElement = e.target;
                    if (targetElement.closest("[data-goto]")) {
                        const gotoLink = targetElement.closest("[data-goto]");
                        const gotoLinkSelector = gotoLink.dataset.goto ? gotoLink.dataset.goto : "";
                        const noHeader = gotoLink.hasAttribute("data-goto-header") ? true : false;
                        const gotoSpeed = gotoLink.dataset.gotoSpeed ? gotoLink.dataset.gotoSpeed : 500;
                        const offsetTop = gotoLink.dataset.gotoTop ? parseInt(gotoLink.dataset.gotoTop) : 0;
                        if (modules_flsModules.fullpage) {
                            const fullpageSection = document.querySelector(`${gotoLinkSelector}`).closest("[data-fp-section]");
                            const fullpageSectionId = fullpageSection ? +fullpageSection.dataset.fpId : null;
                            if (fullpageSectionId !== null) {
                                modules_flsModules.fullpage.switchingSection(fullpageSectionId);
                                document.documentElement.classList.contains("menu-open") ? menuClose() : null;
                            }
                        } else gotoblock_gotoBlock(gotoLinkSelector, noHeader, gotoSpeed, offsetTop);
                        e.preventDefault();
                    }
                } else if (e.type === "watcherCallback" && e.detail) {
                    const entry = e.detail.entry;
                    const targetElement = entry.target;
                    if (targetElement.dataset.watch === "navigator") {
                        document.querySelector(`[data-goto]._navigator-active`);
                        let navigatorCurrentItem;
                        if (targetElement.id && document.querySelector(`[data-goto="#${targetElement.id}"]`)) navigatorCurrentItem = document.querySelector(`[data-goto="#${targetElement.id}"]`); else if (targetElement.classList.length) for (let index = 0; index < targetElement.classList.length; index++) {
                            const element = targetElement.classList[index];
                            if (document.querySelector(`[data-goto=".${element}"]`)) {
                                navigatorCurrentItem = document.querySelector(`[data-goto=".${element}"]`);
                                break;
                            }
                        }
                        if (entry.isIntersecting) navigatorCurrentItem ? navigatorCurrentItem.classList.add("_navigator-active") : null; else navigatorCurrentItem ? navigatorCurrentItem.classList.remove("_navigator-active") : null;
                    }
                }
            }
            if (getHash()) {
                let goToHash;
                if (document.querySelector(`#${getHash()}`)) goToHash = `#${getHash()}`; else if (document.querySelector(`.${getHash()}`)) goToHash = `.${getHash()}`;
                goToHash ? gotoblock_gotoBlock(goToHash, true, 500, 20) : null;
            }
        }
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        class DynamicAdapt {
            constructor(type) {
                this.type = type;
            }
            init() {
                this.оbjects = [];
                this.daClassname = "_dynamic_adapt_";
                this.nodes = [ ...document.querySelectorAll("[data-da]") ];
                this.nodes.forEach((node => {
                    const data = node.dataset.da.trim();
                    const dataArray = data.split(",");
                    const оbject = {};
                    оbject.element = node;
                    оbject.parent = node.parentNode;
                    оbject.destination = document.querySelector(`${dataArray[0].trim()}`);
                    оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767";
                    оbject.place = dataArray[2] ? dataArray[2].trim() : "last";
                    оbject.index = this.indexInParent(оbject.parent, оbject.element);
                    this.оbjects.push(оbject);
                }));
                this.arraySort(this.оbjects);
                this.mediaQueries = this.оbjects.map((({breakpoint}) => `(${this.type}-width: ${breakpoint}px),${breakpoint}`)).filter(((item, index, self) => self.indexOf(item) === index));
                this.mediaQueries.forEach((media => {
                    const mediaSplit = media.split(",");
                    const matchMedia = window.matchMedia(mediaSplit[0]);
                    const mediaBreakpoint = mediaSplit[1];
                    const оbjectsFilter = this.оbjects.filter((({breakpoint}) => breakpoint === mediaBreakpoint));
                    matchMedia.addEventListener("change", (() => {
                        this.mediaHandler(matchMedia, оbjectsFilter);
                    }));
                    this.mediaHandler(matchMedia, оbjectsFilter);
                }));
            }
            mediaHandler(matchMedia, оbjects) {
                if (matchMedia.matches) оbjects.forEach((оbject => {
                    this.moveTo(оbject.place, оbject.element, оbject.destination);
                })); else оbjects.forEach((({parent, element, index}) => {
                    if (element.classList.contains(this.daClassname)) this.moveBack(parent, element, index);
                }));
            }
            moveTo(place, element, destination) {
                element.classList.add(this.daClassname);
                if (place === "last" || place >= destination.children.length) {
                    destination.append(element);
                    return;
                }
                if (place === "first") {
                    destination.prepend(element);
                    return;
                }
                destination.children[place].before(element);
            }
            moveBack(parent, element, index) {
                element.classList.remove(this.daClassname);
                if (parent.children[index] !== void 0) parent.children[index].before(element); else parent.append(element);
            }
            indexInParent(parent, element) {
                return [ ...parent.children ].indexOf(element);
            }
            arraySort(arr) {
                if (this.type === "min") arr.sort(((a, b) => {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if (a.place === "first" || b.place === "last") return -1;
                        if (a.place === "last" || b.place === "first") return 1;
                        return 0;
                    }
                    return a.breakpoint - b.breakpoint;
                })); else {
                    arr.sort(((a, b) => {
                        if (a.breakpoint === b.breakpoint) {
                            if (a.place === b.place) return 0;
                            if (a.place === "first" || b.place === "last") return 1;
                            if (a.place === "last" || b.place === "first") return -1;
                            return 0;
                        }
                        return b.breakpoint - a.breakpoint;
                    }));
                    return;
                }
            }
        }
        const da = new DynamicAdapt("max");
        da.init();
        /**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
        function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                }));
                keys.push.apply(keys, symbols);
            }
            return keys;
        }
        function _objectSpread2(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) ownKeys(Object(source), true).forEach((function(key) {
                    _defineProperty(target, key, source[key]);
                })); else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); else ownKeys(Object(source)).forEach((function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                }));
            }
            return target;
        }
        function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function(obj) {
                return typeof obj;
            }; else _typeof = function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            return _typeof(obj);
        }
        function _defineProperty(obj, key, value) {
            if (key in obj) Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                configurable: true,
                writable: true
            }); else obj[key] = value;
            return obj;
        }
        function _extends() {
            _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                }
                return target;
            };
            return _extends.apply(this, arguments);
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null) return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;
            for (i = 0; i < sourceKeys.length; i++) {
                key = sourceKeys[i];
                if (excluded.indexOf(key) >= 0) continue;
                target[key] = source[key];
            }
            return target;
        }
        function _objectWithoutProperties(source, excluded) {
            if (source == null) return {};
            var target = _objectWithoutPropertiesLoose(source, excluded);
            var key, i;
            if (Object.getOwnPropertySymbols) {
                var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                for (i = 0; i < sourceSymbolKeys.length; i++) {
                    key = sourceSymbolKeys[i];
                    if (excluded.indexOf(key) >= 0) continue;
                    if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                    target[key] = source[key];
                }
            }
            return target;
        }
        var version = "1.15.2";
        function userAgent(pattern) {
            if (typeof window !== "undefined" && window.navigator) return !!navigator.userAgent.match(pattern);
        }
        var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
        var Edge = userAgent(/Edge/i);
        var FireFox = userAgent(/firefox/i);
        var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
        var IOS = userAgent(/iP(ad|od|hone)/i);
        var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
        var captureMode = {
            capture: false,
            passive: false
        };
        function on(el, event, fn) {
            el.addEventListener(event, fn, !IE11OrLess && captureMode);
        }
        function off(el, event, fn) {
            el.removeEventListener(event, fn, !IE11OrLess && captureMode);
        }
        function matches(el, selector) {
            if (!selector) return;
            selector[0] === ">" && (selector = selector.substring(1));
            if (el) try {
                if (el.matches) return el.matches(selector); else if (el.msMatchesSelector) return el.msMatchesSelector(selector); else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
            } catch (_) {
                return false;
            }
            return false;
        }
        function getParentOrHost(el) {
            return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
        }
        function sortable_esm_closest(el, selector, ctx, includeCTX) {
            if (el) {
                ctx = ctx || document;
                do {
                    if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) return el;
                    if (el === ctx) break;
                } while (el = getParentOrHost(el));
            }
            return null;
        }
        var R_SPACE = /\s+/g;
        function toggleClass(el, name, state) {
            if (el && name) if (el.classList) el.classList[state ? "add" : "remove"](name); else {
                var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
                el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
            }
        }
        function css(el, prop, val) {
            var style = el && el.style;
            if (style) if (val === void 0) {
                if (document.defaultView && document.defaultView.getComputedStyle) val = document.defaultView.getComputedStyle(el, ""); else if (el.currentStyle) val = el.currentStyle;
                return prop === void 0 ? val : val[prop];
            } else {
                if (!(prop in style) && prop.indexOf("webkit") === -1) prop = "-webkit-" + prop;
                style[prop] = val + (typeof val === "string" ? "" : "px");
            }
        }
        function matrix(el, selfOnly) {
            var appliedTransforms = "";
            if (typeof el === "string") appliedTransforms = el; else do {
                var transform = css(el, "transform");
                if (transform && transform !== "none") appliedTransforms = transform + " " + appliedTransforms;
            } while (!selfOnly && (el = el.parentNode));
            var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
            return matrixFn && new matrixFn(appliedTransforms);
        }
        function find(ctx, tagName, iterator) {
            if (ctx) {
                var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
                if (iterator) for (;i < n; i++) iterator(list[i], i);
                return list;
            }
            return [];
        }
        function getWindowScrollingElement() {
            var scrollingElement = document.scrollingElement;
            if (scrollingElement) return scrollingElement; else return document.documentElement;
        }
        function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
            if (!el.getBoundingClientRect && el !== window) return;
            var elRect, top, left, bottom, right, height, width;
            if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
                elRect = el.getBoundingClientRect();
                top = elRect.top;
                left = elRect.left;
                bottom = elRect.bottom;
                right = elRect.right;
                height = elRect.height;
                width = elRect.width;
            } else {
                top = 0;
                left = 0;
                bottom = window.innerHeight;
                right = window.innerWidth;
                height = window.innerHeight;
                width = window.innerWidth;
            }
            if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
                container = container || el.parentNode;
                if (!IE11OrLess) do {
                    if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
                        var containerRect = container.getBoundingClientRect();
                        top -= containerRect.top + parseInt(css(container, "border-top-width"));
                        left -= containerRect.left + parseInt(css(container, "border-left-width"));
                        bottom = top + elRect.height;
                        right = left + elRect.width;
                        break;
                    }
                } while (container = container.parentNode);
            }
            if (undoScale && el !== window) {
                var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
                if (elMatrix) {
                    top /= scaleY;
                    left /= scaleX;
                    width /= scaleX;
                    height /= scaleY;
                    bottom = top + height;
                    right = left + width;
                }
            }
            return {
                top,
                left,
                bottom,
                right,
                width,
                height
            };
        }
        function isScrolledPast(el, elSide, parentSide) {
            var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
            while (parent) {
                var parentSideVal = getRect(parent)[parentSide], visible = void 0;
                if (parentSide === "top" || parentSide === "left") visible = elSideVal >= parentSideVal; else visible = elSideVal <= parentSideVal;
                if (!visible) return parent;
                if (parent === getWindowScrollingElement()) break;
                parent = getParentAutoScrollElement(parent, false);
            }
            return false;
        }
        function getChild(el, childNum, options, includeDragEl) {
            var currentChild = 0, i = 0, children = el.children;
            while (i < children.length) {
                if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && sortable_esm_closest(children[i], options.draggable, el, false)) {
                    if (currentChild === childNum) return children[i];
                    currentChild++;
                }
                i++;
            }
            return null;
        }
        function lastChild(el, selector) {
            var last = el.lastElementChild;
            while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) last = last.previousElementSibling;
            return last || null;
        }
        function index(el, selector) {
            var index = 0;
            if (!el || !el.parentNode) return -1;
            while (el = el.previousElementSibling) if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) index++;
            return index;
        }
        function getRelativeScrollOffset(el) {
            var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
            if (el) do {
                var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
                offsetLeft += el.scrollLeft * scaleX;
                offsetTop += el.scrollTop * scaleY;
            } while (el !== winScroller && (el = el.parentNode));
            return [ offsetLeft, offsetTop ];
        }
        function indexOfObject(arr, obj) {
            for (var i in arr) {
                if (!arr.hasOwnProperty(i)) continue;
                for (var key in obj) if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
            }
            return -1;
        }
        function getParentAutoScrollElement(el, includeSelf) {
            if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
            var elem = el;
            var gotSelf = false;
            do {
                if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
                    var elemCSS = css(elem);
                    if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
                        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
                        if (gotSelf || includeSelf) return elem;
                        gotSelf = true;
                    }
                }
            } while (elem = elem.parentNode);
            return getWindowScrollingElement();
        }
        function sortable_esm_extend(dst, src) {
            if (dst && src) for (var key in src) if (src.hasOwnProperty(key)) dst[key] = src[key];
            return dst;
        }
        function isRectEqual(rect1, rect2) {
            return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
        }
        var _throttleTimeout;
        function throttle(callback, ms) {
            return function() {
                if (!_throttleTimeout) {
                    var args = arguments, _this = this;
                    if (args.length === 1) callback.call(_this, args[0]); else callback.apply(_this, args);
                    _throttleTimeout = setTimeout((function() {
                        _throttleTimeout = void 0;
                    }), ms);
                }
            };
        }
        function cancelThrottle() {
            clearTimeout(_throttleTimeout);
            _throttleTimeout = void 0;
        }
        function scrollBy(el, x, y) {
            el.scrollLeft += x;
            el.scrollTop += y;
        }
        function clone(el) {
            var Polymer = window.Polymer;
            var $ = window.jQuery || window.Zepto;
            if (Polymer && Polymer.dom) return Polymer.dom(el).cloneNode(true); else if ($) return $(el).clone(true)[0]; else return el.cloneNode(true);
        }
        function getChildContainingRectFromElement(container, options, ghostEl) {
            var rect = {};
            Array.from(container.children).forEach((function(child) {
                var _rect$left, _rect$top, _rect$right, _rect$bottom;
                if (!sortable_esm_closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
                var childRect = getRect(child);
                rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : 1 / 0, childRect.left);
                rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : 1 / 0, childRect.top);
                rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -1 / 0, childRect.right);
                rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -1 / 0, childRect.bottom);
            }));
            rect.width = rect.right - rect.left;
            rect.height = rect.bottom - rect.top;
            rect.x = rect.left;
            rect.y = rect.top;
            return rect;
        }
        var expando = "Sortable" + (new Date).getTime();
        function AnimationStateManager() {
            var animationCallbackId, animationStates = [];
            return {
                captureAnimationState: function captureAnimationState() {
                    animationStates = [];
                    if (!this.options.animation) return;
                    var children = [].slice.call(this.el.children);
                    children.forEach((function(child) {
                        if (css(child, "display") === "none" || child === Sortable.ghost) return;
                        animationStates.push({
                            target: child,
                            rect: getRect(child)
                        });
                        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
                        if (child.thisAnimationDuration) {
                            var childMatrix = matrix(child, true);
                            if (childMatrix) {
                                fromRect.top -= childMatrix.f;
                                fromRect.left -= childMatrix.e;
                            }
                        }
                        child.fromRect = fromRect;
                    }));
                },
                addAnimationState: function addAnimationState(state) {
                    animationStates.push(state);
                },
                removeAnimationState: function removeAnimationState(target) {
                    animationStates.splice(indexOfObject(animationStates, {
                        target
                    }), 1);
                },
                animateAll: function animateAll(callback) {
                    var _this = this;
                    if (!this.options.animation) {
                        clearTimeout(animationCallbackId);
                        if (typeof callback === "function") callback();
                        return;
                    }
                    var animating = false, animationTime = 0;
                    animationStates.forEach((function(state) {
                        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
                        if (targetMatrix) {
                            toRect.top -= targetMatrix.f;
                            toRect.left -= targetMatrix.e;
                        }
                        target.toRect = toRect;
                        if (target.thisAnimationDuration) if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
                        if (!isRectEqual(toRect, fromRect)) {
                            target.prevFromRect = fromRect;
                            target.prevToRect = toRect;
                            if (!time) time = _this.options.animation;
                            _this.animate(target, animatingRect, toRect, time);
                        }
                        if (time) {
                            animating = true;
                            animationTime = Math.max(animationTime, time);
                            clearTimeout(target.animationResetTimer);
                            target.animationResetTimer = setTimeout((function() {
                                target.animationTime = 0;
                                target.prevFromRect = null;
                                target.fromRect = null;
                                target.prevToRect = null;
                                target.thisAnimationDuration = null;
                            }), time);
                            target.thisAnimationDuration = time;
                        }
                    }));
                    clearTimeout(animationCallbackId);
                    if (!animating) {
                        if (typeof callback === "function") callback();
                    } else animationCallbackId = setTimeout((function() {
                        if (typeof callback === "function") callback();
                    }), animationTime);
                    animationStates = [];
                },
                animate: function animate(target, currentRect, toRect, duration) {
                    if (duration) {
                        css(target, "transition", "");
                        css(target, "transform", "");
                        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
                        target.animatingX = !!translateX;
                        target.animatingY = !!translateY;
                        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
                        this.forRepaintDummy = repaint(target);
                        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
                        css(target, "transform", "translate3d(0,0,0)");
                        typeof target.animated === "number" && clearTimeout(target.animated);
                        target.animated = setTimeout((function() {
                            css(target, "transition", "");
                            css(target, "transform", "");
                            target.animated = false;
                            target.animatingX = false;
                            target.animatingY = false;
                        }), duration);
                    }
                }
            };
        }
        function repaint(target) {
            return target.offsetWidth;
        }
        function calculateRealTime(animatingRect, fromRect, toRect, options) {
            return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
        }
        var plugins = [];
        var sortable_esm_defaults = {
            initializeByDefault: true
        };
        var PluginManager = {
            mount: function mount(plugin) {
                for (var option in sortable_esm_defaults) if (sortable_esm_defaults.hasOwnProperty(option) && !(option in plugin)) plugin[option] = sortable_esm_defaults[option];
                plugins.forEach((function(p) {
                    if (p.pluginName === plugin.pluginName) throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
                }));
                plugins.push(plugin);
            },
            pluginEvent: function pluginEvent(eventName, sortable, evt) {
                var _this = this;
                this.eventCanceled = false;
                evt.cancel = function() {
                    _this.eventCanceled = true;
                };
                var eventNameGlobal = eventName + "Global";
                plugins.forEach((function(plugin) {
                    if (!sortable[plugin.pluginName]) return;
                    if (sortable[plugin.pluginName][eventNameGlobal]) sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
                        sortable
                    }, evt));
                    if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) sortable[plugin.pluginName][eventName](_objectSpread2({
                        sortable
                    }, evt));
                }));
            },
            initializePlugins: function initializePlugins(sortable, el, defaults, options) {
                plugins.forEach((function(plugin) {
                    var pluginName = plugin.pluginName;
                    if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
                    var initialized = new plugin(sortable, el, sortable.options);
                    initialized.sortable = sortable;
                    initialized.options = sortable.options;
                    sortable[pluginName] = initialized;
                    _extends(defaults, initialized.defaults);
                }));
                for (var option in sortable.options) {
                    if (!sortable.options.hasOwnProperty(option)) continue;
                    var modified = this.modifyOption(sortable, option, sortable.options[option]);
                    if (typeof modified !== "undefined") sortable.options[option] = modified;
                }
            },
            getEventProperties: function getEventProperties(name, sortable) {
                var eventProperties = {};
                plugins.forEach((function(plugin) {
                    if (typeof plugin.eventProperties !== "function") return;
                    _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
                }));
                return eventProperties;
            },
            modifyOption: function modifyOption(sortable, name, value) {
                var modifiedValue;
                plugins.forEach((function(plugin) {
                    if (!sortable[plugin.pluginName]) return;
                    if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
                }));
                return modifiedValue;
            }
        };
        function dispatchEvent(_ref) {
            var sortable = _ref.sortable, rootEl = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex = _ref.oldIndex, newIndex = _ref.newIndex, oldDraggableIndex = _ref.oldDraggableIndex, newDraggableIndex = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
            sortable = sortable || rootEl && rootEl[expando];
            if (!sortable) return;
            var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
            if (window.CustomEvent && !IE11OrLess && !Edge) evt = new CustomEvent(name, {
                bubbles: true,
                cancelable: true
            }); else {
                evt = document.createEvent("Event");
                evt.initEvent(name, true, true);
            }
            evt.to = toEl || rootEl;
            evt.from = fromEl || rootEl;
            evt.item = targetEl || rootEl;
            evt.clone = cloneEl;
            evt.oldIndex = oldIndex;
            evt.newIndex = newIndex;
            evt.oldDraggableIndex = oldDraggableIndex;
            evt.newDraggableIndex = newDraggableIndex;
            evt.originalEvent = originalEvent;
            evt.pullMode = putSortable ? putSortable.lastPutMode : void 0;
            var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
            for (var option in allEventProperties) evt[option] = allEventProperties[option];
            if (rootEl) rootEl.dispatchEvent(evt);
            if (options[onName]) options[onName].call(sortable, evt);
        }
        var _excluded = [ "evt" ];
        var pluginEvent = function pluginEvent(eventName, sortable) {
            var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
            PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
                dragEl,
                parentEl,
                ghostEl,
                rootEl,
                nextEl,
                lastDownEl,
                cloneEl,
                cloneHidden,
                dragStarted: moved,
                putSortable,
                activeSortable: Sortable.active,
                originalEvent,
                oldIndex,
                oldDraggableIndex,
                newIndex,
                newDraggableIndex,
                hideGhostForTarget: _hideGhostForTarget,
                unhideGhostForTarget: _unhideGhostForTarget,
                cloneNowHidden: function cloneNowHidden() {
                    cloneHidden = true;
                },
                cloneNowShown: function cloneNowShown() {
                    cloneHidden = false;
                },
                dispatchSortableEvent: function dispatchSortableEvent(name) {
                    _dispatchEvent({
                        sortable,
                        name,
                        originalEvent
                    });
                }
            }, data));
        };
        function _dispatchEvent(info) {
            dispatchEvent(_objectSpread2({
                putSortable,
                cloneEl,
                targetEl: dragEl,
                rootEl,
                oldIndex,
                oldDraggableIndex,
                newIndex,
                newDraggableIndex
            }, info));
        }
        var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, targetMoveDistance, ghostRelativeParent, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], pastFirstInvertThresh = false, isCircumstantialInvert = false, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
        var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
            if (!documentExists) return;
            if (IE11OrLess) return false;
            var el = document.createElement("x");
            el.style.cssText = "pointer-events:auto";
            return el.style.pointerEvents === "auto";
        }(), _detectDirection = function _detectDirection(el, options) {
            var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
            if (elCSS.display === "flex") return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
            if (elCSS.display === "grid") return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
            if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
                var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
                return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
            }
            return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
        }, _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
            var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
            return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
        }, _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
            var ret;
            sortables.some((function(sortable) {
                var threshold = sortable[expando].options.emptyInsertThreshold;
                if (!threshold || lastChild(sortable)) return;
                var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
                if (insideHorizontally && insideVertically) return ret = sortable;
            }));
            return ret;
        }, _prepareGroup = function _prepareGroup(options) {
            function toFn(value, pull) {
                return function(to, from, dragEl, evt) {
                    var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
                    if (value == null && (pull || sameGroup)) return true; else if (value == null || value === false) return false; else if (pull && value === "clone") return value; else if (typeof value === "function") return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt); else {
                        var otherGroup = (pull ? to : from).options.group.name;
                        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
                    }
                };
            }
            var group = {};
            var originalGroup = options.group;
            if (!originalGroup || _typeof(originalGroup) != "object") originalGroup = {
                name: originalGroup
            };
            group.name = originalGroup.name;
            group.checkPull = toFn(originalGroup.pull, true);
            group.checkPut = toFn(originalGroup.put);
            group.revertClone = originalGroup.revertClone;
            options.group = group;
        }, _hideGhostForTarget = function _hideGhostForTarget() {
            if (!supportCssPointerEvents && ghostEl) css(ghostEl, "display", "none");
        }, _unhideGhostForTarget = function _unhideGhostForTarget() {
            if (!supportCssPointerEvents && ghostEl) css(ghostEl, "display", "");
        };
        if (documentExists && !ChromeForAndroid) document.addEventListener("click", (function(evt) {
            if (ignoreNextClick) {
                evt.preventDefault();
                evt.stopPropagation && evt.stopPropagation();
                evt.stopImmediatePropagation && evt.stopImmediatePropagation();
                ignoreNextClick = false;
                return false;
            }
        }), true);
        var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
            if (dragEl) {
                evt = evt.touches ? evt.touches[0] : evt;
                var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
                if (nearest) {
                    var event = {};
                    for (var i in evt) if (evt.hasOwnProperty(i)) event[i] = evt[i];
                    event.target = event.rootEl = nearest;
                    event.preventDefault = void 0;
                    event.stopPropagation = void 0;
                    nearest[expando]._onDragOver(event);
                }
            }
        };
        var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
            if (dragEl) dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        };
        function Sortable(el, options) {
            if (!(el && el.nodeType && el.nodeType === 1)) throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
            this.el = el;
            this.options = options = _extends({}, options);
            el[expando] = this;
            var defaults = {
                group: null,
                sort: true,
                disabled: false,
                store: null,
                handle: null,
                draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
                swapThreshold: 1,
                invertSwap: false,
                invertedSwapThreshold: null,
                removeCloneOnHide: true,
                direction: function direction() {
                    return _detectDirection(el, this.options);
                },
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag",
                ignore: "a, img",
                filter: null,
                preventOnFilter: true,
                animation: 0,
                easing: null,
                setData: function setData(dataTransfer, dragEl) {
                    dataTransfer.setData("Text", dragEl.textContent);
                },
                dropBubble: false,
                dragoverBubble: false,
                dataIdAttr: "data-id",
                delay: 0,
                delayOnTouchOnly: false,
                touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
                forceFallback: false,
                fallbackClass: "sortable-fallback",
                fallbackOnBody: false,
                fallbackTolerance: 0,
                fallbackOffset: {
                    x: 0,
                    y: 0
                },
                supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
                emptyInsertThreshold: 5
            };
            PluginManager.initializePlugins(this, el, defaults);
            for (var name in defaults) !(name in options) && (options[name] = defaults[name]);
            _prepareGroup(options);
            for (var fn in this) if (fn.charAt(0) === "_" && typeof this[fn] === "function") this[fn] = this[fn].bind(this);
            this.nativeDraggable = options.forceFallback ? false : supportDraggable;
            if (this.nativeDraggable) this.options.touchStartThreshold = 1;
            if (options.supportPointer) on(el, "pointerdown", this._onTapStart); else {
                on(el, "mousedown", this._onTapStart);
                on(el, "touchstart", this._onTapStart);
            }
            if (this.nativeDraggable) {
                on(el, "dragover", this);
                on(el, "dragenter", this);
            }
            sortables.push(this.el);
            options.store && options.store.get && this.sort(options.store.get(this) || []);
            _extends(this, AnimationStateManager());
        }
        Sortable.prototype = {
            constructor: Sortable,
            _isOutsideThisEl: function _isOutsideThisEl(target) {
                if (!this.el.contains(target) && target !== this.el) lastTarget = null;
            },
            _getDirection: function _getDirection(evt, target) {
                return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
            },
            _onTapStart: function _onTapStart(evt) {
                if (!evt.cancelable) return;
                var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
                _saveInputCheckedState(el);
                if (dragEl) return;
                if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) return;
                if (originalTarget.isContentEditable) return;
                if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") return;
                target = sortable_esm_closest(target, options.draggable, el, false);
                if (target && target.animated) return;
                if (lastDownEl === target) return;
                oldIndex = index(target);
                oldDraggableIndex = index(target, options.draggable);
                if (typeof filter === "function") {
                    if (filter.call(this, evt, target, this)) {
                        _dispatchEvent({
                            sortable: _this,
                            rootEl: originalTarget,
                            name: "filter",
                            targetEl: target,
                            toEl: el,
                            fromEl: el
                        });
                        pluginEvent("filter", _this, {
                            evt
                        });
                        preventOnFilter && evt.cancelable && evt.preventDefault();
                        return;
                    }
                } else if (filter) {
                    filter = filter.split(",").some((function(criteria) {
                        criteria = sortable_esm_closest(originalTarget, criteria.trim(), el, false);
                        if (criteria) {
                            _dispatchEvent({
                                sortable: _this,
                                rootEl: criteria,
                                name: "filter",
                                targetEl: target,
                                fromEl: el,
                                toEl: el
                            });
                            pluginEvent("filter", _this, {
                                evt
                            });
                            return true;
                        }
                    }));
                    if (filter) {
                        preventOnFilter && evt.cancelable && evt.preventDefault();
                        return;
                    }
                }
                if (options.handle && !sortable_esm_closest(originalTarget, options.handle, el, false)) return;
                this._prepareDragStart(evt, touch, target);
            },
            _prepareDragStart: function _prepareDragStart(evt, touch, target) {
                var dragStartFn, _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument;
                if (target && !dragEl && target.parentNode === el) {
                    var dragRect = getRect(target);
                    rootEl = el;
                    dragEl = target;
                    parentEl = dragEl.parentNode;
                    nextEl = dragEl.nextSibling;
                    lastDownEl = target;
                    activeGroup = options.group;
                    Sortable.dragged = dragEl;
                    tapEvt = {
                        target: dragEl,
                        clientX: (touch || evt).clientX,
                        clientY: (touch || evt).clientY
                    };
                    tapDistanceLeft = tapEvt.clientX - dragRect.left;
                    tapDistanceTop = tapEvt.clientY - dragRect.top;
                    this._lastX = (touch || evt).clientX;
                    this._lastY = (touch || evt).clientY;
                    dragEl.style["will-change"] = "all";
                    dragStartFn = function dragStartFn() {
                        pluginEvent("delayEnded", _this, {
                            evt
                        });
                        if (Sortable.eventCanceled) {
                            _this._onDrop();
                            return;
                        }
                        _this._disableDelayedDragEvents();
                        if (!FireFox && _this.nativeDraggable) dragEl.draggable = true;
                        _this._triggerDragStart(evt, touch);
                        _dispatchEvent({
                            sortable: _this,
                            name: "choose",
                            originalEvent: evt
                        });
                        toggleClass(dragEl, options.chosenClass, true);
                    };
                    options.ignore.split(",").forEach((function(criteria) {
                        find(dragEl, criteria.trim(), _disableDraggable);
                    }));
                    on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
                    on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
                    on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
                    on(ownerDocument, "mouseup", _this._onDrop);
                    on(ownerDocument, "touchend", _this._onDrop);
                    on(ownerDocument, "touchcancel", _this._onDrop);
                    if (FireFox && this.nativeDraggable) {
                        this.options.touchStartThreshold = 4;
                        dragEl.draggable = true;
                    }
                    pluginEvent("delayStart", this, {
                        evt
                    });
                    if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
                        if (Sortable.eventCanceled) {
                            this._onDrop();
                            return;
                        }
                        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
                        on(ownerDocument, "touchend", _this._disableDelayedDrag);
                        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
                        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
                        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
                        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
                        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
                    } else dragStartFn();
                }
            },
            _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
                var touch = e.touches ? e.touches[0] : e;
                if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) this._disableDelayedDrag();
            },
            _disableDelayedDrag: function _disableDelayedDrag() {
                dragEl && _disableDraggable(dragEl);
                clearTimeout(this._dragStartTimer);
                this._disableDelayedDragEvents();
            },
            _disableDelayedDragEvents: function _disableDelayedDragEvents() {
                var ownerDocument = this.el.ownerDocument;
                off(ownerDocument, "mouseup", this._disableDelayedDrag);
                off(ownerDocument, "touchend", this._disableDelayedDrag);
                off(ownerDocument, "touchcancel", this._disableDelayedDrag);
                off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
                off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
                off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
            },
            _triggerDragStart: function _triggerDragStart(evt, touch) {
                touch = touch || evt.pointerType == "touch" && evt;
                if (!this.nativeDraggable || touch) if (this.options.supportPointer) on(document, "pointermove", this._onTouchMove); else if (touch) on(document, "touchmove", this._onTouchMove); else on(document, "mousemove", this._onTouchMove); else {
                    on(dragEl, "dragend", this);
                    on(rootEl, "dragstart", this._onDragStart);
                }
                try {
                    if (document.selection) _nextTick((function() {
                        document.selection.empty();
                    })); else window.getSelection().removeAllRanges();
                } catch (err) {}
            },
            _dragStarted: function _dragStarted(fallback, evt) {
                awaitingDragStarted = false;
                if (rootEl && dragEl) {
                    pluginEvent("dragStarted", this, {
                        evt
                    });
                    if (this.nativeDraggable) on(document, "dragover", _checkOutsideTargetEl);
                    var options = this.options;
                    !fallback && toggleClass(dragEl, options.dragClass, false);
                    toggleClass(dragEl, options.ghostClass, true);
                    Sortable.active = this;
                    fallback && this._appendGhost();
                    _dispatchEvent({
                        sortable: this,
                        name: "start",
                        originalEvent: evt
                    });
                } else this._nulling();
            },
            _emulateDragOver: function _emulateDragOver() {
                if (touchEvt) {
                    this._lastX = touchEvt.clientX;
                    this._lastY = touchEvt.clientY;
                    _hideGhostForTarget();
                    var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
                    var parent = target;
                    while (target && target.shadowRoot) {
                        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
                        if (target === parent) break;
                        parent = target;
                    }
                    dragEl.parentNode[expando]._isOutsideThisEl(target);
                    if (parent) do {
                        if (parent[expando]) {
                            var inserted = void 0;
                            inserted = parent[expando]._onDragOver({
                                clientX: touchEvt.clientX,
                                clientY: touchEvt.clientY,
                                target,
                                rootEl: parent
                            });
                            if (inserted && !this.options.dragoverBubble) break;
                        }
                        target = parent;
                    } while (parent = parent.parentNode);
                    _unhideGhostForTarget();
                }
            },
            _onTouchMove: function _onTouchMove(evt) {
                if (tapEvt) {
                    var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
                    if (!Sortable.active && !awaitingDragStarted) {
                        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) return;
                        this._onDragStart(evt, true);
                    }
                    if (ghostEl) {
                        if (ghostMatrix) {
                            ghostMatrix.e += dx - (lastDx || 0);
                            ghostMatrix.f += dy - (lastDy || 0);
                        } else ghostMatrix = {
                            a: 1,
                            b: 0,
                            c: 0,
                            d: 1,
                            e: dx,
                            f: dy
                        };
                        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
                        css(ghostEl, "webkitTransform", cssMatrix);
                        css(ghostEl, "mozTransform", cssMatrix);
                        css(ghostEl, "msTransform", cssMatrix);
                        css(ghostEl, "transform", cssMatrix);
                        lastDx = dx;
                        lastDy = dy;
                        touchEvt = touch;
                    }
                    evt.cancelable && evt.preventDefault();
                }
            },
            _appendGhost: function _appendGhost() {
                if (!ghostEl) {
                    var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
                    if (PositionGhostAbsolutely) {
                        ghostRelativeParent = container;
                        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) ghostRelativeParent = ghostRelativeParent.parentNode;
                        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
                            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
                            rect.top += ghostRelativeParent.scrollTop;
                            rect.left += ghostRelativeParent.scrollLeft;
                        } else ghostRelativeParent = getWindowScrollingElement();
                        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
                    }
                    ghostEl = dragEl.cloneNode(true);
                    toggleClass(ghostEl, options.ghostClass, false);
                    toggleClass(ghostEl, options.fallbackClass, true);
                    toggleClass(ghostEl, options.dragClass, true);
                    css(ghostEl, "transition", "");
                    css(ghostEl, "transform", "");
                    css(ghostEl, "box-sizing", "border-box");
                    css(ghostEl, "margin", 0);
                    css(ghostEl, "top", rect.top);
                    css(ghostEl, "left", rect.left);
                    css(ghostEl, "width", rect.width);
                    css(ghostEl, "height", rect.height);
                    css(ghostEl, "opacity", "0.8");
                    css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
                    css(ghostEl, "zIndex", "100000");
                    css(ghostEl, "pointerEvents", "none");
                    Sortable.ghost = ghostEl;
                    container.appendChild(ghostEl);
                    css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
                }
            },
            _onDragStart: function _onDragStart(evt, fallback) {
                var _this = this;
                var dataTransfer = evt.dataTransfer;
                var options = _this.options;
                pluginEvent("dragStart", this, {
                    evt
                });
                if (Sortable.eventCanceled) {
                    this._onDrop();
                    return;
                }
                pluginEvent("setupClone", this);
                if (!Sortable.eventCanceled) {
                    cloneEl = clone(dragEl);
                    cloneEl.removeAttribute("id");
                    cloneEl.draggable = false;
                    cloneEl.style["will-change"] = "";
                    this._hideClone();
                    toggleClass(cloneEl, this.options.chosenClass, false);
                    Sortable.clone = cloneEl;
                }
                _this.cloneId = _nextTick((function() {
                    pluginEvent("clone", _this);
                    if (Sortable.eventCanceled) return;
                    if (!_this.options.removeCloneOnHide) rootEl.insertBefore(cloneEl, dragEl);
                    _this._hideClone();
                    _dispatchEvent({
                        sortable: _this,
                        name: "clone"
                    });
                }));
                !fallback && toggleClass(dragEl, options.dragClass, true);
                if (fallback) {
                    ignoreNextClick = true;
                    _this._loopId = setInterval(_this._emulateDragOver, 50);
                } else {
                    off(document, "mouseup", _this._onDrop);
                    off(document, "touchend", _this._onDrop);
                    off(document, "touchcancel", _this._onDrop);
                    if (dataTransfer) {
                        dataTransfer.effectAllowed = "move";
                        options.setData && options.setData.call(_this, dataTransfer, dragEl);
                    }
                    on(document, "drop", _this);
                    css(dragEl, "transform", "translateZ(0)");
                }
                awaitingDragStarted = true;
                _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
                on(document, "selectstart", _this);
                moved = true;
                if (Safari) css(document.body, "user-select", "none");
            },
            _onDragOver: function _onDragOver(evt) {
                var dragRect, targetRect, revert, vertical, el = this.el, target = evt.target, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, _this = this, completedFired = false;
                if (_silent) return;
                function dragOverEvent(name, extra) {
                    pluginEvent(name, _this, _objectSpread2({
                        evt,
                        isOwner,
                        axis: vertical ? "vertical" : "horizontal",
                        revert,
                        dragRect,
                        targetRect,
                        canSort,
                        fromSortable,
                        target,
                        completed,
                        onMove: function onMove(target, after) {
                            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
                        },
                        changed
                    }, extra));
                }
                function capture() {
                    dragOverEvent("dragOverAnimationCapture");
                    _this.captureAnimationState();
                    if (_this !== fromSortable) fromSortable.captureAnimationState();
                }
                function completed(insertion) {
                    dragOverEvent("dragOverCompleted", {
                        insertion
                    });
                    if (insertion) {
                        if (isOwner) activeSortable._hideClone(); else activeSortable._showClone(_this);
                        if (_this !== fromSortable) {
                            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
                            toggleClass(dragEl, options.ghostClass, true);
                        }
                        if (putSortable !== _this && _this !== Sortable.active) putSortable = _this; else if (_this === Sortable.active && putSortable) putSortable = null;
                        if (fromSortable === _this) _this._ignoreWhileAnimating = target;
                        _this.animateAll((function() {
                            dragOverEvent("dragOverAnimationComplete");
                            _this._ignoreWhileAnimating = null;
                        }));
                        if (_this !== fromSortable) {
                            fromSortable.animateAll();
                            fromSortable._ignoreWhileAnimating = null;
                        }
                    }
                    if (target === dragEl && !dragEl.animated || target === el && !target.animated) lastTarget = null;
                    if (!options.dragoverBubble && !evt.rootEl && target !== document) {
                        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
                        !insertion && nearestEmptyInsertDetectEvent(evt);
                    }
                    !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
                    return completedFired = true;
                }
                function changed() {
                    newIndex = index(dragEl);
                    newDraggableIndex = index(dragEl, options.draggable);
                    _dispatchEvent({
                        sortable: _this,
                        name: "change",
                        toEl: el,
                        newIndex,
                        newDraggableIndex,
                        originalEvent: evt
                    });
                }
                if (evt.preventDefault !== void 0) evt.cancelable && evt.preventDefault();
                target = sortable_esm_closest(target, options.draggable, el, true);
                dragOverEvent("dragOver");
                if (Sortable.eventCanceled) return completedFired;
                if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) return completed(false);
                ignoreNextClick = false;
                if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
                    vertical = this._getDirection(evt, target) === "vertical";
                    dragRect = getRect(dragEl);
                    dragOverEvent("dragOverValid");
                    if (Sortable.eventCanceled) return completedFired;
                    if (revert) {
                        parentEl = rootEl;
                        capture();
                        this._hideClone();
                        dragOverEvent("revert");
                        if (!Sortable.eventCanceled) if (nextEl) rootEl.insertBefore(dragEl, nextEl); else rootEl.appendChild(dragEl);
                        return completed(true);
                    }
                    var elLastChild = lastChild(el, options.draggable);
                    if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
                        if (elLastChild === dragEl) return completed(false);
                        if (elLastChild && el === evt.target) target = elLastChild;
                        if (target) targetRect = getRect(target);
                        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
                            capture();
                            if (elLastChild && elLastChild.nextSibling) el.insertBefore(dragEl, elLastChild.nextSibling); else el.appendChild(dragEl);
                            parentEl = el;
                            changed();
                            return completed(true);
                        }
                    } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
                        var firstChild = getChild(el, 0, options, true);
                        if (firstChild === dragEl) return completed(false);
                        target = firstChild;
                        targetRect = getRect(target);
                        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
                            capture();
                            el.insertBefore(dragEl, firstChild);
                            parentEl = el;
                            changed();
                            return completed(true);
                        }
                    } else if (target.parentNode === el) {
                        targetRect = getRect(target);
                        var targetBeforeFirstSwap, direction = 0, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
                        if (lastTarget !== target) {
                            targetBeforeFirstSwap = targetRect[side1];
                            pastFirstInvertThresh = false;
                            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
                        }
                        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
                        var sibling;
                        if (direction !== 0) {
                            var dragIndex = index(dragEl);
                            do {
                                dragIndex -= direction;
                                sibling = parentEl.children[dragIndex];
                            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
                        }
                        if (direction === 0 || sibling === target) return completed(false);
                        lastTarget = target;
                        lastDirection = direction;
                        var nextSibling = target.nextElementSibling, after = false;
                        after = direction === 1;
                        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
                        if (moveVector !== false) {
                            if (moveVector === 1 || moveVector === -1) after = moveVector === 1;
                            _silent = true;
                            setTimeout(_unsilent, 30);
                            capture();
                            if (after && !nextSibling) el.appendChild(dragEl); else target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                            if (scrolledPastTop) scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
                            parentEl = dragEl.parentNode;
                            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
                            changed();
                            return completed(true);
                        }
                    }
                    if (el.contains(dragEl)) return completed(false);
                }
                return false;
            },
            _ignoreWhileAnimating: null,
            _offMoveEvents: function _offMoveEvents() {
                off(document, "mousemove", this._onTouchMove);
                off(document, "touchmove", this._onTouchMove);
                off(document, "pointermove", this._onTouchMove);
                off(document, "dragover", nearestEmptyInsertDetectEvent);
                off(document, "mousemove", nearestEmptyInsertDetectEvent);
                off(document, "touchmove", nearestEmptyInsertDetectEvent);
            },
            _offUpEvents: function _offUpEvents() {
                var ownerDocument = this.el.ownerDocument;
                off(ownerDocument, "mouseup", this._onDrop);
                off(ownerDocument, "touchend", this._onDrop);
                off(ownerDocument, "pointerup", this._onDrop);
                off(ownerDocument, "touchcancel", this._onDrop);
                off(document, "selectstart", this);
            },
            _onDrop: function _onDrop(evt) {
                var el = this.el, options = this.options;
                newIndex = index(dragEl);
                newDraggableIndex = index(dragEl, options.draggable);
                pluginEvent("drop", this, {
                    evt
                });
                parentEl = dragEl && dragEl.parentNode;
                newIndex = index(dragEl);
                newDraggableIndex = index(dragEl, options.draggable);
                if (Sortable.eventCanceled) {
                    this._nulling();
                    return;
                }
                awaitingDragStarted = false;
                isCircumstantialInvert = false;
                pastFirstInvertThresh = false;
                clearInterval(this._loopId);
                clearTimeout(this._dragStartTimer);
                _cancelNextTick(this.cloneId);
                _cancelNextTick(this._dragStartId);
                if (this.nativeDraggable) {
                    off(document, "drop", this);
                    off(el, "dragstart", this._onDragStart);
                }
                this._offMoveEvents();
                this._offUpEvents();
                if (Safari) css(document.body, "user-select", "");
                css(dragEl, "transform", "");
                if (evt) {
                    if (moved) {
                        evt.cancelable && evt.preventDefault();
                        !options.dropBubble && evt.stopPropagation();
                    }
                    ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
                    if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
                    if (dragEl) {
                        if (this.nativeDraggable) off(dragEl, "dragend", this);
                        _disableDraggable(dragEl);
                        dragEl.style["will-change"] = "";
                        if (moved && !awaitingDragStarted) toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
                        toggleClass(dragEl, this.options.chosenClass, false);
                        _dispatchEvent({
                            sortable: this,
                            name: "unchoose",
                            toEl: parentEl,
                            newIndex: null,
                            newDraggableIndex: null,
                            originalEvent: evt
                        });
                        if (rootEl !== parentEl) {
                            if (newIndex >= 0) {
                                _dispatchEvent({
                                    rootEl: parentEl,
                                    name: "add",
                                    toEl: parentEl,
                                    fromEl: rootEl,
                                    originalEvent: evt
                                });
                                _dispatchEvent({
                                    sortable: this,
                                    name: "remove",
                                    toEl: parentEl,
                                    originalEvent: evt
                                });
                                _dispatchEvent({
                                    rootEl: parentEl,
                                    name: "sort",
                                    toEl: parentEl,
                                    fromEl: rootEl,
                                    originalEvent: evt
                                });
                                _dispatchEvent({
                                    sortable: this,
                                    name: "sort",
                                    toEl: parentEl,
                                    originalEvent: evt
                                });
                            }
                            putSortable && putSortable.save();
                        } else if (newIndex !== oldIndex) if (newIndex >= 0) {
                            _dispatchEvent({
                                sortable: this,
                                name: "update",
                                toEl: parentEl,
                                originalEvent: evt
                            });
                            _dispatchEvent({
                                sortable: this,
                                name: "sort",
                                toEl: parentEl,
                                originalEvent: evt
                            });
                        }
                        if (Sortable.active) {
                            if (newIndex == null || newIndex === -1) {
                                newIndex = oldIndex;
                                newDraggableIndex = oldDraggableIndex;
                            }
                            _dispatchEvent({
                                sortable: this,
                                name: "end",
                                toEl: parentEl,
                                originalEvent: evt
                            });
                            this.save();
                        }
                    }
                }
                this._nulling();
            },
            _nulling: function _nulling() {
                pluginEvent("nulling", this);
                rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
                savedInputChecked.forEach((function(el) {
                    el.checked = true;
                }));
                savedInputChecked.length = lastDx = lastDy = 0;
            },
            handleEvent: function handleEvent(evt) {
                switch (evt.type) {
                  case "drop":
                  case "dragend":
                    this._onDrop(evt);
                    break;

                  case "dragenter":
                  case "dragover":
                    if (dragEl) {
                        this._onDragOver(evt);
                        _globalDragOver(evt);
                    }
                    break;

                  case "selectstart":
                    evt.preventDefault();
                    break;
                }
            },
            toArray: function toArray() {
                var el, order = [], children = this.el.children, i = 0, n = children.length, options = this.options;
                for (;i < n; i++) {
                    el = children[i];
                    if (sortable_esm_closest(el, options.draggable, this.el, false)) order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
                }
                return order;
            },
            sort: function sort(order, useAnimation) {
                var items = {}, rootEl = this.el;
                this.toArray().forEach((function(id, i) {
                    var el = rootEl.children[i];
                    if (sortable_esm_closest(el, this.options.draggable, rootEl, false)) items[id] = el;
                }), this);
                useAnimation && this.captureAnimationState();
                order.forEach((function(id) {
                    if (items[id]) {
                        rootEl.removeChild(items[id]);
                        rootEl.appendChild(items[id]);
                    }
                }));
                useAnimation && this.animateAll();
            },
            save: function save() {
                var store = this.options.store;
                store && store.set && store.set(this);
            },
            closest: function closest$1(el, selector) {
                return sortable_esm_closest(el, selector || this.options.draggable, this.el, false);
            },
            option: function option(name, value) {
                var options = this.options;
                if (value === void 0) return options[name]; else {
                    var modifiedValue = PluginManager.modifyOption(this, name, value);
                    if (typeof modifiedValue !== "undefined") options[name] = modifiedValue; else options[name] = value;
                    if (name === "group") _prepareGroup(options);
                }
            },
            destroy: function destroy() {
                pluginEvent("destroy", this);
                var el = this.el;
                el[expando] = null;
                off(el, "mousedown", this._onTapStart);
                off(el, "touchstart", this._onTapStart);
                off(el, "pointerdown", this._onTapStart);
                if (this.nativeDraggable) {
                    off(el, "dragover", this);
                    off(el, "dragenter", this);
                }
                Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), (function(el) {
                    el.removeAttribute("draggable");
                }));
                this._onDrop();
                this._disableDelayedDragEvents();
                sortables.splice(sortables.indexOf(this.el), 1);
                this.el = el = null;
            },
            _hideClone: function _hideClone() {
                if (!cloneHidden) {
                    pluginEvent("hideClone", this);
                    if (Sortable.eventCanceled) return;
                    css(cloneEl, "display", "none");
                    if (this.options.removeCloneOnHide && cloneEl.parentNode) cloneEl.parentNode.removeChild(cloneEl);
                    cloneHidden = true;
                }
            },
            _showClone: function _showClone(putSortable) {
                if (putSortable.lastPutMode !== "clone") {
                    this._hideClone();
                    return;
                }
                if (cloneHidden) {
                    pluginEvent("showClone", this);
                    if (Sortable.eventCanceled) return;
                    if (dragEl.parentNode == rootEl && !this.options.group.revertClone) rootEl.insertBefore(cloneEl, dragEl); else if (nextEl) rootEl.insertBefore(cloneEl, nextEl); else rootEl.appendChild(cloneEl);
                    if (this.options.group.revertClone) this.animate(dragEl, cloneEl);
                    css(cloneEl, "display", "");
                    cloneHidden = false;
                }
            }
        };
        function _globalDragOver(evt) {
            if (evt.dataTransfer) evt.dataTransfer.dropEffect = "move";
            evt.cancelable && evt.preventDefault();
        }
        function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
            var evt, retVal, sortable = fromEl[expando], onMoveFn = sortable.options.onMove;
            if (window.CustomEvent && !IE11OrLess && !Edge) evt = new CustomEvent("move", {
                bubbles: true,
                cancelable: true
            }); else {
                evt = document.createEvent("Event");
                evt.initEvent("move", true, true);
            }
            evt.to = toEl;
            evt.from = fromEl;
            evt.dragged = dragEl;
            evt.draggedRect = dragRect;
            evt.related = targetEl || toEl;
            evt.relatedRect = targetRect || getRect(toEl);
            evt.willInsertAfter = willInsertAfter;
            evt.originalEvent = originalEvent;
            fromEl.dispatchEvent(evt);
            if (onMoveFn) retVal = onMoveFn.call(sortable, evt, originalEvent);
            return retVal;
        }
        function _disableDraggable(el) {
            el.draggable = false;
        }
        function _unsilent() {
            _silent = false;
        }
        function _ghostIsFirst(evt, vertical, sortable) {
            var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
            var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
            var spacer = 10;
            return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
        }
        function _ghostIsLast(evt, vertical, sortable) {
            var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
            var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
            var spacer = 10;
            return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
        }
        function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
            var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
            if (!invertSwap) if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
                if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) pastFirstInvertThresh = true;
                if (!pastFirstInvertThresh) {
                    if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) return -lastDirection;
                } else invert = true;
            } else if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) return _getInsertDirection(target);
            invert = invert || invertSwap;
            if (invert) if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
            return 0;
        }
        function _getInsertDirection(target) {
            if (index(dragEl) < index(target)) return 1; else return -1;
        }
        function _generateId(el) {
            var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum = 0;
            while (i--) sum += str.charCodeAt(i);
            return sum.toString(36);
        }
        function _saveInputCheckedState(root) {
            savedInputChecked.length = 0;
            var inputs = root.getElementsByTagName("input");
            var idx = inputs.length;
            while (idx--) {
                var el = inputs[idx];
                el.checked && savedInputChecked.push(el);
            }
        }
        function _nextTick(fn) {
            return setTimeout(fn, 0);
        }
        function _cancelNextTick(id) {
            return clearTimeout(id);
        }
        if (documentExists) on(document, "touchmove", (function(evt) {
            if ((Sortable.active || awaitingDragStarted) && evt.cancelable) evt.preventDefault();
        }));
        Sortable.utils = {
            on,
            off,
            css,
            find,
            is: function is(el, selector) {
                return !!sortable_esm_closest(el, selector, el, false);
            },
            extend: sortable_esm_extend,
            throttle,
            closest: sortable_esm_closest,
            toggleClass,
            clone,
            index,
            nextTick: _nextTick,
            cancelNextTick: _cancelNextTick,
            detectDirection: _detectDirection,
            getChild
        };
        Sortable.get = function(element) {
            return element[expando];
        };
        Sortable.mount = function() {
            for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) plugins[_key] = arguments[_key];
            if (plugins[0].constructor === Array) plugins = plugins[0];
            plugins.forEach((function(plugin) {
                if (!plugin.prototype || !plugin.prototype.constructor) throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
                if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
                PluginManager.mount(plugin);
            }));
        };
        Sortable.create = function(el, options) {
            return new Sortable(el, options);
        };
        Sortable.version = version;
        var scrollEl, scrollRootEl, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval, autoScrolls = [], scrolling = false;
        function AutoScrollPlugin() {
            function AutoScroll() {
                this.defaults = {
                    scroll: true,
                    forceAutoScrollFallback: false,
                    scrollSensitivity: 30,
                    scrollSpeed: 10,
                    bubbleScroll: true
                };
                for (var fn in this) if (fn.charAt(0) === "_" && typeof this[fn] === "function") this[fn] = this[fn].bind(this);
            }
            AutoScroll.prototype = {
                dragStarted: function dragStarted(_ref) {
                    var originalEvent = _ref.originalEvent;
                    if (this.sortable.nativeDraggable) on(document, "dragover", this._handleAutoScroll); else if (this.options.supportPointer) on(document, "pointermove", this._handleFallbackAutoScroll); else if (originalEvent.touches) on(document, "touchmove", this._handleFallbackAutoScroll); else on(document, "mousemove", this._handleFallbackAutoScroll);
                },
                dragOverCompleted: function dragOverCompleted(_ref2) {
                    var originalEvent = _ref2.originalEvent;
                    if (!this.options.dragOverBubble && !originalEvent.rootEl) this._handleAutoScroll(originalEvent);
                },
                drop: function drop() {
                    if (this.sortable.nativeDraggable) off(document, "dragover", this._handleAutoScroll); else {
                        off(document, "pointermove", this._handleFallbackAutoScroll);
                        off(document, "touchmove", this._handleFallbackAutoScroll);
                        off(document, "mousemove", this._handleFallbackAutoScroll);
                    }
                    clearPointerElemChangedInterval();
                    clearAutoScrolls();
                    cancelThrottle();
                },
                nulling: function nulling() {
                    touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
                    autoScrolls.length = 0;
                },
                _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
                    this._handleAutoScroll(evt, true);
                },
                _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
                    var _this = this;
                    var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
                    touchEvt$1 = evt;
                    if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
                        autoScroll(evt, this.options, elem, fallback);
                        var ogElemScroller = getParentAutoScrollElement(elem, true);
                        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
                            pointerElemChangedInterval && clearPointerElemChangedInterval();
                            pointerElemChangedInterval = setInterval((function() {
                                var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
                                if (newElem !== ogElemScroller) {
                                    ogElemScroller = newElem;
                                    clearAutoScrolls();
                                }
                                autoScroll(evt, _this.options, newElem, fallback);
                            }), 10);
                            lastAutoScrollX = x;
                            lastAutoScrollY = y;
                        }
                    } else {
                        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
                            clearAutoScrolls();
                            return;
                        }
                        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
                    }
                }
            };
            return _extends(AutoScroll, {
                pluginName: "scroll",
                initializeByDefault: true
            });
        }
        function clearAutoScrolls() {
            autoScrolls.forEach((function(autoScroll) {
                clearInterval(autoScroll.pid);
            }));
            autoScrolls = [];
        }
        function clearPointerElemChangedInterval() {
            clearInterval(pointerElemChangedInterval);
        }
        var autoScroll = throttle((function(evt, options, rootEl, isFallback) {
            if (!options.scroll) return;
            var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
            var scrollCustomFn, scrollThisInstance = false;
            if (scrollRootEl !== rootEl) {
                scrollRootEl = rootEl;
                clearAutoScrolls();
                scrollEl = options.scroll;
                scrollCustomFn = options.scrollFn;
                if (scrollEl === true) scrollEl = getParentAutoScrollElement(rootEl, true);
            }
            var layersOut = 0;
            var currentParent = scrollEl;
            do {
                var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
                if (el === winScroller) {
                    canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
                    canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
                } else {
                    canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
                    canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
                }
                var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
                var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
                if (!autoScrolls[layersOut]) for (var i = 0; i <= layersOut; i++) if (!autoScrolls[i]) autoScrolls[i] = {};
                if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
                    autoScrolls[layersOut].el = el;
                    autoScrolls[layersOut].vx = vx;
                    autoScrolls[layersOut].vy = vy;
                    clearInterval(autoScrolls[layersOut].pid);
                    if (vx != 0 || vy != 0) {
                        scrollThisInstance = true;
                        autoScrolls[layersOut].pid = setInterval(function() {
                            if (isFallback && this.layer === 0) Sortable.active._onTouchMove(touchEvt$1);
                            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
                            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
                            if (typeof scrollCustomFn === "function") if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") return;
                            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
                        }.bind({
                            layer: layersOut
                        }), 24);
                    }
                }
                layersOut++;
            } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
            scrolling = scrollThisInstance;
        }), 30);
        var drop = function drop(_ref) {
            var originalEvent = _ref.originalEvent, putSortable = _ref.putSortable, dragEl = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
            if (!originalEvent) return;
            var toSortable = putSortable || activeSortable;
            hideGhostForTarget();
            var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
            var target = document.elementFromPoint(touch.clientX, touch.clientY);
            unhideGhostForTarget();
            if (toSortable && !toSortable.el.contains(target)) {
                dispatchSortableEvent("spill");
                this.onSpill({
                    dragEl,
                    putSortable
                });
            }
        };
        function Revert() {}
        Revert.prototype = {
            startIndex: null,
            dragStart: function dragStart(_ref2) {
                var oldDraggableIndex = _ref2.oldDraggableIndex;
                this.startIndex = oldDraggableIndex;
            },
            onSpill: function onSpill(_ref3) {
                var dragEl = _ref3.dragEl, putSortable = _ref3.putSortable;
                this.sortable.captureAnimationState();
                if (putSortable) putSortable.captureAnimationState();
                var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
                if (nextSibling) this.sortable.el.insertBefore(dragEl, nextSibling); else this.sortable.el.appendChild(dragEl);
                this.sortable.animateAll();
                if (putSortable) putSortable.animateAll();
            },
            drop
        };
        _extends(Revert, {
            pluginName: "revertOnSpill"
        });
        function Remove() {}
        Remove.prototype = {
            onSpill: function onSpill(_ref4) {
                var dragEl = _ref4.dragEl, putSortable = _ref4.putSortable;
                var parentSortable = putSortable || this.sortable;
                parentSortable.captureAnimationState();
                dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
                parentSortable.animateAll();
            },
            drop
        };
        _extends(Remove, {
            pluginName: "removeOnSpill"
        });
        Sortable.mount(new AutoScrollPlugin);
        Sortable.mount(Remove, Revert);
        const sortable_esm = Sortable;
        const t = (t, e = 1e4) => (t = parseFloat(t + "") || 0, Math.round((t + Number.EPSILON) * e) / e), e = function(t) {
            if (!(t && t instanceof Element && t.offsetParent)) return !1;
            const e = t.scrollHeight > t.clientHeight, i = window.getComputedStyle(t).overflowY, n = -1 !== i.indexOf("hidden"), s = -1 !== i.indexOf("visible");
            return e && !n && !s;
        }, i = function(t, n = void 0) {
            return !(!t || t === document.body || n && t === n) && (e(t) ? t : i(t.parentElement, n));
        }, n = function(t) {
            var e = (new DOMParser).parseFromString(t, "text/html").body;
            if (e.childElementCount > 1) {
                for (var i = document.createElement("div"); e.firstChild; ) i.appendChild(e.firstChild);
                return i;
            }
            return e.firstChild;
        }, s = t => `${t || ""}`.split(" ").filter((t => !!t)), o = (t, e, i) => {
            t && s(e).forEach((e => {
                t.classList.toggle(e, i || !1);
            }));
        };
        class a {
            constructor(t) {
                Object.defineProperty(this, "pageX", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "pageY", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "clientX", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "clientY", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "id", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "time", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "nativePointer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), this.nativePointer = t, this.pageX = t.pageX, this.pageY = t.pageY, this.clientX = t.clientX, 
                this.clientY = t.clientY, this.id = self.Touch && t instanceof Touch ? t.identifier : -1, 
                this.time = Date.now();
            }
        }
        const r = {
            passive: !1
        };
        class l {
            constructor(t, {start: e = (() => !0), move: i = (() => {}), end: n = (() => {})}) {
                Object.defineProperty(this, "element", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "startCallback", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "moveCallback", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "endCallback", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "currentPointers", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "startPointers", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), this.element = t, this.startCallback = e, this.moveCallback = i, this.endCallback = n;
                for (const t of [ "onPointerStart", "onTouchStart", "onMove", "onTouchEnd", "onPointerEnd", "onWindowBlur" ]) this[t] = this[t].bind(this);
                this.element.addEventListener("mousedown", this.onPointerStart, r), this.element.addEventListener("touchstart", this.onTouchStart, r), 
                this.element.addEventListener("touchmove", this.onMove, r), this.element.addEventListener("touchend", this.onTouchEnd), 
                this.element.addEventListener("touchcancel", this.onTouchEnd);
            }
            onPointerStart(t) {
                if (!t.buttons || 0 !== t.button) return;
                const e = new a(t);
                this.currentPointers.some((t => t.id === e.id)) || this.triggerPointerStart(e, t) && (window.addEventListener("mousemove", this.onMove), 
                window.addEventListener("mouseup", this.onPointerEnd), window.addEventListener("blur", this.onWindowBlur));
            }
            onTouchStart(t) {
                for (const e of Array.from(t.changedTouches || [])) this.triggerPointerStart(new a(e), t);
                window.addEventListener("blur", this.onWindowBlur);
            }
            onMove(t) {
                const e = this.currentPointers.slice(), i = "changedTouches" in t ? Array.from(t.changedTouches || []).map((t => new a(t))) : [ new a(t) ], n = [];
                for (const t of i) {
                    const e = this.currentPointers.findIndex((e => e.id === t.id));
                    e < 0 || (n.push(t), this.currentPointers[e] = t);
                }
                n.length && this.moveCallback(t, this.currentPointers.slice(), e);
            }
            onPointerEnd(t) {
                t.buttons > 0 && 0 !== t.button || (this.triggerPointerEnd(t, new a(t)), window.removeEventListener("mousemove", this.onMove), 
                window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur));
            }
            onTouchEnd(t) {
                for (const e of Array.from(t.changedTouches || [])) this.triggerPointerEnd(t, new a(e));
            }
            triggerPointerStart(t, e) {
                return !!this.startCallback(e, t, this.currentPointers.slice()) && (this.currentPointers.push(t), 
                this.startPointers.push(t), !0);
            }
            triggerPointerEnd(t, e) {
                const i = this.currentPointers.findIndex((t => t.id === e.id));
                i < 0 || (this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this.endCallback(t, e, this.currentPointers.slice()));
            }
            onWindowBlur() {
                this.clear();
            }
            clear() {
                for (;this.currentPointers.length; ) {
                    const t = this.currentPointers[this.currentPointers.length - 1];
                    this.currentPointers.splice(this.currentPointers.length - 1, 1), this.startPointers.splice(this.currentPointers.length - 1, 1), 
                    this.endCallback(new Event("touchend", {
                        bubbles: !0,
                        cancelable: !0,
                        clientX: t.clientX,
                        clientY: t.clientY
                    }), t, this.currentPointers.slice());
                }
            }
            stop() {
                this.element.removeEventListener("mousedown", this.onPointerStart, r), this.element.removeEventListener("touchstart", this.onTouchStart, r), 
                this.element.removeEventListener("touchmove", this.onMove, r), this.element.removeEventListener("touchend", this.onTouchEnd), 
                this.element.removeEventListener("touchcancel", this.onTouchEnd), window.removeEventListener("mousemove", this.onMove), 
                window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur);
            }
        }
        function c(t, e) {
            return e ? Math.sqrt(Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)) : 0;
        }
        function h(t, e) {
            return e ? {
                clientX: (t.clientX + e.clientX) / 2,
                clientY: (t.clientY + e.clientY) / 2
            } : t;
        }
        const d = t => "object" == typeof t && null !== t && t.constructor === Object && "[object Object]" === Object.prototype.toString.call(t), u = (t, ...e) => {
            const i = e.length;
            for (let n = 0; n < i; n++) {
                const i = e[n] || {};
                Object.entries(i).forEach((([e, i]) => {
                    const n = Array.isArray(i) ? [] : {};
                    t[e] || Object.assign(t, {
                        [e]: n
                    }), d(i) ? Object.assign(t[e], u(n, i)) : Array.isArray(i) ? Object.assign(t, {
                        [e]: [ ...i ]
                    }) : Object.assign(t, {
                        [e]: i
                    });
                }));
            }
            return t;
        }, p = function(t, e) {
            return t.split(".").reduce(((t, e) => "object" == typeof t ? t[e] : void 0), e);
        };
        class f {
            constructor(t = {}) {
                Object.defineProperty(this, "options", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }), Object.defineProperty(this, "events", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: new Map
                }), this.setOptions(t);
                for (const t of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) t.startsWith("on") && "function" == typeof this[t] && (this[t] = this[t].bind(this));
            }
            setOptions(t) {
                this.options = t ? u({}, this.constructor.defaults, t) : {};
                for (const [t, e] of Object.entries(this.option("on") || {})) this.on(t, e);
            }
            option(t, ...e) {
                let i = p(t, this.options);
                return i && "function" == typeof i && (i = i.call(this, this, ...e)), i;
            }
            optionFor(t, e, i, ...n) {
                let s = p(e, t);
                var o;
                "string" != typeof (o = s) || isNaN(o) || isNaN(parseFloat(o)) || (s = parseFloat(s)), 
                "true" === s && (s = !0), "false" === s && (s = !1), s && "function" == typeof s && (s = s.call(this, this, t, ...n));
                let a = p(e, this.options);
                return a && "function" == typeof a ? s = a.call(this, this, t, ...n, s) : void 0 === s && (s = a), 
                void 0 === s ? i : s;
            }
            cn(t) {
                const e = this.options.classes;
                return e && e[t] || "";
            }
            localize(t, e = []) {
                t = String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g, ((t, e, i) => {
                    let n = "";
                    return i ? n = this.option(`${e[0] + e.toLowerCase().substring(1)}.l10n.${i}`) : e && (n = this.option(`l10n.${e}`)), 
                    n || (n = t), n;
                }));
                for (let i = 0; i < e.length; i++) t = t.split(e[i][0]).join(e[i][1]);
                return t = t.replace(/\{\{(.*?)\}\}/g, ((t, e) => e));
            }
            on(t, e) {
                let i = [];
                "string" == typeof t ? i = t.split(" ") : Array.isArray(t) && (i = t), this.events || (this.events = new Map), 
                i.forEach((t => {
                    let i = this.events.get(t);
                    i || (this.events.set(t, []), i = []), i.includes(e) || i.push(e), this.events.set(t, i);
                }));
            }
            off(t, e) {
                let i = [];
                "string" == typeof t ? i = t.split(" ") : Array.isArray(t) && (i = t), i.forEach((t => {
                    const i = this.events.get(t);
                    if (Array.isArray(i)) {
                        const t = i.indexOf(e);
                        t > -1 && i.splice(t, 1);
                    }
                }));
            }
            emit(t, ...e) {
                [ ...this.events.get(t) || [] ].forEach((t => t(this, ...e))), "*" !== t && this.emit("*", t, ...e);
            }
        }
        Object.defineProperty(f, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "5.0.36"
        }), Object.defineProperty(f, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {}
        });
        class g extends f {
            constructor(t = {}) {
                super(t), Object.defineProperty(this, "plugins", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                });
            }
            attachPlugins(t = {}) {
                const e = new Map;
                for (const [i, n] of Object.entries(t)) {
                    const t = this.option(i), s = this.plugins[i];
                    s || !1 === t ? s && !1 === t && (s.detach(), delete this.plugins[i]) : e.set(i, new n(this, t || {}));
                }
                for (const [t, i] of e) this.plugins[t] = i, i.attach();
            }
            detachPlugins(t) {
                t = t || Object.keys(this.plugins);
                for (const e of t) {
                    const t = this.plugins[e];
                    t && t.detach(), delete this.plugins[e];
                }
                return this.emit("detachPlugins"), this;
            }
        }
        var m;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Error = 1] = "Error", t[t.Ready = 2] = "Ready", t[t.Panning = 3] = "Panning", 
            t[t.Mousemove = 4] = "Mousemove", t[t.Destroy = 5] = "Destroy";
        }(m || (m = {}));
        const v = [ "a", "b", "c", "d", "e", "f" ], b = {
            PANUP: "Move up",
            PANDOWN: "Move down",
            PANLEFT: "Move left",
            PANRIGHT: "Move right",
            ZOOMIN: "Zoom in",
            ZOOMOUT: "Zoom out",
            TOGGLEZOOM: "Toggle zoom level",
            TOGGLE1TO1: "Toggle zoom level",
            ITERATEZOOM: "Toggle zoom level",
            ROTATECCW: "Rotate counterclockwise",
            ROTATECW: "Rotate clockwise",
            FLIPX: "Flip horizontally",
            FLIPY: "Flip vertically",
            FITX: "Fit horizontally",
            FITY: "Fit vertically",
            RESET: "Reset",
            TOGGLEFS: "Toggle fullscreen"
        }, y = {
            content: null,
            width: "auto",
            height: "auto",
            panMode: "drag",
            touch: !0,
            dragMinThreshold: 3,
            lockAxis: !1,
            mouseMoveFactor: 1,
            mouseMoveFriction: .12,
            zoom: !0,
            pinchToZoom: !0,
            panOnlyZoomed: "auto",
            minScale: 1,
            maxScale: 2,
            friction: .25,
            dragFriction: .35,
            decelFriction: .05,
            click: "toggleZoom",
            dblClick: !1,
            wheel: "zoom",
            wheelLimit: 7,
            spinner: !0,
            bounds: "auto",
            infinite: !1,
            rubberband: !0,
            bounce: !0,
            maxVelocity: 75,
            transformParent: !1,
            classes: {
                content: "f-panzoom__content",
                isLoading: "is-loading",
                canZoomIn: "can-zoom_in",
                canZoomOut: "can-zoom_out",
                isDraggable: "is-draggable",
                isDragging: "is-dragging",
                inFullscreen: "in-fullscreen",
                htmlHasFullscreen: "with-panzoom-in-fullscreen"
            },
            l10n: b
        }, w = '<circle cx="25" cy="25" r="20"></circle>', x = '<div class="f-spinner"><svg viewBox="0 0 50 50">' + w + w + "</svg></div>", E = t => t && null !== t && t instanceof Element && "nodeType" in t, S = (t, e) => {
            t && s(e).forEach((e => {
                t.classList.remove(e);
            }));
        }, P = (t, e) => {
            t && s(e).forEach((e => {
                t.classList.add(e);
            }));
        }, C = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0
        }, T = 1e5, M = 1e4, O = "mousemove", A = "drag", L = "content", z = "auto";
        let R = null, k = null;
        class I extends g {
            get fits() {
                return this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1;
            }
            get isTouchDevice() {
                return null === k && (k = window.matchMedia("(hover: none)").matches), k;
            }
            get isMobile() {
                return null === R && (R = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)), 
                R;
            }
            get panMode() {
                return this.options.panMode !== O || this.isTouchDevice ? A : O;
            }
            get panOnlyZoomed() {
                const t = this.options.panOnlyZoomed;
                return t === z ? this.isTouchDevice : t;
            }
            get isInfinite() {
                return this.option("infinite");
            }
            get angle() {
                return 180 * Math.atan2(this.current.b, this.current.a) / Math.PI || 0;
            }
            get targetAngle() {
                return 180 * Math.atan2(this.target.b, this.target.a) / Math.PI || 0;
            }
            get scale() {
                const {a: t, b: e} = this.current;
                return Math.sqrt(t * t + e * e) || 1;
            }
            get targetScale() {
                const {a: t, b: e} = this.target;
                return Math.sqrt(t * t + e * e) || 1;
            }
            get minScale() {
                return this.option("minScale") || 1;
            }
            get fullScale() {
                const {contentRect: t} = this;
                return t.fullWidth / t.fitWidth || 1;
            }
            get maxScale() {
                return this.fullScale * (this.option("maxScale") || 1) || 1;
            }
            get coverScale() {
                const {containerRect: t, contentRect: e} = this, i = Math.max(t.height / e.fitHeight, t.width / e.fitWidth) || 1;
                return Math.min(this.fullScale, i);
            }
            get isScaling() {
                return Math.abs(this.targetScale - this.scale) > 1e-5 && !this.isResting;
            }
            get isContentLoading() {
                const t = this.content;
                return !!(t && t instanceof HTMLImageElement) && !t.complete;
            }
            get isResting() {
                if (this.isBouncingX || this.isBouncingY) return !1;
                for (const t of v) {
                    const e = "e" == t || "f" === t ? 1e-4 : 1e-5;
                    if (Math.abs(this.target[t] - this.current[t]) > e) return !1;
                }
                return !(!this.ignoreBounds && !this.checkBounds().inBounds);
            }
            constructor(t, e = {}, i = {}) {
                var s;
                if (super(e), Object.defineProperty(this, "pointerTracker", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "resizeObserver", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "updateTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "clickTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "rAF", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "isTicking", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "ignoreBounds", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "isBouncingX", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "isBouncingY", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "clicks", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "trackingPoints", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "pwt", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "cwd", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "pmme", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "friction", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: m.Init
                }), Object.defineProperty(this, "isDragging", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "content", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "spinner", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "containerRect", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        width: 0,
                        height: 0,
                        innerWidth: 0,
                        innerHeight: 0
                    }
                }), Object.defineProperty(this, "contentRect", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0,
                        fullWidth: 0,
                        fullHeight: 0,
                        fitWidth: 0,
                        fitHeight: 0,
                        width: 0,
                        height: 0
                    }
                }), Object.defineProperty(this, "dragStart", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        x: 0,
                        y: 0,
                        top: 0,
                        left: 0,
                        time: 0
                    }
                }), Object.defineProperty(this, "dragOffset", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        x: 0,
                        y: 0,
                        time: 0
                    }
                }), Object.defineProperty(this, "current", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Object.assign({}, C)
                }), Object.defineProperty(this, "target", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Object.assign({}, C)
                }), Object.defineProperty(this, "velocity", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        a: 0,
                        b: 0,
                        c: 0,
                        d: 0,
                        e: 0,
                        f: 0
                    }
                }), Object.defineProperty(this, "lockedAxis", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), !t) throw new Error("Container Element Not Found");
                this.container = t, this.initContent(), this.attachPlugins(Object.assign(Object.assign({}, I.Plugins), i)), 
                this.emit("attachPlugins"), this.emit("init");
                const o = this.content;
                if (o.addEventListener("load", this.onLoad), o.addEventListener("error", this.onError), 
                this.isContentLoading) {
                    if (this.option("spinner")) {
                        t.classList.add(this.cn("isLoading"));
                        const e = n(x);
                        !t.contains(o) || o.parentElement instanceof HTMLPictureElement ? this.spinner = t.appendChild(e) : this.spinner = (null === (s = o.parentElement) || void 0 === s ? void 0 : s.insertBefore(e, o)) || null;
                    }
                    this.emit("beforeLoad");
                } else queueMicrotask((() => {
                    this.enable();
                }));
            }
            initContent() {
                const {container: t} = this, e = this.cn(L);
                let i = this.option(L) || t.querySelector(`.${e}`);
                if (i || (i = t.querySelector("img,picture") || t.firstElementChild, i && P(i, e)), 
                i instanceof HTMLPictureElement && (i = i.querySelector("img")), !i) throw new Error("No content found");
                this.content = i;
            }
            onLoad() {
                const {spinner: t, container: e, state: i} = this;
                t && (t.remove(), this.spinner = null), this.option("spinner") && e.classList.remove(this.cn("isLoading")), 
                this.emit("afterLoad"), i === m.Init ? this.enable() : this.updateMetrics();
            }
            onError() {
                this.state !== m.Destroy && (this.spinner && (this.spinner.remove(), this.spinner = null), 
                this.stop(), this.detachEvents(), this.state = m.Error, this.emit("error"));
            }
            getNextScale(t) {
                const {fullScale: e, targetScale: i, coverScale: n, maxScale: s, minScale: o} = this;
                let a = o;
                switch (t) {
                  case "toggleMax":
                    a = i - o < .5 * (s - o) ? s : o;
                    break;

                  case "toggleCover":
                    a = i - o < .5 * (n - o) ? n : o;
                    break;

                  case "toggleZoom":
                    a = i - o < .5 * (e - o) ? e : o;
                    break;

                  case "iterateZoom":
                    let t = [ 1, e, s ].sort(((t, e) => t - e)), r = t.findIndex((t => t > i + 1e-5));
                    a = t[r] || 1;
                }
                return a;
            }
            attachObserver() {
                var t;
                const e = () => {
                    const {container: t, containerRect: e} = this;
                    return Math.abs(e.width - t.getBoundingClientRect().width) > .1 || Math.abs(e.height - t.getBoundingClientRect().height) > .1;
                };
                this.resizeObserver || void 0 === window.ResizeObserver || (this.resizeObserver = new ResizeObserver((() => {
                    this.updateTimer || (e() ? (this.onResize(), this.isMobile && (this.updateTimer = setTimeout((() => {
                        e() && this.onResize(), this.updateTimer = null;
                    }), 500))) : this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null));
                }))), null === (t = this.resizeObserver) || void 0 === t || t.observe(this.container);
            }
            detachObserver() {
                var t;
                null === (t = this.resizeObserver) || void 0 === t || t.disconnect();
            }
            attachEvents() {
                const {container: t} = this;
                t.addEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), t.addEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.pointerTracker = new l(t, {
                    start: this.onPointerDown,
                    move: this.onPointerMove,
                    end: this.onPointerUp
                }), document.addEventListener(O, this.onMouseMove);
            }
            detachEvents() {
                var t;
                const {container: e} = this;
                e.removeEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), e.removeEventListener("wheel", this.onWheel, {
                    passive: !1
                }), null === (t = this.pointerTracker) || void 0 === t || t.stop(), this.pointerTracker = null, 
                document.removeEventListener(O, this.onMouseMove), document.removeEventListener("keydown", this.onKeydown, !0), 
                this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null), this.updateTimer && (clearTimeout(this.updateTimer), 
                this.updateTimer = null);
            }
            animate() {
                this.setTargetForce();
                const t = this.friction, e = this.option("maxVelocity");
                for (const i of v) t ? (this.velocity[i] *= 1 - t, e && !this.isScaling && (this.velocity[i] = Math.max(Math.min(this.velocity[i], e), -1 * e)), 
                this.current[i] += this.velocity[i]) : this.current[i] = this.target[i];
                this.setTransform(), this.setEdgeForce(), !this.isResting || this.isDragging ? this.rAF = requestAnimationFrame((() => this.animate())) : this.stop("current");
            }
            setTargetForce() {
                for (const t of v) "e" === t && this.isBouncingX || "f" === t && this.isBouncingY || (this.velocity[t] = (1 / (1 - this.friction) - 1) * (this.target[t] - this.current[t]));
            }
            checkBounds(t = 0, e = 0) {
                const {current: i} = this, n = i.e + t, s = i.f + e, o = this.getBounds(), {x: a, y: r} = o, l = a.min, c = a.max, h = r.min, d = r.max;
                let u = 0, p = 0;
                return l !== 1 / 0 && n < l ? u = l - n : c !== 1 / 0 && n > c && (u = c - n), h !== 1 / 0 && s < h ? p = h - s : d !== 1 / 0 && s > d && (p = d - s), 
                Math.abs(u) < 1e-4 && (u = 0), Math.abs(p) < 1e-4 && (p = 0), Object.assign(Object.assign({}, o), {
                    xDiff: u,
                    yDiff: p,
                    inBounds: !u && !p
                });
            }
            clampTargetBounds() {
                const {target: t} = this, {x: e, y: i} = this.getBounds();
                e.min !== 1 / 0 && (t.e = Math.max(t.e, e.min)), e.max !== 1 / 0 && (t.e = Math.min(t.e, e.max)), 
                i.min !== 1 / 0 && (t.f = Math.max(t.f, i.min)), i.max !== 1 / 0 && (t.f = Math.min(t.f, i.max));
            }
            calculateContentDim(t = this.current) {
                const {content: e, contentRect: i} = this, {fitWidth: n, fitHeight: s, fullWidth: o, fullHeight: a} = i;
                let r = o, l = a;
                if (this.option("zoom") || 0 !== this.angle) {
                    const i = !(e instanceof HTMLImageElement) && ("none" === window.getComputedStyle(e).maxWidth || "none" === window.getComputedStyle(e).maxHeight), c = i ? o : n, h = i ? a : s, d = this.getMatrix(t), u = new DOMPoint(0, 0).matrixTransform(d), p = new DOMPoint(0 + c, 0).matrixTransform(d), f = new DOMPoint(0 + c, 0 + h).matrixTransform(d), g = new DOMPoint(0, 0 + h).matrixTransform(d), m = Math.abs(f.x - u.x), v = Math.abs(f.y - u.y), b = Math.abs(g.x - p.x), y = Math.abs(g.y - p.y);
                    r = Math.max(m, b), l = Math.max(v, y);
                }
                return {
                    contentWidth: r,
                    contentHeight: l
                };
            }
            setEdgeForce() {
                if (this.ignoreBounds || this.isDragging || this.panMode === O || this.targetScale < this.scale) return this.isBouncingX = !1, 
                void (this.isBouncingY = !1);
                const {target: t} = this, {x: e, y: i, xDiff: n, yDiff: s} = this.checkBounds();
                const o = this.option("maxVelocity");
                let a = this.velocity.e, r = this.velocity.f;
                0 !== n ? (this.isBouncingX = !0, n * a <= 0 ? a += .14 * n : (a = .14 * n, e.min !== 1 / 0 && (this.target.e = Math.max(t.e, e.min)), 
                e.max !== 1 / 0 && (this.target.e = Math.min(t.e, e.max))), o && (a = Math.max(Math.min(a, o), -1 * o))) : this.isBouncingX = !1, 
                0 !== s ? (this.isBouncingY = !0, s * r <= 0 ? r += .14 * s : (r = .14 * s, i.min !== 1 / 0 && (this.target.f = Math.max(t.f, i.min)), 
                i.max !== 1 / 0 && (this.target.f = Math.min(t.f, i.max))), o && (r = Math.max(Math.min(r, o), -1 * o))) : this.isBouncingY = !1, 
                this.isBouncingX && (this.velocity.e = a), this.isBouncingY && (this.velocity.f = r);
            }
            enable() {
                const {content: t} = this, e = new DOMMatrixReadOnly(window.getComputedStyle(t).transform);
                for (const t of v) this.current[t] = this.target[t] = e[t];
                this.updateMetrics(), this.attachObserver(), this.attachEvents(), this.state = m.Ready, 
                this.emit("ready");
            }
            onClick(t) {
                var e;
                "click" === t.type && 0 === t.detail && (this.dragOffset.x = 0, this.dragOffset.y = 0), 
                this.isDragging && (null === (e = this.pointerTracker) || void 0 === e || e.clear(), 
                this.trackingPoints = [], this.startDecelAnim());
                const i = t.target;
                if (!i || t.defaultPrevented) return;
                if (i.hasAttribute("disabled")) return t.preventDefault(), void t.stopPropagation();
                if ((() => {
                    const t = window.getSelection();
                    return t && "Range" === t.type;
                })() && !i.closest("button")) return;
                const n = i.closest("[data-panzoom-action]"), s = i.closest("[data-panzoom-change]"), o = n || s, a = o && E(o) ? o.dataset : null;
                if (a) {
                    const e = a.panzoomChange, i = a.panzoomAction;
                    if ((e || i) && t.preventDefault(), e) {
                        let t = {};
                        try {
                            t = JSON.parse(e);
                        } catch (t) {
                            console && console.warn("The given data was not valid JSON");
                        }
                        return void this.applyChange(t);
                    }
                    if (i) return void (this[i] && this[i]());
                }
                if (Math.abs(this.dragOffset.x) > 3 || Math.abs(this.dragOffset.y) > 3) return t.preventDefault(), 
                void t.stopPropagation();
                if (i.closest("[data-fancybox]")) return;
                const r = this.content.getBoundingClientRect(), l = this.dragStart;
                if (l.time && !this.canZoomOut() && (Math.abs(r.x - l.x) > 2 || Math.abs(r.y - l.y) > 2)) return;
                this.dragStart.time = 0;
                const c = e => {
                    this.option("zoom", t) && e && "string" == typeof e && /(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(e) && "function" == typeof this[e] && (t.preventDefault(), 
                    this[e]({
                        event: t
                    }));
                }, h = this.option("click", t), d = this.option("dblClick", t);
                d ? (this.clicks++, 1 == this.clicks && (this.clickTimer = setTimeout((() => {
                    1 === this.clicks ? (this.emit("click", t), !t.defaultPrevented && h && c(h)) : (this.emit("dblClick", t), 
                    t.defaultPrevented || c(d)), this.clicks = 0, this.clickTimer = null;
                }), 350))) : (this.emit("click", t), !t.defaultPrevented && h && c(h));
            }
            addTrackingPoint(t) {
                const e = this.trackingPoints.filter((t => t.time > Date.now() - 100));
                e.push(t), this.trackingPoints = e;
            }
            onPointerDown(t, e, i) {
                var n;
                if (!1 === this.option("touch", t)) return !1;
                this.pwt = 0, this.dragOffset = {
                    x: 0,
                    y: 0,
                    time: 0
                }, this.trackingPoints = [];
                const s = this.content.getBoundingClientRect();
                if (this.dragStart = {
                    x: s.x,
                    y: s.y,
                    top: s.top,
                    left: s.left,
                    time: Date.now()
                }, this.clickTimer) return !1;
                if (this.panMode === O && this.targetScale > 1) return t.preventDefault(), t.stopPropagation(), 
                !1;
                const o = t.composedPath()[0];
                if (!i.length) {
                    if ([ "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO", "IFRAME" ].includes(o.nodeName) || o.closest("[contenteditable],[data-selectable],[data-draggable],[data-clickable],[data-panzoom-change],[data-panzoom-action]")) return !1;
                    null === (n = window.getSelection()) || void 0 === n || n.removeAllRanges();
                }
                if ("mousedown" === t.type) [ "A", "BUTTON" ].includes(o.nodeName) || t.preventDefault(); else if (Math.abs(this.velocity.a) > .3) return !1;
                return this.target.e = this.current.e, this.target.f = this.current.f, this.stop(), 
                this.isDragging || (this.isDragging = !0, this.addTrackingPoint(e), this.emit("touchStart", t)), 
                !0;
            }
            onPointerMove(e, n, s) {
                if (!1 === this.option("touch", e)) return;
                if (!this.isDragging) return;
                if (n.length < 2 && this.panOnlyZoomed && t(this.targetScale) <= t(this.minScale)) return;
                if (this.emit("touchMove", e), e.defaultPrevented) return;
                this.addTrackingPoint(n[0]);
                const {content: o} = this, a = h(s[0], s[1]), r = h(n[0], n[1]);
                let l = 0, d = 0;
                if (n.length > 1) {
                    const t = o.getBoundingClientRect();
                    l = a.clientX - t.left - .5 * t.width, d = a.clientY - t.top - .5 * t.height;
                }
                const u = c(s[0], s[1]), p = c(n[0], n[1]);
                let f = u ? p / u : 1, g = r.clientX - a.clientX, m = r.clientY - a.clientY;
                this.dragOffset.x += g, this.dragOffset.y += m, this.dragOffset.time = Date.now() - this.dragStart.time;
                let v = t(this.targetScale) === t(this.minScale) && this.option("lockAxis");
                if (v && !this.lockedAxis) if ("xy" === v || "y" === v || "touchmove" === e.type) {
                    if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void e.preventDefault();
                    const t = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
                    this.lockedAxis = t > 45 && t < 135 ? "y" : "x", this.dragOffset.x = 0, this.dragOffset.y = 0, 
                    g = 0, m = 0;
                } else this.lockedAxis = v;
                if (i(e.target, this.content) && (v = "x", this.dragOffset.y = 0), v && "xy" !== v && this.lockedAxis !== v && t(this.targetScale) === t(this.minScale)) return;
                e.cancelable && e.preventDefault(), this.container.classList.add(this.cn("isDragging"));
                const b = this.checkBounds(g, m);
                this.option("rubberband") ? ("x" !== this.isInfinite && (b.xDiff > 0 && g < 0 || b.xDiff < 0 && g > 0) && (g *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitWidth * b.xDiff))), 
                "y" !== this.isInfinite && (b.yDiff > 0 && m < 0 || b.yDiff < 0 && m > 0) && (m *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitHeight * b.yDiff)))) : (b.xDiff && (g = 0), 
                b.yDiff && (m = 0));
                const y = this.targetScale, w = this.minScale, x = this.maxScale;
                y < .5 * w && (f = Math.max(f, w)), y > 1.5 * x && (f = Math.min(f, x)), "y" === this.lockedAxis && t(y) === t(w) && (g = 0), 
                "x" === this.lockedAxis && t(y) === t(w) && (m = 0), this.applyChange({
                    originX: l,
                    originY: d,
                    panX: g,
                    panY: m,
                    scale: f,
                    friction: this.option("dragFriction"),
                    ignoreBounds: !0
                });
            }
            onPointerUp(t, e, n) {
                if (n.length) return this.dragOffset.x = 0, this.dragOffset.y = 0, void (this.trackingPoints = []);
                this.container.classList.remove(this.cn("isDragging")), this.isDragging && (this.addTrackingPoint(e), 
                this.panOnlyZoomed && this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1 && (this.trackingPoints = []), 
                i(t.target, this.content) && "y" === this.lockedAxis && (this.trackingPoints = []), 
                this.emit("touchEnd", t), this.isDragging = !1, this.lockedAxis = !1, this.state !== m.Destroy && (t.defaultPrevented || this.startDecelAnim()));
            }
            startDecelAnim() {
                var e;
                const i = this.isScaling;
                this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = !1, 
                this.isBouncingY = !1;
                for (const t of v) this.velocity[t] = 0;
                this.target.e = this.current.e, this.target.f = this.current.f, S(this.container, "is-scaling"), 
                S(this.container, "is-animating"), this.isTicking = !1;
                const {trackingPoints: n} = this, s = n[0], o = n[n.length - 1];
                let a = 0, r = 0, l = 0;
                o && s && (a = o.clientX - s.clientX, r = o.clientY - s.clientY, l = o.time - s.time);
                const c = (null === (e = window.visualViewport) || void 0 === e ? void 0 : e.scale) || 1;
                1 !== c && (a *= c, r *= c);
                let h = 0, d = 0, u = 0, p = 0, f = this.option("decelFriction");
                const g = this.targetScale;
                if (l > 0) {
                    u = Math.abs(a) > 3 ? a / (l / 30) : 0, p = Math.abs(r) > 3 ? r / (l / 30) : 0;
                    const t = this.option("maxVelocity");
                    t && (u = Math.max(Math.min(u, t), -1 * t), p = Math.max(Math.min(p, t), -1 * t));
                }
                u && (h = u / (1 / (1 - f) - 1)), p && (d = p / (1 / (1 - f) - 1)), ("y" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "y" === this.lockedAxis && t(g) === this.minScale) && (h = u = 0), 
                ("x" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "x" === this.lockedAxis && t(g) === this.minScale) && (d = p = 0);
                const m = this.dragOffset.x, b = this.dragOffset.y, y = this.option("dragMinThreshold") || 0;
                Math.abs(m) < y && Math.abs(b) < y && (h = d = 0, u = p = 0), (this.option("zoom") && (g < this.minScale - 1e-5 || g > this.maxScale + 1e-5) || i && !h && !d) && (f = .35), 
                this.applyChange({
                    panX: h,
                    panY: d,
                    friction: f
                }), this.emit("decel", u, p, m, b);
            }
            onWheel(t) {
                var e = [ -t.deltaX || 0, -t.deltaY || 0, -t.detail || 0 ].reduce((function(t, e) {
                    return Math.abs(e) > Math.abs(t) ? e : t;
                }));
                const i = Math.max(-1, Math.min(1, e));
                if (this.emit("wheel", t, i), this.panMode === O) return;
                if (t.defaultPrevented) return;
                const n = this.option("wheel");
                "pan" === n ? (t.preventDefault(), this.panOnlyZoomed && !this.canZoomOut() || this.applyChange({
                    panX: 2 * -t.deltaX,
                    panY: 2 * -t.deltaY,
                    bounce: !1
                })) : "zoom" === n && !1 !== this.option("zoom") && this.zoomWithWheel(t);
            }
            onMouseMove(t) {
                this.panWithMouse(t);
            }
            onKeydown(t) {
                "Escape" === t.key && this.toggleFS();
            }
            onResize() {
                this.updateMetrics(), this.checkBounds().inBounds || this.requestTick();
            }
            setTransform() {
                this.emit("beforeTransform");
                const {current: e, target: i, content: n, contentRect: s} = this, o = Object.assign({}, C);
                for (const n of v) {
                    const s = "e" == n || "f" === n ? M : T;
                    o[n] = t(e[n], s), Math.abs(i[n] - e[n]) < ("e" == n || "f" === n ? .51 : .001) && (e[n] = i[n]);
                }
                let {a, b: r, c: l, d: c, e: h, f: d} = o, u = `matrix(${a}, ${r}, ${l}, ${c}, ${h}, ${d})`, p = n.parentElement instanceof HTMLPictureElement ? n.parentElement : n;
                if (this.option("transformParent") && (p = p.parentElement || p), p.style.transform === u) return;
                p.style.transform = u;
                const {contentWidth: f, contentHeight: g} = this.calculateContentDim();
                s.width = f, s.height = g, this.emit("afterTransform");
            }
            updateMetrics(e = !1) {
                var i;
                if (!this || this.state === m.Destroy) return;
                if (this.isContentLoading) return;
                const n = Math.max(1, (null === (i = window.visualViewport) || void 0 === i ? void 0 : i.scale) || 1), {container: s, content: o} = this, a = o instanceof HTMLImageElement, r = s.getBoundingClientRect(), l = getComputedStyle(this.container);
                let c = r.width * n, h = r.height * n;
                const d = parseFloat(l.paddingTop) + parseFloat(l.paddingBottom), u = c - (parseFloat(l.paddingLeft) + parseFloat(l.paddingRight)), p = h - d;
                this.containerRect = {
                    width: c,
                    height: h,
                    innerWidth: u,
                    innerHeight: p
                };
                const f = parseFloat(o.dataset.width || "") || (t => {
                    let e = 0;
                    return e = t instanceof HTMLImageElement ? t.naturalWidth : t instanceof SVGElement ? t.width.baseVal.value : Math.max(t.offsetWidth, t.scrollWidth), 
                    e || 0;
                })(o), g = parseFloat(o.dataset.height || "") || (t => {
                    let e = 0;
                    return e = t instanceof HTMLImageElement ? t.naturalHeight : t instanceof SVGElement ? t.height.baseVal.value : Math.max(t.offsetHeight, t.scrollHeight), 
                    e || 0;
                })(o);
                let v = this.option("width", f) || z, b = this.option("height", g) || z;
                const y = v === z, w = b === z;
                "number" != typeof v && (v = f), "number" != typeof b && (b = g), y && (v = f * (b / g)), 
                w && (b = g / (f / v));
                let x = o.parentElement instanceof HTMLPictureElement ? o.parentElement : o;
                this.option("transformParent") && (x = x.parentElement || x);
                const E = x.getAttribute("style") || "";
                x.style.setProperty("transform", "none", "important"), a && (x.style.width = "", 
                x.style.height = ""), x.offsetHeight;
                const S = o.getBoundingClientRect();
                let P = S.width * n, C = S.height * n, T = P, M = C;
                P = Math.min(P, v), C = Math.min(C, b), a ? ({width: P, height: C} = ((t, e, i, n) => {
                    const s = i / t, o = n / e, a = Math.min(s, o);
                    return {
                        width: t *= a,
                        height: e *= a
                    };
                })(v, b, P, C)) : (P = Math.min(P, v), C = Math.min(C, b));
                let O = .5 * (M - C), A = .5 * (T - P);
                this.contentRect = Object.assign(Object.assign({}, this.contentRect), {
                    top: S.top - r.top + O,
                    bottom: r.bottom - S.bottom + O,
                    left: S.left - r.left + A,
                    right: r.right - S.right + A,
                    fitWidth: P,
                    fitHeight: C,
                    width: P,
                    height: C,
                    fullWidth: v,
                    fullHeight: b
                }), x.style.cssText = E, a && (x.style.width = `${P}px`, x.style.height = `${C}px`), 
                this.setTransform(), !0 !== e && this.emit("refresh"), this.ignoreBounds || (t(this.targetScale) < t(this.minScale) ? this.zoomTo(this.minScale, {
                    friction: 0
                }) : this.targetScale > this.maxScale ? this.zoomTo(this.maxScale, {
                    friction: 0
                }) : this.state === m.Init || this.checkBounds().inBounds || this.requestTick()), 
                this.updateControls();
            }
            calculateBounds() {
                const {contentWidth: e, contentHeight: i} = this.calculateContentDim(this.target), {targetScale: n, lockedAxis: s} = this, {fitWidth: o, fitHeight: a} = this.contentRect;
                let r = 0, l = 0, c = 0, h = 0;
                const d = this.option("infinite");
                if (!0 === d || s && d === s) r = -1 / 0, c = 1 / 0, l = -1 / 0, h = 1 / 0; else {
                    let {containerRect: s, contentRect: d} = this, u = t(o * n, M), p = t(a * n, M), {innerWidth: f, innerHeight: g} = s;
                    if (s.width === u && (f = s.width), s.width === p && (g = s.height), e > f) {
                        c = .5 * (e - f), r = -1 * c;
                        let t = .5 * (d.right - d.left);
                        r += t, c += t;
                    }
                    if (o > f && e < f && (r -= .5 * (o - f), c -= .5 * (o - f)), i > g) {
                        h = .5 * (i - g), l = -1 * h;
                        let t = .5 * (d.bottom - d.top);
                        l += t, h += t;
                    }
                    a > g && i < g && (r -= .5 * (a - g), c -= .5 * (a - g));
                }
                return {
                    x: {
                        min: r,
                        max: c
                    },
                    y: {
                        min: l,
                        max: h
                    }
                };
            }
            getBounds() {
                const t = this.option("bounds");
                return t !== z ? t : this.calculateBounds();
            }
            updateControls() {
                const e = this, i = e.container, {panMode: n, contentRect: s, targetScale: a, minScale: r} = e;
                let l = r, c = e.option("click") || !1;
                c && (l = e.getNextScale(c));
                let h = e.canZoomIn(), d = e.canZoomOut(), u = n === A && !!this.option("touch"), p = d && u;
                if (u && (t(a) < t(r) && !this.panOnlyZoomed && (p = !0), (t(s.width, 1) > t(s.fitWidth, 1) || t(s.height, 1) > t(s.fitHeight, 1)) && (p = !0)), 
                t(s.width * a, 1) < t(s.fitWidth, 1) && (p = !1), n === O && (p = !1), o(i, this.cn("isDraggable"), p), 
                !this.option("zoom")) return;
                let f = h && t(l) > t(a), g = !f && !p && d && t(l) < t(a);
                o(i, this.cn("canZoomIn"), f), o(i, this.cn("canZoomOut"), g);
                for (const t of i.querySelectorAll("[data-panzoom-action]")) {
                    let e = !1, i = !1;
                    switch (t.dataset.panzoomAction) {
                      case "zoomIn":
                        h ? e = !0 : i = !0;
                        break;

                      case "zoomOut":
                        d ? e = !0 : i = !0;
                        break;

                      case "toggleZoom":
                      case "iterateZoom":
                        h || d ? e = !0 : i = !0;
                        const n = t.querySelector("g");
                        n && (n.style.display = h ? "" : "none");
                    }
                    e ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex")) : i && (t.setAttribute("disabled", ""), 
                    t.setAttribute("tabindex", "-1"));
                }
            }
            panTo({x: t = this.target.e, y: e = this.target.f, scale: i = this.targetScale, friction: n = this.option("friction"), angle: s = 0, originX: o = 0, originY: a = 0, flipX: r = !1, flipY: l = !1, ignoreBounds: c = !1}) {
                this.state !== m.Destroy && this.applyChange({
                    panX: t - this.target.e,
                    panY: e - this.target.f,
                    scale: i / this.targetScale,
                    angle: s,
                    originX: o,
                    originY: a,
                    friction: n,
                    flipX: r,
                    flipY: l,
                    ignoreBounds: c
                });
            }
            applyChange({panX: e = 0, panY: i = 0, scale: n = 1, angle: s = 0, originX: o = -this.current.e, originY: a = -this.current.f, friction: r = this.option("friction"), flipX: l = !1, flipY: c = !1, ignoreBounds: h = !1, bounce: d = this.option("bounce")}) {
                const u = this.state;
                if (u === m.Destroy) return;
                this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.friction = r || 0, 
                this.ignoreBounds = h;
                const {current: p} = this, f = p.e, g = p.f, b = this.getMatrix(this.target);
                let y = (new DOMMatrix).translate(f, g).translate(o, a).translate(e, i);
                if (this.option("zoom")) {
                    if (!h) {
                        const t = this.targetScale, e = this.minScale, i = this.maxScale;
                        t * n < e && (n = e / t), t * n > i && (n = i / t);
                    }
                    y = y.scale(n);
                }
                y = y.translate(-o, -a).translate(-f, -g).multiply(b), s && (y = y.rotate(s)), l && (y = y.scale(-1, 1)), 
                c && (y = y.scale(1, -1));
                for (const e of v) "e" !== e && "f" !== e && (y[e] > this.minScale + 1e-5 || y[e] < this.minScale - 1e-5) ? this.target[e] = y[e] : this.target[e] = t(y[e], M);
                (this.targetScale < this.scale || Math.abs(n - 1) > .1 || this.panMode === O || !1 === d) && !h && this.clampTargetBounds(), 
                u === m.Init ? this.animate() : this.isResting || (this.state = m.Panning, this.requestTick());
            }
            stop(t = !1) {
                if (this.state === m.Init || this.state === m.Destroy) return;
                const e = this.isTicking;
                this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = !1, 
                this.isBouncingY = !1;
                for (const e of v) this.velocity[e] = 0, "current" === t ? this.current[e] = this.target[e] : "target" === t && (this.target[e] = this.current[e]);
                this.setTransform(), S(this.container, "is-scaling"), S(this.container, "is-animating"), 
                this.isTicking = !1, this.state = m.Ready, e && (this.emit("endAnimation"), this.updateControls());
            }
            requestTick() {
                this.isTicking || (this.emit("startAnimation"), this.updateControls(), P(this.container, "is-animating"), 
                this.isScaling && P(this.container, "is-scaling")), this.isTicking = !0, this.rAF || (this.rAF = requestAnimationFrame((() => this.animate())));
            }
            panWithMouse(e, i = this.option("mouseMoveFriction")) {
                if (this.pmme = e, this.panMode !== O || !e) return;
                if (t(this.targetScale) <= t(this.minScale)) return;
                this.emit("mouseMove", e);
                const {container: n, containerRect: s, contentRect: o} = this, a = s.width, r = s.height, l = n.getBoundingClientRect(), c = (e.clientX || 0) - l.left, h = (e.clientY || 0) - l.top;
                let {contentWidth: d, contentHeight: u} = this.calculateContentDim(this.target);
                const p = this.option("mouseMoveFactor");
                p > 1 && (d !== a && (d *= p), u !== r && (u *= p));
                let f = .5 * (d - a) - c / a * 100 / 100 * (d - a);
                f += .5 * (o.right - o.left);
                let g = .5 * (u - r) - h / r * 100 / 100 * (u - r);
                g += .5 * (o.bottom - o.top), this.applyChange({
                    panX: f - this.target.e,
                    panY: g - this.target.f,
                    friction: i
                });
            }
            zoomWithWheel(e) {
                if (this.state === m.Destroy || this.state === m.Init) return;
                const i = Date.now();
                if (i - this.pwt < 45) return void e.preventDefault();
                this.pwt = i;
                var n = [ -e.deltaX || 0, -e.deltaY || 0, -e.detail || 0 ].reduce((function(t, e) {
                    return Math.abs(e) > Math.abs(t) ? e : t;
                }));
                const s = Math.max(-1, Math.min(1, n)), {targetScale: o, maxScale: a, minScale: r} = this;
                let l = o * (100 + 45 * s) / 100;
                t(l) < t(r) && t(o) <= t(r) ? (this.cwd += Math.abs(s), l = r) : t(l) > t(a) && t(o) >= t(a) ? (this.cwd += Math.abs(s), 
                l = a) : (this.cwd = 0, l = Math.max(Math.min(l, a), r)), this.cwd > this.option("wheelLimit") || (e.preventDefault(), 
                t(l) !== t(o) && this.zoomTo(l, {
                    event: e
                }));
            }
            canZoomIn() {
                return this.option("zoom") && (t(this.contentRect.width, 1) < t(this.contentRect.fitWidth, 1) || t(this.targetScale) < t(this.maxScale));
            }
            canZoomOut() {
                return this.option("zoom") && t(this.targetScale) > t(this.minScale);
            }
            zoomIn(t = 1.25, e) {
                this.zoomTo(this.targetScale * t, e);
            }
            zoomOut(t = .8, e) {
                this.zoomTo(this.targetScale * t, e);
            }
            zoomToFit(t) {
                this.zoomTo("fit", t);
            }
            zoomToCover(t) {
                this.zoomTo("cover", t);
            }
            zoomToFull(t) {
                this.zoomTo("full", t);
            }
            zoomToMax(t) {
                this.zoomTo("max", t);
            }
            toggleZoom(t) {
                this.zoomTo(this.getNextScale("toggleZoom"), t);
            }
            toggleMax(t) {
                this.zoomTo(this.getNextScale("toggleMax"), t);
            }
            toggleCover(t) {
                this.zoomTo(this.getNextScale("toggleCover"), t);
            }
            iterateZoom(t) {
                this.zoomTo("next", t);
            }
            zoomTo(t = 1, {friction: e = z, originX: i = z, originY: n = z, event: s} = {}) {
                if (this.isContentLoading || this.state === m.Destroy) return;
                const {targetScale: o, fullScale: a, maxScale: r, coverScale: l} = this;
                if (this.stop(), this.panMode === O && (s = this.pmme || s), s || i === z || n === z) {
                    const t = this.content.getBoundingClientRect(), e = this.container.getBoundingClientRect(), o = s ? s.clientX : e.left + .5 * e.width, a = s ? s.clientY : e.top + .5 * e.height;
                    i = o - t.left - .5 * t.width, n = a - t.top - .5 * t.height;
                }
                let c = 1;
                "number" == typeof t ? c = t : "full" === t ? c = a : "cover" === t ? c = l : "max" === t ? c = r : "fit" === t ? c = 1 : "next" === t && (c = this.getNextScale("iterateZoom")), 
                c = c / o || 1, e = e === z ? c > 1 ? .15 : .25 : e, this.applyChange({
                    scale: c,
                    originX: i,
                    originY: n,
                    friction: e
                }), s && this.panMode === O && this.panWithMouse(s, e);
            }
            rotateCCW() {
                this.applyChange({
                    angle: -90
                });
            }
            rotateCW() {
                this.applyChange({
                    angle: 90
                });
            }
            flipX() {
                this.applyChange({
                    flipX: !0
                });
            }
            flipY() {
                this.applyChange({
                    flipY: !0
                });
            }
            fitX() {
                this.stop("target");
                const {containerRect: t, contentRect: e, target: i} = this;
                this.applyChange({
                    panX: .5 * t.width - (e.left + .5 * e.fitWidth) - i.e,
                    panY: .5 * t.height - (e.top + .5 * e.fitHeight) - i.f,
                    scale: t.width / e.fitWidth / this.targetScale,
                    originX: 0,
                    originY: 0,
                    ignoreBounds: !0
                });
            }
            fitY() {
                this.stop("target");
                const {containerRect: t, contentRect: e, target: i} = this;
                this.applyChange({
                    panX: .5 * t.width - (e.left + .5 * e.fitWidth) - i.e,
                    panY: .5 * t.innerHeight - (e.top + .5 * e.fitHeight) - i.f,
                    scale: t.height / e.fitHeight / this.targetScale,
                    originX: 0,
                    originY: 0,
                    ignoreBounds: !0
                });
            }
            toggleFS() {
                const {container: t} = this, e = this.cn("inFullscreen"), i = this.cn("htmlHasFullscreen");
                t.classList.toggle(e);
                const n = t.classList.contains(e);
                n ? (document.documentElement.classList.add(i), document.addEventListener("keydown", this.onKeydown, !0)) : (document.documentElement.classList.remove(i), 
                document.removeEventListener("keydown", this.onKeydown, !0)), this.updateMetrics(), 
                this.emit(n ? "enterFS" : "exitFS");
            }
            getMatrix(t = this.current) {
                const {a: e, b: i, c: n, d: s, e: o, f: a} = t;
                return new DOMMatrix([ e, i, n, s, o, a ]);
            }
            reset(t) {
                if (this.state !== m.Init && this.state !== m.Destroy) {
                    this.stop("current");
                    for (const t of v) this.target[t] = C[t];
                    this.target.a = this.minScale, this.target.d = this.minScale, this.clampTargetBounds(), 
                    this.isResting || (this.friction = void 0 === t ? this.option("friction") : t, this.state = m.Panning, 
                    this.requestTick());
                }
            }
            destroy() {
                this.stop(), this.state = m.Destroy, this.detachEvents(), this.detachObserver();
                const {container: t, content: e} = this, i = this.option("classes") || {};
                for (const e of Object.values(i)) t.classList.remove(e + "");
                e && (e.removeEventListener("load", this.onLoad), e.removeEventListener("error", this.onError)), 
                this.detachPlugins();
            }
        }
        Object.defineProperty(I, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: y
        }), Object.defineProperty(I, "Plugins", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {}
        });
        const D = function(t, e) {
            let i = !0;
            return (...n) => {
                i && (i = !1, t(...n), setTimeout((() => {
                    i = !0;
                }), e));
            };
        }, F = (t, e) => {
            let i = [];
            return t.childNodes.forEach((t => {
                t.nodeType !== Node.ELEMENT_NODE || e && !t.matches(e) || i.push(t);
            })), i;
        }, j = {
            viewport: null,
            track: null,
            enabled: !0,
            slides: [],
            axis: "x",
            transition: "fade",
            preload: 1,
            slidesPerPage: "auto",
            initialPage: 0,
            friction: .12,
            Panzoom: {
                decelFriction: .12
            },
            center: !0,
            infinite: !0,
            fill: !0,
            dragFree: !1,
            adaptiveHeight: !1,
            direction: "ltr",
            classes: {
                container: "f-carousel",
                viewport: "f-carousel__viewport",
                track: "f-carousel__track",
                slide: "f-carousel__slide",
                isLTR: "is-ltr",
                isRTL: "is-rtl",
                isHorizontal: "is-horizontal",
                isVertical: "is-vertical",
                inTransition: "in-transition",
                isSelected: "is-selected"
            },
            l10n: {
                NEXT: "Next slide",
                PREV: "Previous slide",
                GOTO: "Go to slide #%d"
            }
        };
        var B;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Destroy = 2] = "Destroy";
        }(B || (B = {}));
        const H = t => {
            if ("string" == typeof t || t instanceof HTMLElement) t = {
                html: t
            }; else {
                const e = t.thumb;
                void 0 !== e && ("string" == typeof e && (t.thumbSrc = e), e instanceof HTMLImageElement && (t.thumbEl = e, 
                t.thumbElSrc = e.src, t.thumbSrc = e.src), delete t.thumb);
            }
            return Object.assign({
                html: "",
                el: null,
                isDom: !1,
                class: "",
                customClass: "",
                index: -1,
                dim: 0,
                gap: 0,
                pos: 0,
                transition: !1
            }, t);
        }, N = (t = {}) => Object.assign({
            index: -1,
            slides: [],
            dim: 0,
            pos: -1
        }, t);
        class _ extends f {
            constructor(t, e) {
                super(e), Object.defineProperty(this, "instance", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                });
            }
            attach() {}
            detach() {}
        }
        const $ = {
            classes: {
                list: "f-carousel__dots",
                isDynamic: "is-dynamic",
                hasDots: "has-dots",
                dot: "f-carousel__dot",
                isBeforePrev: "is-before-prev",
                isPrev: "is-prev",
                isCurrent: "is-current",
                isNext: "is-next",
                isAfterNext: "is-after-next"
            },
            dotTpl: '<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>',
            dynamicFrom: 11,
            maxCount: 1 / 0,
            minCount: 2
        };
        class W extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "isDynamic", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "list", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onRefresh() {
                this.refresh();
            }
            build() {
                let t = this.list;
                if (!t) {
                    t = document.createElement("ul"), P(t, this.cn("list")), t.setAttribute("role", "tablist");
                    const e = this.instance.container;
                    e.appendChild(t), P(e, this.cn("hasDots")), this.list = t;
                }
                return t;
            }
            refresh() {
                var t;
                const e = this.instance.pages.length, i = Math.min(2, this.option("minCount")), n = Math.max(2e3, this.option("maxCount")), s = this.option("dynamicFrom");
                if (e < i || e > n) return void this.cleanup();
                const a = "number" == typeof s && e > 5 && e >= s, r = !this.list || this.isDynamic !== a || this.list.children.length !== e;
                r && this.cleanup();
                const l = this.build();
                if (o(l, this.cn("isDynamic"), !!a), r) for (let t = 0; t < e; t++) l.append(this.createItem(t));
                let c, h = 0;
                for (const e of [ ...l.children ]) {
                    const i = h === this.instance.page;
                    i && (c = e), o(e, this.cn("isCurrent"), i), null === (t = e.children[0]) || void 0 === t || t.setAttribute("aria-selected", i ? "true" : "false");
                    for (const t of [ "isBeforePrev", "isPrev", "isNext", "isAfterNext" ]) S(e, this.cn(t));
                    h++;
                }
                if (c = c || l.firstChild, a && c) {
                    const t = c.previousElementSibling, e = t && t.previousElementSibling;
                    P(t, this.cn("isPrev")), P(e, this.cn("isBeforePrev"));
                    const i = c.nextElementSibling, n = i && i.nextElementSibling;
                    P(i, this.cn("isNext")), P(n, this.cn("isAfterNext"));
                }
                this.isDynamic = a;
            }
            createItem(t = 0) {
                var e;
                const i = document.createElement("li");
                i.setAttribute("role", "presentation");
                const s = n(this.instance.localize(this.option("dotTpl"), [ [ "%d", t + 1 ] ]).replace(/\%i/g, t + ""));
                return i.appendChild(s), null === (e = i.children[0]) || void 0 === e || e.setAttribute("role", "tab"), 
                i;
            }
            cleanup() {
                this.list && (this.list.remove(), this.list = null), this.isDynamic = !1, S(this.instance.container, this.cn("hasDots"));
            }
            attach() {
                this.instance.on([ "refresh", "change" ], this.onRefresh);
            }
            detach() {
                this.instance.off([ "refresh", "change" ], this.onRefresh), this.cleanup();
            }
        }
        Object.defineProperty(W, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: $
        });
        const X = "disabled", q = "next", Y = "prev";
        class V extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "prev", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "next", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "isDom", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                });
            }
            onRefresh() {
                const t = this.instance, e = t.pages.length, i = t.page;
                if (e < 2) return void this.cleanup();
                this.build();
                let n = this.prev, s = this.next;
                n && s && (n.removeAttribute(X), s.removeAttribute(X), t.isInfinite || (i <= 0 && n.setAttribute(X, ""), 
                i >= e - 1 && s.setAttribute(X, "")));
            }
            addBtn(t) {
                var e;
                const i = this.instance, n = document.createElement("button");
                n.setAttribute("tabindex", "0"), n.setAttribute("title", i.localize(`{{${t.toUpperCase()}}}`)), 
                P(n, this.cn("button") + " " + this.cn(t === q ? "isNext" : "isPrev"));
                const s = i.isRTL ? t === q ? Y : q : t;
                var o;
                return n.innerHTML = i.localize(this.option(`${s}Tpl`)), n.dataset[`carousel${o = t, 
                o ? o.match("^[a-z]") ? o.charAt(0).toUpperCase() + o.substring(1) : o : ""}`] = "true", 
                null === (e = this.container) || void 0 === e || e.appendChild(n), n;
            }
            build() {
                const t = this.instance.container, e = this.cn("container");
                let {container: i, prev: n, next: s} = this;
                i || (i = t.querySelector("." + e), this.isDom = !!i), i || (i = document.createElement("div"), 
                P(i, e), t.appendChild(i)), this.container = i, s || (s = i.querySelector("[data-carousel-next]")), 
                s || (s = this.addBtn(q)), this.next = s, n || (n = i.querySelector("[data-carousel-prev]")), 
                n || (n = this.addBtn(Y)), this.prev = n;
            }
            cleanup() {
                this.isDom || (this.prev && this.prev.remove(), this.next && this.next.remove(), 
                this.container && this.container.remove()), this.prev = null, this.next = null, 
                this.container = null, this.isDom = !1;
            }
            attach() {
                this.instance.on([ "refresh", "change" ], this.onRefresh);
            }
            detach() {
                this.instance.off([ "refresh", "change" ], this.onRefresh), this.cleanup();
            }
        }
        Object.defineProperty(V, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                classes: {
                    container: "f-carousel__nav",
                    button: "f-button",
                    isNext: "is-next",
                    isPrev: "is-prev"
                },
                nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',
                prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>'
            }
        });
        class Z extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "selectedIndex", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "target", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "nav", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            addAsTargetFor(t) {
                this.target = this.instance, this.nav = t, this.attachEvents();
            }
            addAsNavFor(t) {
                this.nav = this.instance, this.target = t, this.attachEvents();
            }
            attachEvents() {
                const {nav: t, target: e} = this;
                t && e && (t.options.initialSlide = e.options.initialPage, t.state === B.Ready ? this.onNavReady(t) : t.on("ready", this.onNavReady), 
                e.state === B.Ready ? this.onTargetReady(e) : e.on("ready", this.onTargetReady));
            }
            onNavReady(t) {
                t.on("createSlide", this.onNavCreateSlide), t.on("Panzoom.click", this.onNavClick), 
                t.on("Panzoom.touchEnd", this.onNavTouch), this.onTargetChange();
            }
            onTargetReady(t) {
                t.on("change", this.onTargetChange), t.on("Panzoom.refresh", this.onTargetChange), 
                this.onTargetChange();
            }
            onNavClick(t, e, i) {
                this.onNavTouch(t, t.panzoom, i);
            }
            onNavTouch(t, e, i) {
                var n, s;
                if (Math.abs(e.dragOffset.x) > 3 || Math.abs(e.dragOffset.y) > 3) return;
                const o = i.target, {nav: a, target: r} = this;
                if (!a || !r || !o) return;
                const l = o.closest("[data-index]");
                if (i.stopPropagation(), i.preventDefault(), !l) return;
                const c = parseInt(l.dataset.index || "", 10) || 0, h = r.getPageForSlide(c), d = a.getPageForSlide(c);
                a.slideTo(d), r.slideTo(h, {
                    friction: (null === (s = null === (n = this.nav) || void 0 === n ? void 0 : n.plugins) || void 0 === s ? void 0 : s.Sync.option("friction")) || 0
                }), this.markSelectedSlide(c);
            }
            onNavCreateSlide(t, e) {
                e.index === this.selectedIndex && this.markSelectedSlide(e.index);
            }
            onTargetChange() {
                var t, e;
                const {target: i, nav: n} = this;
                if (!i || !n) return;
                if (n.state !== B.Ready || i.state !== B.Ready) return;
                const s = null === (e = null === (t = i.pages[i.page]) || void 0 === t ? void 0 : t.slides[0]) || void 0 === e ? void 0 : e.index, o = n.getPageForSlide(s);
                this.markSelectedSlide(s), n.slideTo(o, null === n.prevPage && null === i.prevPage ? {
                    friction: 0
                } : void 0);
            }
            markSelectedSlide(t) {
                const e = this.nav;
                e && e.state === B.Ready && (this.selectedIndex = t, [ ...e.slides ].map((e => {
                    e.el && e.el.classList[e.index === t ? "add" : "remove"]("is-nav-selected");
                })));
            }
            attach() {
                const t = this;
                let e = t.options.target, i = t.options.nav;
                e ? t.addAsNavFor(e) : i && t.addAsTargetFor(i);
            }
            detach() {
                const t = this, e = t.nav, i = t.target;
                e && (e.off("ready", t.onNavReady), e.off("createSlide", t.onNavCreateSlide), e.off("Panzoom.click", t.onNavClick), 
                e.off("Panzoom.touchEnd", t.onNavTouch)), t.nav = null, i && (i.off("ready", t.onTargetReady), 
                i.off("refresh", t.onTargetChange), i.off("change", t.onTargetChange)), t.target = null;
            }
        }
        Object.defineProperty(Z, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                friction: .35
            }
        });
        const U = {
            Navigation: V,
            Dots: W,
            Sync: Z
        }, G = "animationend", K = "isSelected", J = "slide";
        class Q extends g {
            get axis() {
                return this.isHorizontal ? "e" : "f";
            }
            get isEnabled() {
                return this.state === B.Ready;
            }
            get isInfinite() {
                let t = !1;
                const {contentDim: e, viewportDim: i, pages: n, slides: s} = this, o = s[0];
                return n.length >= 2 && o && e + o.dim >= i && (t = this.option("infinite")), t;
            }
            get isRTL() {
                return "rtl" === this.option("direction");
            }
            get isHorizontal() {
                return "x" === this.option("axis");
            }
            constructor(t, e = {}, i = {}) {
                if (super(), Object.defineProperty(this, "bp", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: ""
                }), Object.defineProperty(this, "lp", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "userOptions", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                }), Object.defineProperty(this, "userPlugins", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: B.Init
                }), Object.defineProperty(this, "page", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "prevPage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "viewport", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "track", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "slides", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "pages", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "panzoom", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "inTransition", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: new Set
                }), Object.defineProperty(this, "contentDim", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "viewportDim", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), "string" == typeof t && (t = document.querySelector(t)), !t || !E(t)) throw new Error("No Element found");
                this.container = t, this.slideNext = D(this.slideNext.bind(this), 150), this.slidePrev = D(this.slidePrev.bind(this), 150), 
                this.userOptions = e, this.userPlugins = i, queueMicrotask((() => {
                    this.processOptions();
                }));
            }
            processOptions() {
                var t, e;
                const i = u({}, Q.defaults, this.userOptions);
                let n = "";
                const s = i.breakpoints;
                if (s && d(s)) for (const [t, e] of Object.entries(s)) window.matchMedia(t).matches && d(e) && (n += t, 
                u(i, e));
                n === this.bp && this.state !== B.Init || (this.bp = n, this.state === B.Ready && (i.initialSlide = (null === (e = null === (t = this.pages[this.page]) || void 0 === t ? void 0 : t.slides[0]) || void 0 === e ? void 0 : e.index) || 0), 
                this.state !== B.Init && this.destroy(), super.setOptions(i), !1 === this.option("enabled") ? this.attachEvents() : setTimeout((() => {
                    this.init();
                }), 0));
            }
            init() {
                this.state = B.Init, this.emit("init"), this.attachPlugins(Object.assign(Object.assign({}, Q.Plugins), this.userPlugins)), 
                this.emit("attachPlugins"), this.initLayout(), this.initSlides(), this.updateMetrics(), 
                this.setInitialPosition(), this.initPanzoom(), this.attachEvents(), this.state = B.Ready, 
                this.emit("ready");
            }
            initLayout() {
                const {container: t} = this, e = this.option("classes");
                P(t, this.cn("container")), o(t, e.isLTR, !this.isRTL), o(t, e.isRTL, this.isRTL), 
                o(t, e.isVertical, !this.isHorizontal), o(t, e.isHorizontal, this.isHorizontal);
                let i = this.option("viewport") || t.querySelector(`.${e.viewport}`);
                i || (i = document.createElement("div"), P(i, e.viewport), i.append(...F(t, `.${e.slide}`)), 
                t.prepend(i)), i.addEventListener("scroll", this.onScroll);
                let n = this.option("track") || t.querySelector(`.${e.track}`);
                n || (n = document.createElement("div"), P(n, e.track), n.append(...Array.from(i.childNodes))), 
                n.setAttribute("aria-live", "polite"), i.contains(n) || i.prepend(n), this.viewport = i, 
                this.track = n, this.emit("initLayout");
            }
            initSlides() {
                const {track: t} = this;
                if (!t) return;
                const e = [ ...this.slides ], i = [];
                [ ...F(t, `.${this.cn(J)}`) ].forEach((t => {
                    if (E(t)) {
                        const e = H({
                            el: t,
                            isDom: !0,
                            index: this.slides.length
                        });
                        i.push(e);
                    }
                }));
                for (let t of [ ...this.option("slides", []) || [], ...e ]) i.push(H(t));
                this.slides = i;
                for (let t = 0; t < this.slides.length; t++) this.slides[t].index = t;
                for (const t of i) this.emit("beforeInitSlide", t, t.index), this.emit("initSlide", t, t.index);
                this.emit("initSlides");
            }
            setInitialPage() {
                const t = this.option("initialSlide");
                this.page = "number" == typeof t ? this.getPageForSlide(t) : parseInt(this.option("initialPage", 0) + "", 10) || 0;
            }
            setInitialPosition() {
                const {track: t, pages: e, isHorizontal: i} = this;
                if (!t || !e.length) return;
                let n = this.page;
                e[n] || (this.page = n = 0);
                const s = (e[n].pos || 0) * (this.isRTL && i ? 1 : -1), o = i ? `${s}px` : "0", a = i ? "0" : `${s}px`;
                t.style.transform = `translate3d(${o}, ${a}, 0) scale(1)`, this.option("adaptiveHeight") && this.setViewportHeight();
            }
            initPanzoom() {
                this.panzoom && (this.panzoom.destroy(), this.panzoom = null);
                const t = this.option("Panzoom") || {};
                this.panzoom = new I(this.viewport, u({}, {
                    content: this.track,
                    zoom: !1,
                    panOnlyZoomed: !1,
                    lockAxis: this.isHorizontal ? "x" : "y",
                    infinite: this.isInfinite,
                    click: !1,
                    dblClick: !1,
                    touch: t => !(this.pages.length < 2 && !t.options.infinite),
                    bounds: () => this.getBounds(),
                    maxVelocity: t => Math.abs(t.target[this.axis] - t.current[this.axis]) < 2 * this.viewportDim ? 100 : 0
                }, t)), this.panzoom.on("*", ((t, e, ...i) => {
                    this.emit(`Panzoom.${e}`, t, ...i);
                })), this.panzoom.on("decel", this.onDecel), this.panzoom.on("refresh", this.onRefresh), 
                this.panzoom.on("beforeTransform", this.onBeforeTransform), this.panzoom.on("endAnimation", this.onEndAnimation);
            }
            attachEvents() {
                const t = this.container;
                t && (t.addEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), t.addEventListener("slideTo", this.onSlideTo)), window.addEventListener("resize", this.onResize);
            }
            createPages() {
                let t = [];
                const {contentDim: e, viewportDim: i} = this;
                let n = this.option("slidesPerPage");
                n = ("auto" === n || e <= i) && !1 !== this.option("fill") ? 1 / 0 : parseFloat(n + "");
                let s = 0, o = 0, a = 0;
                for (const e of this.slides) (!t.length || o + e.dim - i > .05 || a >= n) && (t.push(N()), 
                s = t.length - 1, o = 0, a = 0), t[s].slides.push(e), o += e.dim + e.gap, a++;
                return t;
            }
            processPages() {
                const e = this.pages, {contentDim: i, viewportDim: n, isInfinite: s} = this, o = this.option("center"), a = this.option("fill"), r = a && o && i > n && !s;
                if (e.forEach(((t, e) => {
                    var s;
                    t.index = e, t.pos = (null === (s = t.slides[0]) || void 0 === s ? void 0 : s.pos) || 0, 
                    t.dim = 0;
                    for (const [e, i] of t.slides.entries()) t.dim += i.dim, e < t.slides.length - 1 && (t.dim += i.gap);
                    r && t.pos + .5 * t.dim < .5 * n ? t.pos = 0 : r && t.pos + .5 * t.dim >= i - .5 * n ? t.pos = i - n : o && (t.pos += -.5 * (n - t.dim));
                })), e.forEach((e => {
                    a && !s && i > n && (e.pos = Math.max(e.pos, 0), e.pos = Math.min(e.pos, i - n)), 
                    e.pos = t(e.pos, 1e3), e.dim = t(e.dim, 1e3), Math.abs(e.pos) <= .1 && (e.pos = 0);
                })), s) return e;
                const l = [];
                let c;
                return e.forEach((t => {
                    const e = Object.assign({}, t);
                    c && e.pos === c.pos ? (c.dim += e.dim, c.slides = [ ...c.slides, ...e.slides ]) : (e.index = l.length, 
                    c = e, l.push(e));
                })), l;
            }
            getPageFromIndex(t = 0) {
                const e = this.pages.length;
                let i;
                return t = parseInt((t || 0).toString()) || 0, i = this.isInfinite ? (t % e + e) % e : Math.max(Math.min(t, e - 1), 0), 
                i;
            }
            getSlideMetrics(e) {
                var i, n;
                const s = this.isHorizontal ? "width" : "height";
                let o = 0, a = 0, r = e.el;
                const l = !(!r || r.parentNode);
                if (r ? o = parseFloat(r.dataset[s] || "") || 0 : (r = document.createElement("div"), 
                r.style.visibility = "hidden", (this.track || document.body).prepend(r)), P(r, this.cn(J) + " " + e.class + " " + e.customClass), 
                o) r.style[s] = `${o}px`, r.style["width" === s ? "height" : "width"] = ""; else {
                    l && (this.track || document.body).prepend(r), o = r.getBoundingClientRect()[s] * Math.max(1, (null === (i = window.visualViewport) || void 0 === i ? void 0 : i.scale) || 1);
                    let t = r[this.isHorizontal ? "offsetWidth" : "offsetHeight"];
                    t - 1 > o && (o = t);
                }
                const c = getComputedStyle(r);
                return "content-box" === c.boxSizing && (this.isHorizontal ? (o += parseFloat(c.paddingLeft) || 0, 
                o += parseFloat(c.paddingRight) || 0) : (o += parseFloat(c.paddingTop) || 0, o += parseFloat(c.paddingBottom) || 0)), 
                a = parseFloat(c[this.isHorizontal ? "marginRight" : "marginBottom"]) || 0, l ? null === (n = r.parentElement) || void 0 === n || n.removeChild(r) : e.el || r.remove(), 
                {
                    dim: t(o, 1e3),
                    gap: t(a, 1e3)
                };
            }
            getBounds() {
                const {isInfinite: t, isRTL: e, isHorizontal: i, pages: n} = this;
                let s = {
                    min: 0,
                    max: 0
                };
                if (t) s = {
                    min: -1 / 0,
                    max: 1 / 0
                }; else if (n.length) {
                    const t = n[0].pos, o = n[n.length - 1].pos;
                    s = e && i ? {
                        min: t,
                        max: o
                    } : {
                        min: -1 * o,
                        max: -1 * t
                    };
                }
                return {
                    x: i ? s : {
                        min: 0,
                        max: 0
                    },
                    y: i ? {
                        min: 0,
                        max: 0
                    } : s
                };
            }
            repositionSlides() {
                let e, {isHorizontal: i, isRTL: n, isInfinite: s, viewport: o, viewportDim: a, contentDim: r, page: l, pages: c, slides: h, panzoom: d} = this, u = 0, p = 0, f = 0, g = 0;
                d ? g = -1 * d.current[this.axis] : c[l] && (g = c[l].pos || 0), e = i ? n ? "right" : "left" : "top", 
                n && i && (g *= -1);
                for (const i of h) {
                    const n = i.el;
                    n ? ("top" === e ? (n.style.right = "", n.style.left = "") : n.style.top = "", i.index !== u ? n.style[e] = 0 === p ? "" : `${t(p, 1e3)}px` : n.style[e] = "", 
                    f += i.dim + i.gap, u++) : p += i.dim + i.gap;
                }
                if (s && f && o) {
                    let n = getComputedStyle(o), s = "padding", l = i ? "Right" : "Bottom", c = parseFloat(n[s + (i ? "Left" : "Top")]);
                    g -= c, a += c, a += parseFloat(n[s + l]);
                    for (const i of h) i.el && (t(i.pos) < t(a) && t(i.pos + i.dim + i.gap) < t(g) && t(g) > t(r - a) && (i.el.style[e] = `${t(p + f, 1e3)}px`), 
                    t(i.pos + i.gap) >= t(r - a) && t(i.pos) > t(g + a) && t(g) < t(a) && (i.el.style[e] = `-${t(f, 1e3)}px`));
                }
                let m, v, b = [ ...this.inTransition ];
                if (b.length > 1 && (m = c[b[0]], v = c[b[1]]), m && v) {
                    let i = 0;
                    for (const n of h) n.el ? this.inTransition.has(n.index) && m.slides.indexOf(n) < 0 && (n.el.style[e] = `${t(i + (m.pos - v.pos), 1e3)}px`) : i += n.dim + n.gap;
                }
            }
            createSlideEl(t) {
                const {track: e, slides: i} = this;
                if (!e || !t) return;
                if (t.el && t.el.parentNode) return;
                const n = t.el || document.createElement("div");
                P(n, this.cn(J)), P(n, t.class), P(n, t.customClass);
                const s = t.html;
                s && (s instanceof HTMLElement ? n.appendChild(s) : n.innerHTML = t.html + "");
                const o = [];
                i.forEach(((t, e) => {
                    t.el && o.push(e);
                }));
                const a = t.index;
                let r = null;
                if (o.length) r = i[o.reduce(((t, e) => Math.abs(e - a) < Math.abs(t - a) ? e : t))];
                const l = r && r.el && r.el.parentNode ? r.index < t.index ? r.el.nextSibling : r.el : null;
                e.insertBefore(n, e.contains(l) ? l : null), t.el = n, this.emit("createSlide", t);
            }
            removeSlideEl(t, e = !1) {
                const i = null == t ? void 0 : t.el;
                if (!i || !i.parentNode) return;
                const n = this.cn(K);
                if (i.classList.contains(n) && (S(i, n), this.emit("unselectSlide", t)), t.isDom && !e) return i.removeAttribute("aria-hidden"), 
                i.removeAttribute("data-index"), void (i.style.left = "");
                this.emit("removeSlide", t);
                const s = new CustomEvent(G);
                i.dispatchEvent(s), t.el && (t.el.remove(), t.el = null);
            }
            transitionTo(t = 0, e = this.option("transition")) {
                var i, n, s, o;
                if (!e) return !1;
                const a = this.page, {pages: r, panzoom: l} = this;
                t = parseInt((t || 0).toString()) || 0;
                const c = this.getPageFromIndex(t);
                if (!l || !r[c] || r.length < 2 || Math.abs(((null === (n = null === (i = r[a]) || void 0 === i ? void 0 : i.slides[0]) || void 0 === n ? void 0 : n.dim) || 0) - this.viewportDim) > 1) return !1;
                let h = t > a ? 1 : -1;
                this.isInfinite && (0 === a && t === r.length - 1 && (h = -1), a === r.length - 1 && 0 === t && (h = 1));
                const d = r[c].pos * (this.isRTL ? 1 : -1);
                if (a === c && Math.abs(d - l.target[this.axis]) < 1) return !1;
                this.clearTransitions();
                const u = l.isResting;
                P(this.container, this.cn("inTransition"));
                const p = (null === (s = r[a]) || void 0 === s ? void 0 : s.slides[0]) || null, f = (null === (o = r[c]) || void 0 === o ? void 0 : o.slides[0]) || null;
                this.inTransition.add(f.index), this.createSlideEl(f);
                let g = p.el, m = f.el;
                u || e === J || (e = "fadeFast", g = null);
                const v = this.isRTL ? "next" : "prev", b = this.isRTL ? "prev" : "next";
                return g && (this.inTransition.add(p.index), p.transition = e, g.addEventListener(G, this.onAnimationEnd), 
                g.classList.add(`f-${e}Out`, `to-${h > 0 ? b : v}`)), m && (f.transition = e, m.addEventListener(G, this.onAnimationEnd), 
                m.classList.add(`f-${e}In`, `from-${h > 0 ? v : b}`)), l.current[this.axis] = d, 
                l.target[this.axis] = d, l.requestTick(), this.onChange(c), !0;
            }
            manageSlideVisiblity() {
                const t = new Set, e = new Set, i = this.getVisibleSlides(parseFloat(this.option("preload", 0) + "") || 0);
                for (const n of this.slides) i.has(n) ? t.add(n) : e.add(n);
                for (const e of this.inTransition) t.add(this.slides[e]);
                for (const e of t) this.createSlideEl(e), this.lazyLoadSlide(e);
                for (const i of e) t.has(i) || this.removeSlideEl(i);
                this.markSelectedSlides(), this.repositionSlides();
            }
            markSelectedSlides() {
                if (!this.pages[this.page] || !this.pages[this.page].slides) return;
                const t = "aria-hidden";
                let e = this.cn(K);
                if (e) for (const i of this.slides) {
                    const n = i.el;
                    n && (n.dataset.index = `${i.index}`, n.classList.contains("f-thumbs__slide") ? this.getVisibleSlides(0).has(i) ? n.removeAttribute(t) : n.setAttribute(t, "true") : this.pages[this.page].slides.includes(i) ? (n.classList.contains(e) || (P(n, e), 
                    this.emit("selectSlide", i)), n.removeAttribute(t)) : (n.classList.contains(e) && (S(n, e), 
                    this.emit("unselectSlide", i)), n.setAttribute(t, "true")));
                }
            }
            flipInfiniteTrack() {
                const {axis: t, isHorizontal: e, isInfinite: i, isRTL: n, viewportDim: s, contentDim: o} = this, a = this.panzoom;
                if (!a || !i) return;
                let r = a.current[t], l = a.target[t] - r, c = 0, h = .5 * s;
                n && e ? (r < -h && (c = -1, r += o), r > o - h && (c = 1, r -= o)) : (r > h && (c = 1, 
                r -= o), r < -o + h && (c = -1, r += o)), c && (a.current[t] = r, a.target[t] = r + l);
            }
            lazyLoadImg(t, e) {
                const i = this, s = "f-fadeIn", o = "is-preloading";
                let a = !1, r = null;
                const l = () => {
                    a || (a = !0, r && (r.remove(), r = null), S(e, o), e.complete && (P(e, s), setTimeout((() => {
                        S(e, s);
                    }), 350)), this.option("adaptiveHeight") && t.el && this.pages[this.page].slides.indexOf(t) > -1 && (i.updateMetrics(), 
                    i.setViewportHeight()), this.emit("load", t));
                };
                P(e, o), e.src = e.dataset.lazySrcset || e.dataset.lazySrc || "", delete e.dataset.lazySrc, 
                delete e.dataset.lazySrcset, e.addEventListener("error", (() => {
                    l();
                })), e.addEventListener("load", (() => {
                    l();
                })), setTimeout((() => {
                    const i = e.parentNode;
                    i && t.el && (e.complete ? l() : a || (r = n(x), i.insertBefore(r, e)));
                }), 300);
            }
            lazyLoadSlide(t) {
                const e = t && t.el;
                if (!e) return;
                const i = new Set;
                let n = Array.from(e.querySelectorAll("[data-lazy-src],[data-lazy-srcset]"));
                e.dataset.lazySrc && n.push(e), n.map((t => {
                    t instanceof HTMLImageElement ? i.add(t) : t instanceof HTMLElement && t.dataset.lazySrc && (t.style.backgroundImage = `url('${t.dataset.lazySrc}')`, 
                    delete t.dataset.lazySrc);
                }));
                for (const e of i) this.lazyLoadImg(t, e);
            }
            onAnimationEnd(t) {
                var e;
                const i = t.target, n = i ? parseInt(i.dataset.index || "", 10) || 0 : -1, s = this.slides[n], o = t.animationName;
                if (!i || !s || !o) return;
                const a = !!this.inTransition.has(n) && s.transition;
                a && o.substring(0, a.length + 2) === `f-${a}` && this.inTransition.delete(n), this.inTransition.size || this.clearTransitions(), 
                n === this.page && (null === (e = this.panzoom) || void 0 === e ? void 0 : e.isResting) && this.emit("settle");
            }
            onDecel(t, e = 0, i = 0, n = 0, s = 0) {
                if (this.option("dragFree")) return void this.setPageFromPosition();
                const {isRTL: o, isHorizontal: a, axis: r, pages: l} = this, c = l.length, h = Math.abs(Math.atan2(i, e) / (Math.PI / 180));
                let d = 0;
                if (d = h > 45 && h < 135 ? a ? 0 : i : a ? e : 0, !c) return;
                let u = this.page, p = o && a ? 1 : -1;
                const f = t.current[r] * p;
                let {pageIndex: g} = this.getPageFromPosition(f);
                Math.abs(d) > 5 ? (l[u].dim < document.documentElement["client" + (this.isHorizontal ? "Width" : "Height")] - 1 && (u = g), 
                u = o && a ? d < 0 ? u - 1 : u + 1 : d < 0 ? u + 1 : u - 1) : u = 0 === n && 0 === s ? u : g, 
                this.slideTo(u, {
                    transition: !1,
                    friction: t.option("decelFriction")
                });
            }
            onClick(t) {
                const e = t.target, i = e && E(e) ? e.dataset : null;
                let n, s;
                i && (void 0 !== i.carouselPage ? (s = "slideTo", n = i.carouselPage) : void 0 !== i.carouselNext ? s = "slideNext" : void 0 !== i.carouselPrev && (s = "slidePrev")), 
                s ? (t.preventDefault(), t.stopPropagation(), e && !e.hasAttribute("disabled") && this[s](n)) : this.emit("click", t);
            }
            onSlideTo(t) {
                const e = t.detail || 0;
                this.slideTo(this.getPageForSlide(e), {
                    friction: 0
                });
            }
            onChange(t, e = 0) {
                const i = this.page;
                this.prevPage = i, this.page = t, this.option("adaptiveHeight") && this.setViewportHeight(), 
                t !== i && (this.markSelectedSlides(), this.emit("change", t, i, e));
            }
            onRefresh() {
                let t = this.contentDim, e = this.viewportDim;
                this.updateMetrics(), this.contentDim === t && this.viewportDim === e || this.slideTo(this.page, {
                    friction: 0,
                    transition: !1
                });
            }
            onScroll() {
                var t;
                null === (t = this.viewport) || void 0 === t || t.scroll(0, 0);
            }
            onResize() {
                this.option("breakpoints") && this.processOptions();
            }
            onBeforeTransform(t) {
                this.lp !== t.current[this.axis] && (this.flipInfiniteTrack(), this.manageSlideVisiblity()), 
                this.lp = t.current.e;
            }
            onEndAnimation() {
                this.inTransition.size || this.emit("settle");
            }
            reInit(t = null, e = null) {
                this.destroy(), this.state = B.Init, this.prevPage = null, this.userOptions = t || this.userOptions, 
                this.userPlugins = e || this.userPlugins, this.processOptions();
            }
            slideTo(t = 0, {friction: e = this.option("friction"), transition: i = this.option("transition")} = {}) {
                if (this.state === B.Destroy) return;
                t = parseInt((t || 0).toString()) || 0;
                const n = this.getPageFromIndex(t), {axis: s, isHorizontal: o, isRTL: a, pages: r, panzoom: l} = this, c = r.length, h = a && o ? 1 : -1;
                if (!l || !c) return;
                if (this.page !== n) {
                    const e = new Event("beforeChange", {
                        bubbles: !0,
                        cancelable: !0
                    });
                    if (this.emit("beforeChange", e, t), e.defaultPrevented) return;
                }
                if (this.transitionTo(t, i)) return;
                let d = r[n].pos;
                if (this.isInfinite) {
                    const e = this.contentDim, i = l.target[s] * h;
                    if (2 === c) d += e * Math.floor(parseFloat(t + "") / 2); else d = [ d, d - e, d + e ].reduce((function(t, e) {
                        return Math.abs(e - i) < Math.abs(t - i) ? e : t;
                    }));
                }
                d *= h, Math.abs(l.target[s] - d) < 1 || (l.panTo({
                    x: o ? d : 0,
                    y: o ? 0 : d,
                    friction: e
                }), this.onChange(n));
            }
            slideToClosest(t) {
                if (this.panzoom) {
                    const {pageIndex: e} = this.getPageFromPosition();
                    this.slideTo(e, t);
                }
            }
            slideNext() {
                this.slideTo(this.page + 1);
            }
            slidePrev() {
                this.slideTo(this.page - 1);
            }
            clearTransitions() {
                this.inTransition.clear(), S(this.container, this.cn("inTransition"));
                const t = [ "to-prev", "to-next", "from-prev", "from-next" ];
                for (const e of this.slides) {
                    const i = e.el;
                    if (i) {
                        i.removeEventListener(G, this.onAnimationEnd), i.classList.remove(...t);
                        const n = e.transition;
                        n && i.classList.remove(`f-${n}Out`, `f-${n}In`);
                    }
                }
                this.manageSlideVisiblity();
            }
            addSlide(t, e) {
                var i, n, s, o;
                const a = this.panzoom, r = (null === (i = this.pages[this.page]) || void 0 === i ? void 0 : i.pos) || 0, l = (null === (n = this.pages[this.page]) || void 0 === n ? void 0 : n.dim) || 0, c = this.contentDim < this.viewportDim;
                let h = Array.isArray(e) ? e : [ e ];
                const d = [];
                for (const t of h) d.push(H(t));
                this.slides.splice(t, 0, ...d);
                for (let t = 0; t < this.slides.length; t++) this.slides[t].index = t;
                for (const t of d) this.emit("beforeInitSlide", t, t.index);
                if (this.page >= t && (this.page += d.length), this.updateMetrics(), a) {
                    const e = (null === (s = this.pages[this.page]) || void 0 === s ? void 0 : s.pos) || 0, i = (null === (o = this.pages[this.page]) || void 0 === o ? void 0 : o.dim) || 0, n = this.pages.length || 1, h = this.isRTL ? l - i : i - l, d = this.isRTL ? r - e : e - r;
                    c && 1 === n ? (t <= this.page && (a.current[this.axis] -= h, a.target[this.axis] -= h), 
                    a.panTo({
                        [this.isHorizontal ? "x" : "y"]: -1 * e
                    })) : d && t <= this.page && (a.target[this.axis] -= d, a.current[this.axis] -= d, 
                    a.requestTick());
                }
                for (const t of d) this.emit("initSlide", t, t.index);
            }
            prependSlide(t) {
                this.addSlide(0, t);
            }
            appendSlide(t) {
                this.addSlide(this.slides.length, t);
            }
            removeSlide(t) {
                const e = this.slides.length;
                t = (t % e + e) % e;
                const i = this.slides[t];
                if (i) {
                    this.removeSlideEl(i, !0), this.slides.splice(t, 1);
                    for (let t = 0; t < this.slides.length; t++) this.slides[t].index = t;
                    this.updateMetrics(), this.slideTo(this.page, {
                        friction: 0,
                        transition: !1
                    }), this.emit("destroySlide", i);
                }
            }
            updateMetrics() {
                const {panzoom: e, viewport: i, track: n, slides: s, isHorizontal: o, isInfinite: a} = this;
                if (!n) return;
                const r = o ? "width" : "height", l = o ? "offsetWidth" : "offsetHeight";
                if (i) {
                    let e = Math.max(i[l], t(i.getBoundingClientRect()[r], 1e3)), n = getComputedStyle(i), s = "padding", a = o ? "Right" : "Bottom";
                    e -= parseFloat(n[s + (o ? "Left" : "Top")]) + parseFloat(n[s + a]), this.viewportDim = e;
                }
                let c, h = 0;
                for (const [e, i] of s.entries()) {
                    let n = 0, o = 0;
                    !i.el && c ? (n = c.dim, o = c.gap) : (({dim: n, gap: o} = this.getSlideMetrics(i)), 
                    c = i), n = t(n, 1e3), o = t(o, 1e3), i.dim = n, i.gap = o, i.pos = h, h += n, (a || e < s.length - 1) && (h += o);
                }
                h = t(h, 1e3), this.contentDim = h, e && (e.contentRect[r] = h, e.contentRect[o ? "fullWidth" : "fullHeight"] = h), 
                this.pages = this.createPages(), this.pages = this.processPages(), this.state === B.Init && this.setInitialPage(), 
                this.page = Math.max(0, Math.min(this.page, this.pages.length - 1)), this.manageSlideVisiblity(), 
                this.emit("refresh");
            }
            getProgress(e, i = !1, n = !1) {
                void 0 === e && (e = this.page);
                const s = this, o = s.panzoom, a = s.contentDim, r = s.pages[e] || 0;
                if (!r || !o) return e > this.page ? -1 : 1;
                let l = -1 * o.current.e, c = t((l - r.pos) / (1 * r.dim), 1e3), h = c, d = c;
                this.isInfinite && !0 !== n && (h = t((l - r.pos + a) / (1 * r.dim), 1e3), d = t((l - r.pos - a) / (1 * r.dim), 1e3));
                let u = [ c, h, d ].reduce((function(t, e) {
                    return Math.abs(e) < Math.abs(t) ? e : t;
                }));
                return i ? u : u > 1 ? 1 : u < -1 ? -1 : u;
            }
            setViewportHeight() {
                const {page: t, pages: e, viewport: i, isHorizontal: n} = this;
                if (!i || !e[t]) return;
                let s = 0;
                n && this.track && (this.track.style.height = "auto", e[t].slides.forEach((t => {
                    t.el && (s = Math.max(s, t.el.offsetHeight));
                }))), i.style.height = s ? `${s}px` : "";
            }
            getPageForSlide(t) {
                for (const e of this.pages) for (const i of e.slides) if (i.index === t) return e.index;
                return -1;
            }
            getVisibleSlides(t = 0) {
                var e;
                const i = new Set;
                let {panzoom: n, contentDim: s, viewportDim: o, pages: a, page: r} = this;
                if (o) {
                    s = s + (null === (e = this.slides[this.slides.length - 1]) || void 0 === e ? void 0 : e.gap) || 0;
                    let l = 0;
                    l = n && n.state !== m.Init && n.state !== m.Destroy ? -1 * n.current[this.axis] : a[r] && a[r].pos || 0, 
                    this.isInfinite && (l -= Math.floor(l / s) * s), this.isRTL && this.isHorizontal && (l *= -1);
                    const c = l - o * t, h = l + o * (t + 1), d = this.isInfinite ? [ -1, 0, 1 ] : [ 0 ];
                    for (const t of this.slides) for (const e of d) {
                        const n = t.pos + e * s, o = n + t.dim + t.gap;
                        n < h && o > c && i.add(t);
                    }
                }
                return i;
            }
            getPageFromPosition(t) {
                const {viewportDim: e, contentDim: i, slides: n, pages: s, panzoom: o} = this, a = s.length, r = n.length, l = n[0], c = n[r - 1], h = this.option("center");
                let d = 0, u = 0, p = 0, f = void 0 === t ? -1 * ((null == o ? void 0 : o.target[this.axis]) || 0) : t;
                h && (f += .5 * e), this.isInfinite ? (f < l.pos - .5 * c.gap && (f -= i, p = -1), 
                f > c.pos + c.dim + .5 * c.gap && (f -= i, p = 1)) : f = Math.max(l.pos || 0, Math.min(f, c.pos));
                let g = c, m = n.find((t => {
                    const e = t.pos - .5 * g.gap, i = t.pos + t.dim + .5 * t.gap;
                    return g = t, f >= e && f < i;
                }));
                return m || (m = c), u = this.getPageForSlide(m.index), d = u + p * a, {
                    page: d,
                    pageIndex: u
                };
            }
            setPageFromPosition() {
                const {pageIndex: t} = this.getPageFromPosition();
                this.onChange(t);
            }
            destroy() {
                if ([ B.Destroy ].includes(this.state)) return;
                this.state = B.Destroy;
                const {container: t, viewport: e, track: i, slides: n, panzoom: s} = this, o = this.option("classes");
                t.removeEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), t.removeEventListener("slideTo", this.onSlideTo), window.removeEventListener("resize", this.onResize), 
                s && (s.destroy(), this.panzoom = null), n && n.forEach((t => {
                    this.removeSlideEl(t);
                })), this.detachPlugins(), e && (e.removeEventListener("scroll", this.onScroll), 
                e.offsetParent && i && i.offsetParent && e.replaceWith(...i.childNodes));
                for (const [e, i] of Object.entries(o)) "container" !== e && i && t.classList.remove(i);
                this.track = null, this.viewport = null, this.page = 0, this.slides = [];
                const a = this.events.get("ready");
                this.events = new Map, a && this.events.set("ready", a);
            }
        }
        Object.defineProperty(Q, "Panzoom", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: I
        }), Object.defineProperty(Q, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: j
        }), Object.defineProperty(Q, "Plugins", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: U
        });
        const tt = function(t) {
            if (!E(t)) return 0;
            const e = window.scrollY, i = window.innerHeight, n = e + i, s = t.getBoundingClientRect(), o = s.y + e, a = s.height, r = o + a;
            if (e > r || n < o) return 0;
            if (e < o && n > r) return 100;
            if (o < e && r > n) return 100;
            let l = a;
            o < e && (l -= e - o), r > n && (l -= r - n);
            const c = l / i * 100;
            return Math.round(c);
        }, et = !("undefined" == typeof window || !window.document || !window.document.createElement);
        let it;
        const nt = [ "a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden]):not(.fancybox-focus-guard)", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])' ].join(","), st = t => {
            if (t && et) {
                void 0 === it && document.createElement("div").focus({
                    get preventScroll() {
                        return it = !0, !1;
                    }
                });
                try {
                    if (it) t.focus({
                        preventScroll: !0
                    }); else {
                        const e = window.scrollY || document.body.scrollTop, i = window.scrollX || document.body.scrollLeft;
                        t.focus(), document.body.scrollTo({
                            top: e,
                            left: i,
                            behavior: "auto"
                        });
                    }
                } catch (t) {}
            }
        }, ot = () => {
            const t = document;
            let e, i = "", n = "", s = "";
            return t.fullscreenEnabled ? (i = "requestFullscreen", n = "exitFullscreen", s = "fullscreenElement") : t.webkitFullscreenEnabled && (i = "webkitRequestFullscreen", 
            n = "webkitExitFullscreen", s = "webkitFullscreenElement"), i && (e = {
                request: function(e = t.documentElement) {
                    return "webkitRequestFullscreen" === i ? e[i](Element.ALLOW_KEYBOARD_INPUT) : e[i]();
                },
                exit: function() {
                    return t[s] && t[n]();
                },
                isFullscreen: function() {
                    return t[s];
                }
            }), e;
        }, at = {
            animated: !0,
            autoFocus: !0,
            backdropClick: "close",
            Carousel: {
                classes: {
                    container: "fancybox__carousel",
                    viewport: "fancybox__viewport",
                    track: "fancybox__track",
                    slide: "fancybox__slide"
                }
            },
            closeButton: "auto",
            closeExisting: !1,
            commonCaption: !1,
            compact: () => window.matchMedia("(max-width: 578px), (max-height: 578px)").matches,
            contentClick: "toggleZoom",
            contentDblClick: !1,
            defaultType: "image",
            defaultDisplay: "flex",
            dragToClose: !0,
            Fullscreen: {
                autoStart: !1
            },
            groupAll: !1,
            groupAttr: "data-fancybox",
            hideClass: "f-fadeOut",
            hideScrollbar: !0,
            idle: 3500,
            keyboard: {
                Escape: "close",
                Delete: "close",
                Backspace: "close",
                PageUp: "next",
                PageDown: "prev",
                ArrowUp: "prev",
                ArrowDown: "next",
                ArrowRight: "next",
                ArrowLeft: "prev"
            },
            l10n: Object.assign(Object.assign({}, b), {
                CLOSE: "Close",
                NEXT: "Next",
                PREV: "Previous",
                MODAL: "You can close this modal content with the ESC key",
                ERROR: "Something Went Wrong, Please Try Again Later",
                IMAGE_ERROR: "Image Not Found",
                ELEMENT_NOT_FOUND: "HTML Element Not Found",
                AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
                AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
                IFRAME_ERROR: "Error Loading Page",
                TOGGLE_ZOOM: "Toggle zoom level",
                TOGGLE_THUMBS: "Toggle thumbnails",
                TOGGLE_SLIDESHOW: "Toggle slideshow",
                TOGGLE_FULLSCREEN: "Toggle full-screen mode",
                DOWNLOAD: "Download"
            }),
            parentEl: null,
            placeFocusBack: !0,
            showClass: "f-zoomInUp",
            startIndex: 0,
            tpl: {
                closeButton: '<button data-fancybox-close class="f-button is-close-btn" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg></button>',
                main: '<div class="fancybox__container" role="dialog" aria-modal="true" aria-label="{{MODAL}}" tabindex="-1">\n    <div class="fancybox__backdrop"></div>\n    <div class="fancybox__carousel"></div>\n    <div class="fancybox__footer"></div>\n  </div>'
            },
            trapFocus: !0,
            wheel: "zoom"
        };
        var rt, lt;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Closing = 2] = "Closing", 
            t[t.CustomClosing = 3] = "CustomClosing", t[t.Destroy = 4] = "Destroy";
        }(rt || (rt = {})), function(t) {
            t[t.Loading = 0] = "Loading", t[t.Opening = 1] = "Opening", t[t.Ready = 2] = "Ready", 
            t[t.Closing = 3] = "Closing";
        }(lt || (lt = {}));
        let ct = "", ht = !1, dt = !1, ut = null;
        const pt = () => {
            let t = "", e = "";
            const i = Oe.getInstance();
            if (i) {
                const n = i.carousel, s = i.getSlide();
                if (n && s) {
                    let o = s.slug || void 0, a = s.triggerEl || void 0;
                    e = o || i.option("slug") || "", !e && a && a.dataset && (e = a.dataset.fancybox || ""), 
                    e && "true" !== e && (t = "#" + e + (!o && n.slides.length > 1 ? "-" + (s.index + 1) : ""));
                }
            }
            return {
                hash: t,
                slug: e,
                index: 1
            };
        }, ft = () => {
            const t = new URL(document.URL).hash, e = t.slice(1).split("-"), i = e[e.length - 1], n = i && /^\+?\d+$/.test(i) && parseInt(e.pop() || "1", 10) || 1;
            return {
                hash: t,
                slug: e.join("-"),
                index: n
            };
        }, gt = () => {
            const {slug: t, index: e} = ft();
            if (!t) return;
            let i = document.querySelector(`[data-slug="${t}"]`);
            if (i && i.dispatchEvent(new CustomEvent("click", {
                bubbles: !0,
                cancelable: !0
            })), Oe.getInstance()) return;
            const n = document.querySelectorAll(`[data-fancybox="${t}"]`);
            n.length && (i = n[e - 1], i && i.dispatchEvent(new CustomEvent("click", {
                bubbles: !0,
                cancelable: !0
            })));
        }, mt = () => {
            if (!1 === Oe.defaults.Hash) return;
            const t = Oe.getInstance();
            if (!1 === (null == t ? void 0 : t.options.Hash)) return;
            const {slug: e, index: i} = ft(), {slug: n} = pt();
            t && (e === n ? t.jumpTo(i - 1) : (ht = !0, t.close())), gt();
        }, vt = () => {
            ut && clearTimeout(ut), queueMicrotask((() => {
                mt();
            }));
        }, bt = () => {
            window.addEventListener("hashchange", vt, !1), setTimeout((() => {
                mt();
            }), 500);
        };
        et && (/complete|interactive|loaded/.test(document.readyState) ? bt() : document.addEventListener("DOMContentLoaded", bt));
        const yt = "is-zooming-in";
        class wt extends _ {
            onCreateSlide(t, e, i) {
                const n = this.instance.optionFor(i, "src") || "";
                i.el && "image" === i.type && "string" == typeof n && this.setImage(i, n);
            }
            onRemoveSlide(t, e, i) {
                i.panzoom && i.panzoom.destroy(), i.panzoom = void 0, i.imageEl = void 0;
            }
            onChange(t, e, i, n) {
                S(this.instance.container, yt);
                for (const t of e.slides) {
                    const e = t.panzoom;
                    e && t.index !== i && e.reset(.35);
                }
            }
            onClose() {
                var t;
                const e = this.instance, i = e.container, n = e.getSlide();
                if (!i || !i.parentElement || !n) return;
                const {el: s, contentEl: o, panzoom: a, thumbElSrc: r} = n;
                if (!s || !r || !o || !a || a.isContentLoading || a.state === m.Init || a.state === m.Destroy) return;
                a.updateMetrics();
                let l = this.getZoomInfo(n);
                if (!l) return;
                this.instance.state = rt.CustomClosing, i.classList.remove(yt), i.classList.add("is-zooming-out"), 
                o.style.backgroundImage = `url('${r}')`;
                const c = i.getBoundingClientRect();
                1 === ((null === (t = window.visualViewport) || void 0 === t ? void 0 : t.scale) || 1) && Object.assign(i.style, {
                    position: "absolute",
                    top: `${i.offsetTop + window.scrollY}px`,
                    left: `${i.offsetLeft + window.scrollX}px`,
                    bottom: "auto",
                    right: "auto",
                    width: `${c.width}px`,
                    height: `${c.height}px`,
                    overflow: "hidden"
                });
                const {x: h, y: d, scale: u, opacity: p} = l;
                if (p) {
                    const t = ((t, e, i, n) => {
                        const s = e - t, o = n - i;
                        return e => i + ((e - t) / s * o || 0);
                    })(a.scale, u, 1, 0);
                    a.on("afterTransform", (() => {
                        o.style.opacity = t(a.scale) + "";
                    }));
                }
                a.on("endAnimation", (() => {
                    e.destroy();
                })), a.target.a = u, a.target.b = 0, a.target.c = 0, a.target.d = u, a.panTo({
                    x: h,
                    y: d,
                    scale: u,
                    friction: p ? .2 : .33,
                    ignoreBounds: !0
                }), a.isResting && e.destroy();
            }
            setImage(t, e) {
                const i = this.instance;
                t.src = e, this.process(t, e).then((e => {
                    const {contentEl: n, imageEl: s, thumbElSrc: o, el: a} = t;
                    if (i.isClosing() || !n || !s) return;
                    n.offsetHeight;
                    const r = !!i.isOpeningSlide(t) && this.getZoomInfo(t);
                    if (this.option("protected") && a) {
                        a.addEventListener("contextmenu", (t => {
                            t.preventDefault();
                        }));
                        const t = document.createElement("div");
                        P(t, "fancybox-protected"), n.appendChild(t);
                    }
                    if (o && r) {
                        const s = e.contentRect, a = Math.max(s.fullWidth, s.fullHeight);
                        let c = null;
                        !r.opacity && a > 1200 && (c = document.createElement("img"), P(c, "fancybox-ghost"), 
                        c.src = o, n.appendChild(c));
                        const h = () => {
                            c && (P(c, "f-fadeFastOut"), setTimeout((() => {
                                c && (c.remove(), c = null);
                            }), 200));
                        };
                        (l = o, new Promise(((t, e) => {
                            const i = new Image;
                            i.onload = t, i.onerror = e, i.src = l;
                        }))).then((() => {
                            i.hideLoading(t), t.state = lt.Opening, this.instance.emit("reveal", t), this.zoomIn(t).then((() => {
                                h(), this.instance.done(t);
                            }), (() => {})), c && setTimeout((() => {
                                h();
                            }), a > 2500 ? 800 : 200);
                        }), (() => {
                            i.hideLoading(t), i.revealContent(t);
                        }));
                    } else {
                        const n = this.optionFor(t, "initialSize"), s = this.optionFor(t, "zoom"), o = {
                            event: i.prevMouseMoveEvent || i.options.event,
                            friction: s ? .12 : 0
                        };
                        let a = i.optionFor(t, "showClass") || void 0, r = !0;
                        i.isOpeningSlide(t) && ("full" === n ? e.zoomToFull(o) : "cover" === n ? e.zoomToCover(o) : "max" === n ? e.zoomToMax(o) : r = !1, 
                        e.stop("current")), r && a && (a = e.isDragging ? "f-fadeIn" : ""), i.hideLoading(t), 
                        i.revealContent(t, a);
                    }
                    var l;
                }), (() => {
                    i.setError(t, "{{IMAGE_ERROR}}");
                }));
            }
            process(t, e) {
                return new Promise(((i, s) => {
                    var o;
                    const a = this.instance, r = t.el;
                    a.clearContent(t), a.showLoading(t);
                    let l = this.optionFor(t, "content");
                    if ("string" == typeof l && (l = n(l)), !l || !E(l)) {
                        if (l = document.createElement("img"), l instanceof HTMLImageElement) {
                            let i = "", n = t.caption;
                            i = "string" == typeof n && n ? n.replace(/<[^>]+>/gi, "").substring(0, 1e3) : `Image ${t.index + 1} of ${(null === (o = a.carousel) || void 0 === o ? void 0 : o.pages.length) || 1}`, 
                            l.src = e || "", l.alt = i, l.draggable = !1, t.srcset && l.setAttribute("srcset", t.srcset), 
                            this.instance.isOpeningSlide(t) && (l.fetchPriority = "high");
                        }
                        t.sizes && l.setAttribute("sizes", t.sizes);
                    }
                    P(l, "fancybox-image"), t.imageEl = l, a.setContent(t, l, !1);
                    t.panzoom = new I(r, u({
                        transformParent: !0
                    }, this.option("Panzoom") || {}, {
                        content: l,
                        width: (e, i) => a.optionFor(t, "width", "auto", i) || "auto",
                        height: (e, i) => a.optionFor(t, "height", "auto", i) || "auto",
                        wheel: () => {
                            const t = a.option("wheel");
                            return ("zoom" === t || "pan" == t) && t;
                        },
                        click: (e, i) => {
                            var n, s;
                            if (a.isCompact || a.isClosing()) return !1;
                            if (t.index !== (null === (n = a.getSlide()) || void 0 === n ? void 0 : n.index)) return !1;
                            if (i) {
                                const t = i.composedPath()[0];
                                if ([ "A", "BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO" ].includes(t.nodeName)) return !1;
                            }
                            let o = !i || i.target && (null === (s = t.contentEl) || void 0 === s ? void 0 : s.contains(i.target));
                            return a.option(o ? "contentClick" : "backdropClick") || !1;
                        },
                        dblClick: () => a.isCompact ? "toggleZoom" : a.option("contentDblClick") || !1,
                        spinner: !1,
                        panOnlyZoomed: !0,
                        wheelLimit: 1 / 0,
                        on: {
                            ready: t => {
                                i(t);
                            },
                            error: () => {
                                s();
                            },
                            destroy: () => {
                                s();
                            }
                        }
                    }));
                }));
            }
            zoomIn(t) {
                return new Promise(((e, i) => {
                    const n = this.instance, s = n.container, {panzoom: o, contentEl: a, el: r} = t;
                    o && o.updateMetrics();
                    const l = this.getZoomInfo(t);
                    if (!(l && r && a && o && s)) return void i();
                    const {x: c, y: h, scale: d, opacity: u} = l, p = () => {
                        t.state !== lt.Closing && (u && (a.style.opacity = Math.max(Math.min(1, 1 - (1 - o.scale) / (1 - d)), 0) + ""), 
                        o.scale >= 1 && o.scale > o.targetScale - .1 && e(o));
                    }, f = t => {
                        (t.scale < .99 || t.scale > 1.01) && !t.isDragging || (S(s, yt), a.style.opacity = "", 
                        t.off("endAnimation", f), t.off("touchStart", f), t.off("afterTransform", p), e(t));
                    };
                    o.on("endAnimation", f), o.on("touchStart", f), o.on("afterTransform", p), o.on([ "error", "destroy" ], (() => {
                        i();
                    })), o.panTo({
                        x: c,
                        y: h,
                        scale: d,
                        friction: 0,
                        ignoreBounds: !0
                    }), o.stop("current");
                    const g = {
                        event: "mousemove" === o.panMode ? n.prevMouseMoveEvent || n.options.event : void 0
                    }, m = this.optionFor(t, "initialSize");
                    P(s, yt), n.hideLoading(t), "full" === m ? o.zoomToFull(g) : "cover" === m ? o.zoomToCover(g) : "max" === m ? o.zoomToMax(g) : o.reset(.172);
                }));
            }
            getZoomInfo(t) {
                const {el: e, imageEl: i, thumbEl: n, panzoom: s} = t, o = this.instance, a = o.container;
                if (!e || !i || !n || !s || tt(n) < 3 || !this.optionFor(t, "zoom") || !a || o.state === rt.Destroy) return !1;
                if ("0" === getComputedStyle(a).getPropertyValue("--f-images-zoom")) return !1;
                const r = window.visualViewport || null;
                if (1 !== (r ? r.scale : 1)) return !1;
                let {top: l, left: c, width: h, height: d} = n.getBoundingClientRect(), {top: u, left: p, fitWidth: f, fitHeight: g} = s.contentRect;
                if (!(h && d && f && g)) return !1;
                const m = s.container.getBoundingClientRect();
                p += m.left, u += m.top;
                const v = -1 * (p + .5 * f - (c + .5 * h)), b = -1 * (u + .5 * g - (l + .5 * d)), y = h / f;
                let w = this.option("zoomOpacity") || !1;
                return "auto" === w && (w = Math.abs(h / d - f / g) > .1), {
                    x: v,
                    y: b,
                    scale: y,
                    opacity: w
                };
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.change", t.onChange), e.on("Carousel.createSlide", t.onCreateSlide), 
                e.on("Carousel.removeSlide", t.onRemoveSlide), e.on("close", t.onClose);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.change", t.onChange), e.off("Carousel.createSlide", t.onCreateSlide), 
                e.off("Carousel.removeSlide", t.onRemoveSlide), e.off("close", t.onClose);
            }
        }
        Object.defineProperty(wt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                initialSize: "fit",
                Panzoom: {
                    maxScale: 1
                },
                protected: !1,
                zoom: !0,
                zoomOpacity: "auto"
            }
        }), "function" == typeof SuppressedError && SuppressedError;
        const xt = "html", Et = "image", St = "map", Pt = "youtube", Ct = "vimeo", Tt = "html5video", Mt = (t, e = {}) => {
            const i = new URL(t), n = new URLSearchParams(i.search), s = new URLSearchParams;
            for (const [t, i] of [ ...n, ...Object.entries(e) ]) {
                let e = i + "";
                if ("t" === t) {
                    let t = e.match(/((\d*)m)?(\d*)s?/);
                    t && s.set("start", 60 * parseInt(t[2] || "0") + parseInt(t[3] || "0") + "");
                } else s.set(t, e);
            }
            let o = s + "", a = t.match(/#t=((.*)?\d+s)/);
            return a && (o += `#t=${a[1]}`), o;
        }, Ot = {
            ajax: null,
            autoSize: !0,
            iframeAttr: {
                allow: "autoplay; fullscreen",
                scrolling: "auto"
            },
            preload: !0,
            videoAutoplay: !0,
            videoRatio: 16 / 9,
            videoTpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>',
            videoFormat: "",
            vimeo: {
                byline: 1,
                color: "00adef",
                controls: 1,
                dnt: 1,
                muted: 0
            },
            youtube: {
                controls: 1,
                enablejsapi: 1,
                nocookie: 1,
                rel: 0,
                fs: 1
            }
        }, At = [ "image", "html", "ajax", "inline", "clone", "iframe", "map", "pdf", "html5video", "youtube", "vimeo" ];
        class Lt extends _ {
            onBeforeInitSlide(t, e, i) {
                this.processType(i);
            }
            onCreateSlide(t, e, i) {
                this.setContent(i);
            }
            onClearContent(t, e) {
                e.xhr && (e.xhr.abort(), e.xhr = null);
                const i = e.iframeEl;
                i && (i.onload = i.onerror = null, i.src = "//about:blank", e.iframeEl = null);
                const n = e.contentEl, s = e.placeholderEl;
                if ("inline" === e.type && n && s) n.classList.remove("fancybox__content"), "none" !== getComputedStyle(n).getPropertyValue("display") && (n.style.display = "none"), 
                setTimeout((() => {
                    s && (n && s.parentNode && s.parentNode.insertBefore(n, s), s.remove());
                }), 0), e.contentEl = void 0, e.placeholderEl = void 0; else for (;e.el && e.el.firstChild; ) e.el.removeChild(e.el.firstChild);
            }
            onSelectSlide(t, e, i) {
                i.state === lt.Ready && this.playVideo();
            }
            onUnselectSlide(t, e, i) {
                var n, s;
                if (i.type === Tt) {
                    try {
                        null === (s = null === (n = i.el) || void 0 === n ? void 0 : n.querySelector("video")) || void 0 === s || s.pause();
                    } catch (t) {}
                    return;
                }
                let o;
                i.type === Ct ? o = {
                    method: "pause",
                    value: "true"
                } : i.type === Pt && (o = {
                    event: "command",
                    func: "pauseVideo"
                }), o && i.iframeEl && i.iframeEl.contentWindow && i.iframeEl.contentWindow.postMessage(JSON.stringify(o), "*"), 
                i.poller && clearTimeout(i.poller);
            }
            onDone(t, e) {
                t.isCurrentSlide(e) && !t.isClosing() && this.playVideo();
            }
            onRefresh(t, e) {
                e.slides.forEach((t => {
                    t.el && (this.resizeIframe(t), this.setAspectRatio(t));
                }));
            }
            onMessage(t) {
                try {
                    let e = JSON.parse(t.data);
                    if ("https://player.vimeo.com" === t.origin) {
                        if ("ready" === e.event) for (let e of Array.from(document.getElementsByClassName("fancybox__iframe"))) e instanceof HTMLIFrameElement && e.contentWindow === t.source && (e.dataset.ready = "true");
                    } else if (t.origin.match(/^https:\/\/(www.)?youtube(-nocookie)?.com$/) && "onReady" === e.event) {
                        const t = document.getElementById(e.id);
                        t && (t.dataset.ready = "true");
                    }
                } catch (t) {}
            }
            loadAjaxContent(t) {
                const e = this.instance.optionFor(t, "src") || "";
                this.instance.showLoading(t);
                const i = this.instance, n = new XMLHttpRequest;
                i.showLoading(t), n.onreadystatechange = function() {
                    n.readyState === XMLHttpRequest.DONE && i.state === rt.Ready && (i.hideLoading(t), 
                    200 === n.status ? i.setContent(t, n.responseText) : i.setError(t, 404 === n.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
                };
                const s = t.ajax || null;
                n.open(s ? "POST" : "GET", e + ""), n.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), 
                n.setRequestHeader("X-Requested-With", "XMLHttpRequest"), n.send(s), t.xhr = n;
            }
            setInlineContent(t) {
                let e = null;
                if (E(t.src)) e = t.src; else if ("string" == typeof t.src) {
                    const i = t.src.split("#", 2).pop();
                    e = i ? document.getElementById(i) : null;
                }
                if (e) {
                    if ("clone" === t.type || e.closest(".fancybox__slide")) {
                        e = e.cloneNode(!0);
                        const i = e.dataset.animationName;
                        i && (e.classList.remove(i), delete e.dataset.animationName);
                        let n = e.getAttribute("id");
                        n = n ? `${n}--clone` : `clone-${this.instance.id}-${t.index}`, e.setAttribute("id", n);
                    } else if (e.parentNode) {
                        const i = document.createElement("div");
                        i.classList.add("fancybox-placeholder"), e.parentNode.insertBefore(i, e), t.placeholderEl = i;
                    }
                    this.instance.setContent(t, e);
                } else this.instance.setError(t, "{{ELEMENT_NOT_FOUND}}");
            }
            setIframeContent(t) {
                const {src: e, el: i} = t;
                if (!e || "string" != typeof e || !i) return;
                i.classList.add("is-loading");
                const n = this.instance, s = document.createElement("iframe");
                s.className = "fancybox__iframe", s.setAttribute("id", `fancybox__iframe_${n.id}_${t.index}`);
                for (const [e, i] of Object.entries(this.optionFor(t, "iframeAttr") || {})) s.setAttribute(e, i);
                s.onerror = () => {
                    n.setError(t, "{{IFRAME_ERROR}}");
                }, t.iframeEl = s;
                const o = this.optionFor(t, "preload");
                if ("iframe" !== t.type || !1 === o) return s.setAttribute("src", t.src + ""), n.setContent(t, s, !1), 
                this.resizeIframe(t), void n.revealContent(t);
                n.showLoading(t), s.onload = () => {
                    if (!s.src.length) return;
                    const e = "true" !== s.dataset.ready;
                    s.dataset.ready = "true", this.resizeIframe(t), e ? n.revealContent(t) : n.hideLoading(t);
                }, s.setAttribute("src", e), n.setContent(t, s, !1);
            }
            resizeIframe(t) {
                const {type: e, iframeEl: i} = t;
                if (e === Pt || e === Ct) return;
                const n = null == i ? void 0 : i.parentElement;
                if (!i || !n) return;
                let s = t.autoSize;
                void 0 === s && (s = this.optionFor(t, "autoSize"));
                let o = t.width || 0, a = t.height || 0;
                o && a && (s = !1);
                const r = n && n.style;
                if (!1 !== t.preload && !1 !== s && r) try {
                    const t = window.getComputedStyle(n), e = parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), s = parseFloat(t.paddingTop) + parseFloat(t.paddingBottom), l = i.contentWindow;
                    if (l) {
                        const t = l.document, i = t.getElementsByTagName(xt)[0], n = t.body;
                        r.width = "", n.style.overflow = "hidden", o = o || i.scrollWidth + e, r.width = `${o}px`, 
                        n.style.overflow = "", r.flex = "0 0 auto", r.height = `${n.scrollHeight}px`, a = i.scrollHeight + s;
                    }
                } catch (t) {}
                if (o || a) {
                    const t = {
                        flex: "0 1 auto",
                        width: "",
                        height: ""
                    };
                    o && "auto" !== o && (t.width = `${o}px`), a && "auto" !== a && (t.height = `${a}px`), 
                    Object.assign(r, t);
                }
            }
            playVideo() {
                const t = this.instance.getSlide();
                if (!t) return;
                const {el: e} = t;
                if (!e || !e.offsetParent) return;
                if (!this.optionFor(t, "videoAutoplay")) return;
                if (t.type === Tt) try {
                    const t = e.querySelector("video");
                    if (t) {
                        const e = t.play();
                        void 0 !== e && e.then((() => {})).catch((e => {
                            t.muted = !0, t.play();
                        }));
                    }
                } catch (t) {}
                if (t.type !== Pt && t.type !== Ct) return;
                const i = () => {
                    if (t.iframeEl && t.iframeEl.contentWindow) {
                        let e;
                        if ("true" === t.iframeEl.dataset.ready) return e = t.type === Pt ? {
                            event: "command",
                            func: "playVideo"
                        } : {
                            method: "play",
                            value: "true"
                        }, e && t.iframeEl.contentWindow.postMessage(JSON.stringify(e), "*"), void (t.poller = void 0);
                        t.type === Pt && (e = {
                            event: "listening",
                            id: t.iframeEl.getAttribute("id")
                        }, t.iframeEl.contentWindow.postMessage(JSON.stringify(e), "*"));
                    }
                    t.poller = setTimeout(i, 250);
                };
                i();
            }
            processType(t) {
                if (t.html) return t.type = xt, t.src = t.html, void (t.html = "");
                const e = this.instance.optionFor(t, "src", "");
                if (!e || "string" != typeof e) return;
                let i = t.type, n = null;
                if (n = e.match(/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|shorts\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
                    const s = this.optionFor(t, Pt), {nocookie: o} = s, a = function(t, e) {
                        var i = {};
                        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
                        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
                            var s = 0;
                            for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
                        }
                        return i;
                    }(s, [ "nocookie" ]), r = `www.youtube${o ? "-nocookie" : ""}.com`, l = Mt(e, a), c = encodeURIComponent(n[2]);
                    t.videoId = c, t.src = `https://${r}/embed/${c}?${l}`, t.thumbSrc = t.thumbSrc || `https://i.ytimg.com/vi/${c}/mqdefault.jpg`, 
                    i = Pt;
                } else if (n = e.match(/^.+vimeo.com\/(?:\/)?([\d]+)((\/|\?h=)([a-z0-9]+))?(.*)?/)) {
                    const s = Mt(e, this.optionFor(t, Ct)), o = encodeURIComponent(n[1]), a = n[4] || "";
                    t.videoId = o, t.src = `https://player.vimeo.com/video/${o}?${a ? `h=${a}${s ? "&" : ""}` : ""}${s}`, 
                    i = Ct;
                }
                if (!i && t.triggerEl) {
                    const e = t.triggerEl.dataset.type;
                    At.includes(e) && (i = e);
                }
                i || "string" == typeof e && ("#" === e.charAt(0) ? i = "inline" : (n = e.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i = Tt, 
                t.videoFormat = t.videoFormat || "video/" + ("ogv" === n[1] ? "ogg" : n[1])) : e.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i = Et : e.match(/\.(pdf)((\?|#).*)?$/i) && (i = "pdf")), 
                (n = e.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t.src = `https://maps.google.${n[1]}/?ll=${(n[2] ? n[2] + "&z=" + Math.floor(parseFloat(n[3])) + (n[4] ? n[4].replace(/^\//, "&") : "") : n[4] + "").replace(/\?/, "&")}&output=${n[4] && n[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, 
                i = St) : (n = e.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t.src = `https://maps.google.${n[1]}/maps?q=${n[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, 
                i = St), i = i || this.instance.option("defaultType"), t.type = i, i === Et && (t.thumbSrc = t.thumbSrc || t.src);
            }
            setContent(t) {
                const e = this.instance.optionFor(t, "src") || "";
                if (t && t.type && e) {
                    switch (t.type) {
                      case xt:
                        this.instance.setContent(t, e);
                        break;

                      case Tt:
                        const i = this.option("videoTpl");
                        i && this.instance.setContent(t, i.replace(/\{\{src\}\}/gi, e + "").replace(/\{\{format\}\}/gi, this.optionFor(t, "videoFormat") || "").replace(/\{\{poster\}\}/gi, t.poster || t.thumbSrc || ""));
                        break;

                      case "inline":
                      case "clone":
                        this.setInlineContent(t);
                        break;

                      case "ajax":
                        this.loadAjaxContent(t);
                        break;

                      case "pdf":
                      case St:
                      case Pt:
                      case Ct:
                        t.preload = !1;

                      case "iframe":
                        this.setIframeContent(t);
                    }
                    this.setAspectRatio(t);
                }
            }
            setAspectRatio(t) {
                const e = t.contentEl;
                if (!(t.el && e && t.type && [ Pt, Ct, Tt ].includes(t.type))) return;
                let i, n = t.width || "auto", s = t.height || "auto";
                if ("auto" === n || "auto" === s) {
                    i = this.optionFor(t, "videoRatio");
                    const e = (i + "").match(/(\d+)\s*\/\s?(\d+)/);
                    i = e && e.length > 2 ? parseFloat(e[1]) / parseFloat(e[2]) : parseFloat(i + "");
                } else n && s && (i = n / s);
                if (!i) return;
                e.style.aspectRatio = "", e.style.width = "", e.style.height = "", e.offsetHeight;
                const o = e.getBoundingClientRect(), a = o.width || 1, r = o.height || 1;
                e.style.aspectRatio = i + "", i < a / r ? (s = "auto" === s ? r : Math.min(r, s), 
                e.style.width = "auto", e.style.height = `${s}px`) : (n = "auto" === n ? a : Math.min(a, n), 
                e.style.width = `${n}px`, e.style.height = "auto");
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.beforeInitSlide", t.onBeforeInitSlide), e.on("Carousel.createSlide", t.onCreateSlide), 
                e.on("Carousel.selectSlide", t.onSelectSlide), e.on("Carousel.unselectSlide", t.onUnselectSlide), 
                e.on("Carousel.Panzoom.refresh", t.onRefresh), e.on("done", t.onDone), e.on("clearContent", t.onClearContent), 
                window.addEventListener("message", t.onMessage);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.beforeInitSlide", t.onBeforeInitSlide), e.off("Carousel.createSlide", t.onCreateSlide), 
                e.off("Carousel.selectSlide", t.onSelectSlide), e.off("Carousel.unselectSlide", t.onUnselectSlide), 
                e.off("Carousel.Panzoom.refresh", t.onRefresh), e.off("done", t.onDone), e.off("clearContent", t.onClearContent), 
                window.removeEventListener("message", t.onMessage);
            }
        }
        Object.defineProperty(Lt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Ot
        });
        const zt = "play", Rt = "pause", kt = "ready";
        class It extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: kt
                }), Object.defineProperty(this, "inHover", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "timer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "progressBar", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            get isActive() {
                return this.state !== kt;
            }
            onReady(t) {
                this.option("autoStart") && (t.isInfinite || t.page < t.pages.length - 1) && this.start();
            }
            onChange() {
                this.removeProgressBar(), this.pause();
            }
            onSettle() {
                this.resume();
            }
            onVisibilityChange() {
                "visible" === document.visibilityState ? this.resume() : this.pause();
            }
            onMouseEnter() {
                this.inHover = !0, this.pause();
            }
            onMouseLeave() {
                var t;
                this.inHover = !1, (null === (t = this.instance.panzoom) || void 0 === t ? void 0 : t.isResting) && this.resume();
            }
            onTimerEnd() {
                const t = this.instance;
                "play" === this.state && (t.isInfinite || t.page !== t.pages.length - 1 ? t.slideNext() : t.slideTo(0));
            }
            removeProgressBar() {
                this.progressBar && (this.progressBar.remove(), this.progressBar = null);
            }
            createProgressBar() {
                var t;
                if (!this.option("showProgress")) return null;
                this.removeProgressBar();
                const e = this.instance, i = (null === (t = e.pages[e.page]) || void 0 === t ? void 0 : t.slides) || [];
                let n = this.option("progressParentEl");
                if (n || (n = (1 === i.length ? i[0].el : null) || e.viewport), !n) return null;
                const s = document.createElement("div");
                return P(s, "f-progress"), n.prepend(s), this.progressBar = s, s.offsetHeight, s;
            }
            set() {
                const t = this, e = t.instance;
                if (e.pages.length < 2) return;
                if (t.timer) return;
                const i = t.option("timeout");
                t.state = zt, P(e.container, "has-autoplay");
                let n = t.createProgressBar();
                n && (n.style.transitionDuration = `${i}ms`, n.style.transform = "scaleX(1)"), t.timer = setTimeout((() => {
                    t.timer = null, t.inHover || t.onTimerEnd();
                }), i), t.emit("set");
            }
            clear() {
                const t = this;
                t.timer && (clearTimeout(t.timer), t.timer = null), t.removeProgressBar();
            }
            start() {
                const t = this;
                if (t.set(), t.state !== kt) {
                    if (t.option("pauseOnHover")) {
                        const e = t.instance.container;
                        e.addEventListener("mouseenter", t.onMouseEnter, !1), e.addEventListener("mouseleave", t.onMouseLeave, !1);
                    }
                    document.addEventListener("visibilitychange", t.onVisibilityChange, !1), t.emit("start");
                }
            }
            stop() {
                const t = this, e = t.state, i = t.instance.container;
                t.clear(), t.state = kt, i.removeEventListener("mouseenter", t.onMouseEnter, !1), 
                i.removeEventListener("mouseleave", t.onMouseLeave, !1), document.removeEventListener("visibilitychange", t.onVisibilityChange, !1), 
                S(i, "has-autoplay"), e !== kt && t.emit("stop");
            }
            pause() {
                const t = this;
                t.state === zt && (t.state = Rt, t.clear(), t.emit(Rt));
            }
            resume() {
                const t = this, e = t.instance;
                if (e.isInfinite || e.page !== e.pages.length - 1) if (t.state !== zt) {
                    if (t.state === Rt && !t.inHover) {
                        const e = new Event("resume", {
                            bubbles: !0,
                            cancelable: !0
                        });
                        t.emit("resume", e), e.defaultPrevented || t.set();
                    }
                } else t.set(); else t.stop();
            }
            toggle() {
                this.state === zt || this.state === Rt ? this.stop() : this.start();
            }
            attach() {
                const t = this, e = t.instance;
                e.on("ready", t.onReady), e.on("Panzoom.startAnimation", t.onChange), e.on("Panzoom.endAnimation", t.onSettle), 
                e.on("Panzoom.touchMove", t.onChange);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("ready", t.onReady), e.off("Panzoom.startAnimation", t.onChange), e.off("Panzoom.endAnimation", t.onSettle), 
                e.off("Panzoom.touchMove", t.onChange), t.stop();
            }
        }
        Object.defineProperty(It, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                autoStart: !0,
                pauseOnHover: !0,
                progressParentEl: null,
                showProgress: !0,
                timeout: 3e3
            }
        });
        class Dt extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "ref", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onPrepare(t) {
                const e = t.carousel;
                if (!e) return;
                const i = t.container;
                i && (e.options.Autoplay = u({
                    autoStart: !1
                }, this.option("Autoplay") || {}, {
                    pauseOnHover: !1,
                    timeout: this.option("timeout"),
                    progressParentEl: () => this.option("progressParentEl") || null,
                    on: {
                        start: () => {
                            t.emit("startSlideshow");
                        },
                        set: e => {
                            var n;
                            i.classList.add("has-slideshow"), (null === (n = t.getSlide()) || void 0 === n ? void 0 : n.state) !== lt.Ready && e.pause();
                        },
                        stop: () => {
                            i.classList.remove("has-slideshow"), t.isCompact || t.endIdle(), t.emit("endSlideshow");
                        },
                        resume: (e, i) => {
                            var n, s, o;
                            !i || !i.cancelable || (null === (n = t.getSlide()) || void 0 === n ? void 0 : n.state) === lt.Ready && (null === (o = null === (s = t.carousel) || void 0 === s ? void 0 : s.panzoom) || void 0 === o ? void 0 : o.isResting) || i.preventDefault();
                        }
                    }
                }), e.attachPlugins({
                    Autoplay: It
                }), this.ref = e.plugins.Autoplay);
            }
            onReady(t) {
                const e = t.carousel, i = this.ref;
                i && e && this.option("playOnStart") && (e.isInfinite || e.page < e.pages.length - 1) && i.start();
            }
            onDone(t, e) {
                const i = this.ref, n = t.carousel;
                if (!i || !n) return;
                const s = e.panzoom;
                s && s.on("startAnimation", (() => {
                    t.isCurrentSlide(e) && i.stop();
                })), t.isCurrentSlide(e) && i.resume();
            }
            onKeydown(t, e) {
                var i;
                const n = this.ref;
                n && e === this.option("key") && "BUTTON" !== (null === (i = document.activeElement) || void 0 === i ? void 0 : i.nodeName) && n.toggle();
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.init", t.onPrepare), e.on("Carousel.ready", t.onReady), e.on("done", t.onDone), 
                e.on("keydown", t.onKeydown);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.init", t.onPrepare), e.off("Carousel.ready", t.onReady), e.off("done", t.onDone), 
                e.off("keydown", t.onKeydown);
            }
        }
        Object.defineProperty(Dt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                key: " ",
                playOnStart: !1,
                progressParentEl: t => {
                    var e;
                    return (null === (e = t.instance.container) || void 0 === e ? void 0 : e.querySelector(".fancybox__toolbar [data-fancybox-toggle-slideshow]")) || t.instance.container;
                },
                timeout: 3e3
            }
        });
        const Ft = {
            classes: {
                container: "f-thumbs f-carousel__thumbs",
                viewport: "f-thumbs__viewport",
                track: "f-thumbs__track",
                slide: "f-thumbs__slide",
                isResting: "is-resting",
                isSelected: "is-selected",
                isLoading: "is-loading",
                hasThumbs: "has-thumbs"
            },
            minCount: 2,
            parentEl: null,
            thumbTpl: '<button class="f-thumbs__slide__button" tabindex="0" type="button" aria-label="{{GOTO}}" data-carousel-index="%i"><img class="f-thumbs__slide__img" data-lazy-src="{{%s}}" alt="" /></button>',
            type: "modern"
        };
        var jt;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Hidden = 2] = "Hidden";
        }(jt || (jt = {}));
        const Bt = "isResting", Ht = "thumbWidth", Nt = "thumbHeight", _t = "thumbClipWidth";
        let $t = class extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "type", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "modern"
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "track", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "carousel", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "thumbWidth", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbClipWidth", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbHeight", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbGap", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbExtraGap", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: jt.Init
                });
            }
            get isModern() {
                return "modern" === this.type;
            }
            onInitSlide(t, e) {
                const i = e.el ? e.el.dataset : void 0;
                i && (e.thumbSrc = i.thumbSrc || e.thumbSrc || "", e[_t] = parseFloat(i[_t] || "") || e[_t] || 0, 
                e[Nt] = parseFloat(i.thumbHeight || "") || e[Nt] || 0), this.addSlide(e);
            }
            onInitSlides() {
                this.build();
            }
            onChange() {
                var t;
                if (!this.isModern) return;
                const e = this.container, i = this.instance, n = i.panzoom, s = this.carousel, a = s ? s.panzoom : null, r = i.page;
                if (n && s && a) {
                    if (n.isDragging) {
                        S(e, this.cn(Bt));
                        let n = (null === (t = s.pages[r]) || void 0 === t ? void 0 : t.pos) || 0;
                        n += i.getProgress(r) * (this[_t] + this.thumbGap);
                        let o = a.getBounds();
                        -1 * n > o.x.min && -1 * n < o.x.max && a.panTo({
                            x: -1 * n,
                            friction: .12
                        });
                    } else o(e, this.cn(Bt), n.isResting);
                    this.shiftModern();
                }
            }
            onRefresh() {
                this.updateProps();
                for (const t of this.instance.slides || []) this.resizeModernSlide(t);
                this.shiftModern();
            }
            isDisabled() {
                const t = this.option("minCount") || 0;
                if (t) {
                    const e = this.instance;
                    let i = 0;
                    for (const t of e.slides || []) t.thumbSrc && i++;
                    if (i < t) return !0;
                }
                const e = this.option("type");
                return [ "modern", "classic" ].indexOf(e) < 0;
            }
            getThumb(t) {
                const e = this.option("thumbTpl") || "";
                return {
                    html: this.instance.localize(e, [ [ "%i", t.index ], [ "%d", t.index + 1 ], [ "%s", t.thumbSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" ] ])
                };
            }
            addSlide(t) {
                const e = this.carousel;
                e && e.addSlide(t.index, this.getThumb(t));
            }
            getSlides() {
                const t = [];
                for (const e of this.instance.slides || []) t.push(this.getThumb(e));
                return t;
            }
            resizeModernSlide(t) {
                this.isModern && (t[Ht] = t[_t] && t[Nt] ? Math.round(this[Nt] * (t[_t] / t[Nt])) : this[Ht]);
            }
            updateProps() {
                const t = this.container;
                if (!t) return;
                const e = e => parseFloat(getComputedStyle(t).getPropertyValue("--f-thumb-" + e)) || 0;
                this.thumbGap = e("gap"), this.thumbExtraGap = e("extra-gap"), this[Ht] = e("width") || 40, 
                this[_t] = e("clip-width") || 40, this[Nt] = e("height") || 40;
            }
            build() {
                const t = this;
                if (t.state !== jt.Init) return;
                if (t.isDisabled()) return void t.emit("disabled");
                const e = t.instance, i = e.container, n = t.getSlides(), s = t.option("type");
                t.type = s;
                const o = t.option("parentEl"), a = t.cn("container"), r = t.cn("track");
                let l = null == o ? void 0 : o.querySelector("." + a);
                l || (l = document.createElement("div"), P(l, a), o ? o.appendChild(l) : i.after(l)), 
                P(l, `is-${s}`), P(i, t.cn("hasThumbs")), t.container = l, t.updateProps();
                let c = l.querySelector("." + r);
                c || (c = document.createElement("div"), P(c, t.cn("track")), l.appendChild(c)), 
                t.track = c;
                const h = u({}, {
                    track: c,
                    infinite: !1,
                    center: !0,
                    fill: "classic" === s,
                    dragFree: !0,
                    slidesPerPage: 1,
                    transition: !1,
                    preload: .25,
                    friction: .12,
                    Panzoom: {
                        maxVelocity: 0
                    },
                    Dots: !1,
                    Navigation: !1,
                    classes: {
                        container: "f-thumbs",
                        viewport: "f-thumbs__viewport",
                        track: "f-thumbs__track",
                        slide: "f-thumbs__slide"
                    }
                }, t.option("Carousel") || {}, {
                    Sync: {
                        target: e
                    },
                    slides: n
                }), d = new e.constructor(l, h);
                d.on("createSlide", ((e, i) => {
                    t.setProps(i.index), t.emit("createSlide", i, i.el);
                })), d.on("ready", (() => {
                    t.shiftModern(), t.emit("ready");
                })), d.on("refresh", (() => {
                    t.shiftModern();
                })), d.on("Panzoom.click", ((e, i, n) => {
                    t.onClick(n);
                })), t.carousel = d, t.state = jt.Ready;
            }
            onClick(t) {
                t.preventDefault(), t.stopPropagation();
                const e = this.instance, {pages: i, page: n} = e, s = t => {
                    if (t) {
                        const e = t.closest("[data-carousel-index]");
                        if (e) return [ parseInt(e.dataset.carouselIndex || "", 10) || 0, e ];
                    }
                    return [ -1, void 0 ];
                }, o = (t, e) => {
                    const i = document.elementFromPoint(t, e);
                    return i ? s(i) : [ -1, void 0 ];
                };
                let [a, r] = s(t.target);
                if (a > -1) return;
                const l = this[_t], c = t.clientX, h = t.clientY;
                let [d, u] = o(c - l, h), [p, f] = o(c + l, h);
                u && f ? (a = Math.abs(c - u.getBoundingClientRect().right) < Math.abs(c - f.getBoundingClientRect().left) ? d : p, 
                a === n && (a = a === d ? p : d)) : u ? a = d : f && (a = p), a > -1 && i[a] && e.slideTo(a);
            }
            getShift(t) {
                var e;
                const i = this, {instance: n} = i, s = i.carousel;
                if (!n || !s) return 0;
                const o = i[Ht], a = i[_t], r = i.thumbGap, l = i.thumbExtraGap;
                if (!(null === (e = s.slides[t]) || void 0 === e ? void 0 : e.el)) return 0;
                const c = .5 * (o - a), h = n.pages.length - 1;
                let d = n.getProgress(0), u = n.getProgress(h), p = n.getProgress(t, !1, !0), f = 0, g = c + l + r;
                const m = d < 0 && d > -1, v = u > 0 && u < 1;
                return 0 === t ? (f = g * Math.abs(d), v && 1 === d && (f -= g * Math.abs(u))) : t === h ? (f = g * Math.abs(u) * -1, 
                m && -1 === u && (f += g * Math.abs(d))) : m || v ? (f = -1 * g, f += g * Math.abs(d), 
                f += g * (1 - Math.abs(u))) : f = g * p, f;
            }
            setProps(e) {
                var i;
                const n = this;
                if (!n.isModern) return;
                const {instance: s} = n, o = n.carousel;
                if (s && o) {
                    const a = null === (i = o.slides[e]) || void 0 === i ? void 0 : i.el;
                    if (a && a.childNodes.length) {
                        let i = t(1 - Math.abs(s.getProgress(e))), o = t(n.getShift(e));
                        a.style.setProperty("--progress", i ? i + "" : ""), a.style.setProperty("--shift", o + "");
                    }
                }
            }
            shiftModern() {
                const t = this;
                if (!t.isModern) return;
                const {instance: e, track: i} = t, n = e.panzoom, s = t.carousel;
                if (!(e && i && n && s)) return;
                if (n.state === m.Init || n.state === m.Destroy) return;
                for (const i of e.slides) t.setProps(i.index);
                let o = (t[_t] + t.thumbGap) * (s.slides.length || 0);
                i.style.setProperty("--width", o + "");
            }
            cleanup() {
                const t = this;
                t.carousel && t.carousel.destroy(), t.carousel = null, t.container && t.container.remove(), 
                t.container = null, t.track && t.track.remove(), t.track = null, t.state = jt.Init, 
                S(t.instance.container, t.cn("hasThumbs"));
            }
            attach() {
                const t = this, e = t.instance;
                e.on("initSlide", t.onInitSlide), e.state === B.Init ? e.on("initSlides", t.onInitSlides) : t.onInitSlides(), 
                e.on([ "change", "Panzoom.afterTransform" ], t.onChange), e.on("Panzoom.refresh", t.onRefresh);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("initSlide", t.onInitSlide), e.off("initSlides", t.onInitSlides), e.off([ "change", "Panzoom.afterTransform" ], t.onChange), 
                e.off("Panzoom.refresh", t.onRefresh), t.cleanup();
            }
        };
        Object.defineProperty($t, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Ft
        });
        const Wt = Object.assign(Object.assign({}, Ft), {
            key: "t",
            showOnStart: !0,
            parentEl: null
        }), Xt = "is-masked", qt = "aria-hidden";
        class Yt extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "ref", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "hidden", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                });
            }
            get isEnabled() {
                const t = this.ref;
                return t && !t.isDisabled();
            }
            get isHidden() {
                return this.hidden;
            }
            onClick(t, e) {
                e.stopPropagation();
            }
            onCreateSlide(t, e) {
                var i, n, s;
                const o = (null === (s = null === (n = null === (i = this.instance) || void 0 === i ? void 0 : i.carousel) || void 0 === n ? void 0 : n.slides[e.index]) || void 0 === s ? void 0 : s.type) || "", a = e.el;
                if (a && o) {
                    let t = `for-${o}`;
                    [ "video", "youtube", "vimeo", "html5video" ].includes(o) && (t += " for-video"), 
                    P(a, t);
                }
            }
            onInit() {
                var t;
                const e = this, i = e.instance, n = i.carousel;
                if (e.ref || !n) return;
                const s = e.option("parentEl") || i.footer || i.container;
                if (!s) return;
                const o = u({}, e.options, {
                    parentEl: s,
                    classes: {
                        container: "f-thumbs fancybox__thumbs"
                    },
                    Carousel: {
                        Sync: {
                            friction: i.option("Carousel.friction") || 0
                        }
                    },
                    on: {
                        ready: t => {
                            const i = t.container;
                            i && this.hidden && (e.refresh(), i.style.transition = "none", e.hide(), i.offsetHeight, 
                            queueMicrotask((() => {
                                i.style.transition = "", e.show();
                            })));
                        }
                    }
                });
                o.Carousel = o.Carousel || {}, o.Carousel.on = u((null === (t = e.options.Carousel) || void 0 === t ? void 0 : t.on) || {}, {
                    click: this.onClick,
                    createSlide: this.onCreateSlide
                }), n.options.Thumbs = o, n.attachPlugins({
                    Thumbs: $t
                }), e.ref = n.plugins.Thumbs, e.option("showOnStart") || (e.ref.state = jt.Hidden, 
                e.hidden = !0);
            }
            onResize() {
                var t;
                const e = null === (t = this.ref) || void 0 === t ? void 0 : t.container;
                e && (e.style.maxHeight = "");
            }
            onKeydown(t, e) {
                const i = this.option("key");
                i && i === e && this.toggle();
            }
            toggle() {
                const t = this.ref;
                if (t && !t.isDisabled()) return t.state === jt.Hidden ? (t.state = jt.Init, void t.build()) : void (this.hidden ? this.show() : this.hide());
            }
            show() {
                const t = this.ref;
                if (!t || t.isDisabled()) return;
                const e = t.container;
                e && (this.refresh(), e.offsetHeight, e.removeAttribute(qt), e.classList.remove(Xt), 
                this.hidden = !1);
            }
            hide() {
                const t = this.ref, e = t && t.container;
                e && (this.refresh(), e.offsetHeight, e.classList.add(Xt), e.setAttribute(qt, "true")), 
                this.hidden = !0;
            }
            refresh() {
                const t = this.ref;
                if (!t || !t.state) return;
                const e = t.container, i = (null == e ? void 0 : e.firstChild) || null;
                e && i && i.childNodes.length && (e.style.maxHeight = `${i.getBoundingClientRect().height}px`);
            }
            attach() {
                const t = this, e = t.instance;
                e.state === rt.Init ? e.on("Carousel.init", t.onInit) : t.onInit(), e.on("resize", t.onResize), 
                e.on("keydown", t.onKeydown);
            }
            detach() {
                var t;
                const e = this, i = e.instance;
                i.off("Carousel.init", e.onInit), i.off("resize", e.onResize), i.off("keydown", e.onKeydown), 
                null === (t = i.carousel) || void 0 === t || t.detachPlugins([ "Thumbs" ]), e.ref = null;
            }
        }
        Object.defineProperty(Yt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Wt
        });
        const Vt = {
            panLeft: {
                icon: '<svg><path d="M5 12h14M5 12l6 6M5 12l6-6"/></svg>',
                change: {
                    panX: -100
                }
            },
            panRight: {
                icon: '<svg><path d="M5 12h14M13 18l6-6M13 6l6 6"/></svg>',
                change: {
                    panX: 100
                }
            },
            panUp: {
                icon: '<svg><path d="M12 5v14M18 11l-6-6M6 11l6-6"/></svg>',
                change: {
                    panY: -100
                }
            },
            panDown: {
                icon: '<svg><path d="M12 5v14M18 13l-6 6M6 13l6 6"/></svg>',
                change: {
                    panY: 100
                }
            },
            zoomIn: {
                icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M11 8v6M8 11h6"/></svg>',
                action: "zoomIn"
            },
            zoomOut: {
                icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
                action: "zoomOut"
            },
            toggle1to1: {
                icon: '<svg><path d="M3.51 3.07c5.74.02 11.48-.02 17.22.02 1.37.1 2.34 1.64 2.18 3.13 0 4.08.02 8.16 0 12.23-.1 1.54-1.47 2.64-2.79 2.46-5.61-.01-11.24.02-16.86-.01-1.36-.12-2.33-1.65-2.17-3.14 0-4.07-.02-8.16 0-12.23.1-1.36 1.22-2.48 2.42-2.46Z"/><path d="M5.65 8.54h1.49v6.92m8.94-6.92h1.49v6.92M11.5 9.4v.02m0 5.18v0"/></svg>',
                action: "toggleZoom"
            },
            toggleZoom: {
                icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
                action: "toggleZoom"
            },
            iterateZoom: {
                icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
                action: "iterateZoom"
            },
            rotateCCW: {
                icon: '<svg><path d="M15 4.55a8 8 0 0 0-6 14.9M9 15v5H4M18.37 7.16v.01M13 19.94v.01M16.84 18.37v.01M19.37 15.1v.01M19.94 11v.01"/></svg>',
                action: "rotateCCW"
            },
            rotateCW: {
                icon: '<svg><path d="M9 4.55a8 8 0 0 1 6 14.9M15 15v5h5M5.63 7.16v.01M4.06 11v.01M4.63 15.1v.01M7.16 18.37v.01M11 19.94v.01"/></svg>',
                action: "rotateCW"
            },
            flipX: {
                icon: '<svg style="stroke-width: 1.3"><path d="M12 3v18M16 7v10h5L16 7M8 7v10H3L8 7"/></svg>',
                action: "flipX"
            },
            flipY: {
                icon: '<svg style="stroke-width: 1.3"><path d="M3 12h18M7 16h10L7 21v-5M7 8h10L7 3v5"/></svg>',
                action: "flipY"
            },
            fitX: {
                icon: '<svg><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6M10 18H3M21 18h-7M6 15l-3 3 3 3M18 15l3 3-3 3"/></svg>',
                action: "fitX"
            },
            fitY: {
                icon: '<svg><path d="M12 20H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M18 14v7M18 3v7M15 18l3 3 3-3M15 6l3-3 3 3"/></svg>',
                action: "fitY"
            },
            reset: {
                icon: '<svg><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>',
                action: "reset"
            },
            toggleFS: {
                icon: '<svg><g><path d="M14.5 9.5 21 3m0 0h-6m6 0v6M3 21l6.5-6.5M3 21v-6m0 6h6"/></g><g><path d="m14 10 7-7m-7 7h6m-6 0V4M3 21l7-7m0 0v6m0-6H4"/></g></svg>',
                action: "toggleFS"
            }
        };
        var Zt;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Disabled = 2] = "Disabled";
        }(Zt || (Zt = {}));
        const Ut = {
            absolute: "auto",
            display: {
                left: [ "infobar" ],
                middle: [],
                right: [ "iterateZoom", "slideshow", "fullscreen", "thumbs", "close" ]
            },
            enabled: "auto",
            items: {
                infobar: {
                    tpl: '<div class="fancybox__infobar" tabindex="-1"><span data-fancybox-current-index></span>/<span data-fancybox-count></span></div>'
                },
                download: {
                    tpl: '<a class="f-button" title="{{DOWNLOAD}}" data-fancybox-download href="javasript:;"><svg><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5 5-5M12 4v12"/></svg></a>'
                },
                prev: {
                    tpl: '<button class="f-button" title="{{PREV}}" data-fancybox-prev><svg><path d="m15 6-6 6 6 6"/></svg></button>'
                },
                next: {
                    tpl: '<button class="f-button" title="{{NEXT}}" data-fancybox-next><svg><path d="m9 6 6 6-6 6"/></svg></button>'
                },
                slideshow: {
                    tpl: '<button class="f-button" title="{{TOGGLE_SLIDESHOW}}" data-fancybox-toggle-slideshow><svg><g><path d="M8 4v16l13 -8z"></path></g><g><path d="M8 4v15M17 4v15"/></g></svg></button>'
                },
                fullscreen: {
                    tpl: '<button class="f-button" title="{{TOGGLE_FULLSCREEN}}" data-fancybox-toggle-fullscreen><svg><g><path d="M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2M16 4h2a2 2 0 0 1 2 2v2M16 20h2a2 2 0 0 0 2-2v-2"/></g><g><path d="M15 19v-2a2 2 0 0 1 2-2h2M15 5v2a2 2 0 0 0 2 2h2M5 15h2a2 2 0 0 1 2 2v2M5 9h2a2 2 0 0 0 2-2V5"/></g></svg></button>'
                },
                thumbs: {
                    tpl: '<button class="f-button" title="{{TOGGLE_THUMBS}}" data-fancybox-toggle-thumbs><svg><circle cx="5.5" cy="5.5" r="1"/><circle cx="12" cy="5.5" r="1"/><circle cx="18.5" cy="5.5" r="1"/><circle cx="5.5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18.5" cy="12" r="1"/><circle cx="5.5" cy="18.5" r="1"/><circle cx="12" cy="18.5" r="1"/><circle cx="18.5" cy="18.5" r="1"/></svg></button>'
                },
                close: {
                    tpl: '<button class="f-button" title="{{CLOSE}}" data-fancybox-close><svg><path d="m19.5 4.5-15 15M4.5 4.5l15 15"/></svg></button>'
                }
            },
            parentEl: null
        }, Gt = {
            tabindex: "-1",
            width: "24",
            height: "24",
            viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        }, Kt = "has-toolbar", Jt = "fancybox__toolbar";
        class Qt extends _ {
            constructor() {
                super(...arguments), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Zt.Init
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onReady(t) {
                var e;
                if (!t.carousel) return;
                let i = this.option("display"), n = this.option("absolute"), s = this.option("enabled");
                if ("auto" === s) {
                    const t = this.instance.carousel;
                    let e = 0;
                    if (t) for (const i of t.slides) (i.panzoom || "image" === i.type) && e++;
                    e || (s = !1);
                }
                s || (i = void 0);
                let o = 0;
                const a = {
                    left: [],
                    middle: [],
                    right: []
                };
                if (i) for (const t of [ "left", "middle", "right" ]) for (const n of i[t]) {
                    const i = this.createEl(n);
                    i && (null === (e = a[t]) || void 0 === e || e.push(i), o++);
                }
                let r = null;
                if (o && (r = this.createContainer()), r) {
                    for (const [t, e] of Object.entries(a)) {
                        const i = document.createElement("div");
                        P(i, Jt + "__column is-" + t);
                        for (const t of e) i.appendChild(t);
                        "auto" !== n || "middle" !== t || e.length || (n = !0), r.appendChild(i);
                    }
                    !0 === n && P(r, "is-absolute"), this.state = Zt.Ready, this.onRefresh();
                } else this.state = Zt.Disabled;
            }
            onClick(t) {
                var e, i;
                const n = this.instance, s = n.getSlide(), o = null == s ? void 0 : s.panzoom, a = t.target, r = a && E(a) ? a.dataset : null;
                if (!r) return;
                if (void 0 !== r.fancyboxToggleThumbs) return t.preventDefault(), t.stopPropagation(), 
                void (null === (e = n.plugins.Thumbs) || void 0 === e || e.toggle());
                if (void 0 !== r.fancyboxToggleFullscreen) return t.preventDefault(), t.stopPropagation(), 
                void this.instance.toggleFullscreen();
                if (void 0 !== r.fancyboxToggleSlideshow) {
                    t.preventDefault(), t.stopPropagation();
                    const e = null === (i = n.carousel) || void 0 === i ? void 0 : i.plugins.Autoplay;
                    let s = e.isActive;
                    return o && "mousemove" === o.panMode && !s && o.reset(), void (s ? e.stop() : e.start());
                }
                const l = r.panzoomAction, c = r.panzoomChange;
                if ((c || l) && (t.preventDefault(), t.stopPropagation()), c) {
                    let t = {};
                    try {
                        t = JSON.parse(c);
                    } catch (t) {}
                    o && o.applyChange(t);
                } else l && o && o[l] && o[l]();
            }
            onChange() {
                this.onRefresh();
            }
            onRefresh() {
                if (this.instance.isClosing()) return;
                const t = this.container;
                if (!t) return;
                const e = this.instance.getSlide();
                if (!e || e.state !== lt.Ready) return;
                const i = e && !e.error && e.panzoom;
                for (const e of t.querySelectorAll("[data-panzoom-action]")) i ? (e.removeAttribute("disabled"), 
                e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1"));
                let n = i && i.canZoomIn(), s = i && i.canZoomOut();
                for (const e of t.querySelectorAll('[data-panzoom-action="zoomIn"]')) n ? (e.removeAttribute("disabled"), 
                e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1"));
                for (const e of t.querySelectorAll('[data-panzoom-action="zoomOut"]')) s ? (e.removeAttribute("disabled"), 
                e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1"));
                for (const e of t.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
                    s || n ? (e.removeAttribute("disabled"), e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), 
                    e.setAttribute("tabindex", "-1"));
                    const t = e.querySelector("g");
                    t && (t.style.display = n ? "" : "none");
                }
            }
            onDone(t, e) {
                var i;
                null === (i = e.panzoom) || void 0 === i || i.on("afterTransform", (() => {
                    this.instance.isCurrentSlide(e) && this.onRefresh();
                })), this.instance.isCurrentSlide(e) && this.onRefresh();
            }
            createContainer() {
                const t = this.instance.container;
                if (!t) return null;
                const e = this.option("parentEl") || t;
                let i = e.querySelector("." + Jt);
                return i || (i = document.createElement("div"), P(i, Jt), e.prepend(i)), i.addEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !0
                }), t && P(t, Kt), this.container = i, i;
            }
            createEl(t) {
                const e = this.instance, i = e.carousel;
                if (!i) return null;
                if ("toggleFS" === t) return null;
                if ("fullscreen" === t && !ot()) return null;
                let s = null;
                const o = i.slides.length || 0;
                let a = 0, r = 0;
                for (const t of i.slides) (t.panzoom || "image" === t.type) && a++, ("image" === t.type || t.downloadSrc) && r++;
                if (o < 2 && [ "infobar", "prev", "next" ].includes(t)) return s;
                if (void 0 !== Vt[t] && !a) return null;
                if ("download" === t && !r) return null;
                if ("thumbs" === t) {
                    const t = e.plugins.Thumbs;
                    if (!t || !t.isEnabled) return null;
                }
                if ("slideshow" === t) if (!i.plugins.Autoplay || o < 2) return null;
                if (void 0 !== Vt[t]) {
                    const e = Vt[t];
                    s = document.createElement("button"), s.setAttribute("title", this.instance.localize(`{{${t.toUpperCase()}}}`)), 
                    P(s, "f-button"), e.action && (s.dataset.panzoomAction = e.action), e.change && (s.dataset.panzoomChange = JSON.stringify(e.change)), 
                    s.appendChild(n(this.instance.localize(e.icon)));
                } else {
                    const e = (this.option("items") || [])[t];
                    e && (s = n(this.instance.localize(e.tpl)), "function" == typeof e.click && s.addEventListener("click", (t => {
                        t.preventDefault(), t.stopPropagation(), "function" == typeof e.click && e.click.call(this, this, t);
                    })));
                }
                const l = null == s ? void 0 : s.querySelector("svg");
                if (l) for (const [t, e] of Object.entries(Gt)) l.getAttribute(t) || l.setAttribute(t, String(e));
                return s;
            }
            removeContainer() {
                const t = this.container;
                t && t.remove(), this.container = null, this.state = Zt.Disabled;
                const e = this.instance.container;
                e && S(e, Kt);
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.initSlides", t.onReady), e.on("done", t.onDone), e.on([ "reveal", "Carousel.change" ], t.onChange), 
                t.onReady(t.instance);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.initSlides", t.onReady), e.off("done", t.onDone), e.off([ "reveal", "Carousel.change" ], t.onChange), 
                t.removeContainer();
            }
        }
        Object.defineProperty(Qt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Ut
        });
        const te = {
            Hash: class extends _ {
                onReady() {
                    ht = !1;
                }
                onChange(t) {
                    ut && clearTimeout(ut);
                    const {hash: e} = pt(), {hash: i} = ft(), n = t.isOpeningSlide(t.getSlide());
                    n && (ct = i === e ? "" : i), e && e !== i && (ut = setTimeout((() => {
                        try {
                            if (t.state === rt.Ready) {
                                let t = "replaceState";
                                n && !dt && (t = "pushState", dt = !0), window.history[t]({}, document.title, window.location.pathname + window.location.search + e);
                            }
                        } catch (t) {}
                    }), 300));
                }
                onClose(t) {
                    if (ut && clearTimeout(ut), !ht && dt) return dt = !1, ht = !1, void window.history.back();
                    if (!ht) try {
                        window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (ct || ""));
                    } catch (t) {}
                }
                attach() {
                    const t = this.instance;
                    t.on("ready", this.onReady), t.on([ "Carousel.ready", "Carousel.change" ], this.onChange), 
                    t.on("close", this.onClose);
                }
                detach() {
                    const t = this.instance;
                    t.off("ready", this.onReady), t.off([ "Carousel.ready", "Carousel.change" ], this.onChange), 
                    t.off("close", this.onClose);
                }
                static parseURL() {
                    return ft();
                }
                static startFromUrl() {
                    gt();
                }
                static destroy() {
                    window.removeEventListener("hashchange", vt, !1);
                }
            },
            Html: Lt,
            Images: wt,
            Slideshow: Dt,
            Thumbs: Yt,
            Toolbar: Qt
        }, ee = "with-fancybox", ie = "hide-scrollbar", ne = "--fancybox-scrollbar-compensate", se = "--fancybox-body-margin", oe = "aria-hidden", ae = "is-using-tab", re = "is-animated", le = "is-compact", ce = "is-loading", he = "is-opening", de = "has-caption", ue = "disabled", pe = "tabindex", fe = "download", ge = "href", me = "src", ve = t => "string" == typeof t, be = function() {
            var t = window.getSelection();
            return !!t && "Range" === t.type;
        };
        let ye, we = null, xe = null, Ee = 0, Se = 0, Pe = 0, Ce = 0;
        const Te = new Map;
        let Me = 0;
        class Oe extends g {
            get isIdle() {
                return this.idle;
            }
            get isCompact() {
                return this.option("compact");
            }
            constructor(t = [], e = {}, i = {}) {
                super(e), Object.defineProperty(this, "userSlides", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "userPlugins", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                }), Object.defineProperty(this, "idle", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "idleTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "clickTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "pwt", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "ignoreFocusChange", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "startedFs", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: rt.Init
                }), Object.defineProperty(this, "id", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "caption", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "footer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "carousel", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "lastFocus", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "prevMouseMoveEvent", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), ye || (ye = ot()), this.id = e.id || ++Me, Te.set(this.id, this), this.userSlides = t, 
                this.userPlugins = i, queueMicrotask((() => {
                    this.init();
                }));
            }
            init() {
                if (this.state === rt.Destroy) return;
                this.state = rt.Init, this.attachPlugins(Object.assign(Object.assign({}, Oe.Plugins), this.userPlugins)), 
                this.emit("init"), this.emit("attachPlugins"), !0 === this.option("hideScrollbar") && (() => {
                    if (!et) return;
                    const t = document, e = t.body, i = t.documentElement;
                    if (e.classList.contains(ie)) return;
                    let n = window.innerWidth - i.getBoundingClientRect().width;
                    const s = parseFloat(window.getComputedStyle(e).marginRight);
                    n < 0 && (n = 0), i.style.setProperty(ne, `${n}px`), s && e.style.setProperty(se, `${s}px`), 
                    e.classList.add(ie);
                })(), this.initLayout(), this.scale();
                const t = () => {
                    this.initCarousel(this.userSlides), this.state = rt.Ready, this.attachEvents(), 
                    this.emit("ready"), setTimeout((() => {
                        this.container && this.container.setAttribute(oe, "false");
                    }), 16);
                };
                this.option("Fullscreen.autoStart") && ye && !ye.isFullscreen() ? ye.request().then((() => {
                    this.startedFs = !0, t();
                })).catch((() => t())) : t();
            }
            initLayout() {
                var t, e;
                const i = this.option("parentEl") || document.body, s = n(this.localize(this.option("tpl.main") || ""));
                if (s) {
                    if (s.setAttribute("id", `fancybox-${this.id}`), s.setAttribute("aria-label", this.localize("{{MODAL}}")), 
                    s.classList.toggle(le, this.isCompact), P(s, this.option("mainClass") || ""), P(s, he), 
                    this.container = s, this.footer = s.querySelector(".fancybox__footer"), i.appendChild(s), 
                    P(document.documentElement, ee), we && xe || (we = document.createElement("span"), 
                    P(we, "fancybox-focus-guard"), we.setAttribute(pe, "0"), we.setAttribute(oe, "true"), 
                    we.setAttribute("aria-label", "Focus guard"), xe = we.cloneNode(), null === (t = s.parentElement) || void 0 === t || t.insertBefore(we, s), 
                    null === (e = s.parentElement) || void 0 === e || e.append(xe)), s.addEventListener("mousedown", (t => {
                        Ee = t.pageX, Se = t.pageY, S(s, ae);
                    })), this.option("closeExisting")) for (const t of Te.values()) t.id !== this.id && t.close(); else this.option("animated") && (P(s, re), 
                    setTimeout((() => {
                        this.isClosing() || S(s, re);
                    }), 350));
                    this.emit("initLayout");
                }
            }
            initCarousel(t) {
                const i = this.container;
                if (!i) return;
                const n = i.querySelector(".fancybox__carousel");
                if (!n) return;
                const s = this.carousel = new Q(n, u({}, {
                    slides: t,
                    transition: "fade",
                    Panzoom: {
                        lockAxis: this.option("dragToClose") ? "xy" : "x",
                        infinite: !!this.option("dragToClose") && "y"
                    },
                    Dots: !1,
                    Navigation: {
                        classes: {
                            container: "fancybox__nav",
                            button: "f-button",
                            isNext: "is-next",
                            isPrev: "is-prev"
                        }
                    },
                    initialPage: this.option("startIndex"),
                    l10n: this.option("l10n")
                }, this.option("Carousel") || {}));
                s.on("*", ((t, e, ...i) => {
                    this.emit(`Carousel.${e}`, t, ...i);
                })), s.on([ "ready", "change" ], (() => {
                    this.manageCaption();
                })), this.on("Carousel.removeSlide", ((t, e, i) => {
                    this.clearContent(i), i.state = void 0;
                })), s.on("Panzoom.touchStart", (() => {
                    var t, e;
                    this.isCompact || this.endIdle(), (null === (t = document.activeElement) || void 0 === t ? void 0 : t.closest(".f-thumbs")) && (null === (e = this.container) || void 0 === e || e.focus());
                })), s.on("settle", (() => {
                    this.idleTimer || this.isCompact || !this.option("idle") || this.setIdle(), this.option("autoFocus") && !this.isClosing && this.checkFocus();
                })), this.option("dragToClose") && (s.on("Panzoom.afterTransform", ((t, i) => {
                    const n = this.getSlide();
                    if (n && e(n.el)) return;
                    const s = this.container;
                    if (s) {
                        const t = Math.abs(i.current.f), e = t < 1 ? "" : Math.max(.5, Math.min(1, 1 - t / i.contentRect.fitHeight * 1.5));
                        s.style.setProperty("--fancybox-ts", e ? "0s" : ""), s.style.setProperty("--fancybox-opacity", e + "");
                    }
                })), s.on("Panzoom.touchEnd", ((t, i, n) => {
                    var s;
                    const o = this.getSlide();
                    if (o && e(o.el)) return;
                    if (i.isMobile && document.activeElement && -1 !== [ "TEXTAREA", "INPUT" ].indexOf(null === (s = document.activeElement) || void 0 === s ? void 0 : s.nodeName)) return;
                    const a = Math.abs(i.dragOffset.y);
                    "y" === i.lockedAxis && (a >= 200 || a >= 50 && i.dragOffset.time < 300) && (n && n.cancelable && n.preventDefault(), 
                    this.close(n, "f-throwOut" + (i.current.f < 0 ? "Up" : "Down")));
                }))), s.on("change", (t => {
                    var e;
                    let i = null === (e = this.getSlide()) || void 0 === e ? void 0 : e.triggerEl;
                    if (i) {
                        const e = new CustomEvent("slideTo", {
                            bubbles: !0,
                            cancelable: !0,
                            detail: t.page
                        });
                        i.dispatchEvent(e);
                    }
                })), s.on([ "refresh", "change" ], (t => {
                    const e = this.container;
                    if (!e) return;
                    for (const i of e.querySelectorAll("[data-fancybox-current-index]")) i.innerHTML = t.page + 1;
                    for (const i of e.querySelectorAll("[data-fancybox-count]")) i.innerHTML = t.pages.length;
                    if (!t.isInfinite) {
                        for (const i of e.querySelectorAll("[data-fancybox-next]")) t.page < t.pages.length - 1 ? (i.removeAttribute(ue), 
                        i.removeAttribute(pe)) : (i.setAttribute(ue, ""), i.setAttribute(pe, "-1"));
                        for (const i of e.querySelectorAll("[data-fancybox-prev]")) t.page > 0 ? (i.removeAttribute(ue), 
                        i.removeAttribute(pe)) : (i.setAttribute(ue, ""), i.setAttribute(pe, "-1"));
                    }
                    const i = this.getSlide();
                    if (!i) return;
                    let n = i.downloadSrc || "";
                    n || "image" !== i.type || i.error || !ve(i[me]) || (n = i[me]);
                    for (const t of e.querySelectorAll("[data-fancybox-download]")) {
                        const e = i.downloadFilename;
                        n ? (t.removeAttribute(ue), t.removeAttribute(pe), t.setAttribute(ge, n), t.setAttribute(fe, e || n), 
                        t.setAttribute("target", "_blank")) : (t.setAttribute(ue, ""), t.setAttribute(pe, "-1"), 
                        t.removeAttribute(ge), t.removeAttribute(fe));
                    }
                })), this.emit("initCarousel");
            }
            attachEvents() {
                const t = this, e = t.container;
                if (!e) return;
                e.addEventListener("click", t.onClick, {
                    passive: !1,
                    capture: !1
                }), e.addEventListener("wheel", t.onWheel, {
                    passive: !1,
                    capture: !1
                }), document.addEventListener("keydown", t.onKeydown, {
                    passive: !1,
                    capture: !0
                }), document.addEventListener("visibilitychange", t.onVisibilityChange, !1), document.addEventListener("mousemove", t.onMousemove), 
                t.option("trapFocus") && document.addEventListener("focus", t.onFocus, !0), window.addEventListener("resize", t.onResize);
                const i = window.visualViewport;
                i && (i.addEventListener("scroll", t.onResize), i.addEventListener("resize", t.onResize));
            }
            detachEvents() {
                const t = this, e = t.container;
                if (!e) return;
                document.removeEventListener("keydown", t.onKeydown, {
                    passive: !1,
                    capture: !0
                }), e.removeEventListener("wheel", t.onWheel, {
                    passive: !1,
                    capture: !1
                }), e.removeEventListener("click", t.onClick, {
                    passive: !1,
                    capture: !1
                }), document.removeEventListener("mousemove", t.onMousemove), window.removeEventListener("resize", t.onResize);
                const i = window.visualViewport;
                i && (i.removeEventListener("resize", t.onResize), i.removeEventListener("scroll", t.onResize)), 
                document.removeEventListener("visibilitychange", t.onVisibilityChange, !1), document.removeEventListener("focus", t.onFocus, !0);
            }
            scale() {
                const t = this.container;
                if (!t) return;
                const e = window.visualViewport, i = Math.max(1, (null == e ? void 0 : e.scale) || 1);
                let n = "", s = "", o = "";
                if (e && i > 1) {
                    let t = `${e.offsetLeft}px`, a = `${e.offsetTop}px`;
                    n = e.width * i + "px", s = e.height * i + "px", o = `translate3d(${t}, ${a}, 0) scale(${1 / i})`;
                }
                t.style.transform = o, t.style.width = n, t.style.height = s;
            }
            onClick(t) {
                var e;
                const {container: i, isCompact: n} = this;
                if (!i || this.isClosing()) return;
                !n && this.option("idle") && this.resetIdle();
                const s = t.composedPath()[0];
                if (s.closest(".fancybox-spinner") || s.closest("[data-fancybox-close]")) return t.preventDefault(), 
                void this.close(t);
                if (s.closest("[data-fancybox-prev]")) return t.preventDefault(), void this.prev();
                if (s.closest("[data-fancybox-next]")) return t.preventDefault(), void this.next();
                if ("click" === t.type && 0 === t.detail) return;
                if (Math.abs(t.pageX - Ee) > 30 || Math.abs(t.pageY - Se) > 30) return;
                const o = document.activeElement;
                if (be() && o && i.contains(o)) return;
                if (n && "image" === (null === (e = this.getSlide()) || void 0 === e ? void 0 : e.type)) return void (this.clickTimer ? (clearTimeout(this.clickTimer), 
                this.clickTimer = null) : this.clickTimer = setTimeout((() => {
                    this.toggleIdle(), this.clickTimer = null;
                }), 350));
                if (this.emit("click", t), t.defaultPrevented) return;
                let a = !1;
                if (s.closest(".fancybox__content")) {
                    if (o) {
                        if (o.closest("[contenteditable]")) return;
                        s.matches(nt) || o.blur();
                    }
                    if (be()) return;
                    a = this.option("contentClick");
                } else s.closest(".fancybox__carousel") && !s.matches(nt) && (a = this.option("backdropClick"));
                "close" === a ? (t.preventDefault(), this.close(t)) : "next" === a ? (t.preventDefault(), 
                this.next()) : "prev" === a && (t.preventDefault(), this.prev());
            }
            onWheel(t) {
                const e = t.target;
                let n = this.option("wheel", t);
                e.closest(".fancybox__thumbs") && (n = "slide");
                const s = "slide" === n, o = [ -t.deltaX || 0, -t.deltaY || 0, -t.detail || 0 ].reduce((function(t, e) {
                    return Math.abs(e) > Math.abs(t) ? e : t;
                })), a = Math.max(-1, Math.min(1, o)), r = Date.now();
                this.pwt && r - this.pwt < 300 ? s && t.preventDefault() : (this.pwt = r, this.emit("wheel", t, a), 
                t.defaultPrevented || ("close" === n ? (t.preventDefault(), this.close(t)) : "slide" === n && (i(e) || (t.preventDefault(), 
                this[a > 0 ? "prev" : "next"]()))));
            }
            onScroll() {
                window.scrollTo(Pe, Ce);
            }
            onKeydown(t) {
                if (!this.isTopmost()) return;
                this.isCompact || !this.option("idle") || this.isClosing() || this.resetIdle();
                const e = t.key, i = this.option("keyboard");
                if (!i) return;
                const n = t.composedPath()[0], s = document.activeElement && document.activeElement.classList, o = s && s.contains("f-button") || n.dataset.carouselPage || n.dataset.carouselIndex;
                if ("Escape" !== e && !o && E(n)) if (n.isContentEditable || -1 !== [ "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO" ].indexOf(n.nodeName)) return;
                if ("Tab" === t.key ? P(this.container, ae) : S(this.container, ae), t.ctrlKey || t.altKey || t.shiftKey) return;
                this.emit("keydown", e, t);
                const a = i[e];
                a && "function" == typeof this[a] && (t.preventDefault(), this[a]());
            }
            onResize() {
                const t = this.container;
                if (!t) return;
                const e = this.isCompact;
                t.classList.toggle(le, e), this.manageCaption(this.getSlide()), this.isCompact ? this.clearIdle() : this.endIdle(), 
                this.scale(), this.emit("resize");
            }
            onFocus(t) {
                this.isTopmost() && this.checkFocus(t);
            }
            onMousemove(t) {
                this.prevMouseMoveEvent = t, !this.isCompact && this.option("idle") && this.resetIdle();
            }
            onVisibilityChange() {
                "visible" === document.visibilityState ? this.checkFocus() : this.endIdle();
            }
            manageCloseBtn(t) {
                const e = this.optionFor(t, "closeButton") || !1;
                if ("auto" === e) {
                    const t = this.plugins.Toolbar;
                    if (t && t.state === Zt.Ready) return;
                }
                if (!e) return;
                if (!t.contentEl || t.closeBtnEl) return;
                const i = this.option("tpl.closeButton");
                if (i) {
                    const e = n(this.localize(i));
                    t.closeBtnEl = t.contentEl.appendChild(e), t.el && P(t.el, "has-close-btn");
                }
            }
            manageCaption(t = void 0) {
                var e, i;
                const n = "fancybox__caption", s = this.container;
                if (!s) return;
                S(s, de);
                const o = this.isCompact || this.option("commonCaption"), a = !o;
                if (this.caption && this.stop(this.caption), a && this.caption && (this.caption.remove(), 
                this.caption = null), o && !this.caption) for (const t of (null === (e = this.carousel) || void 0 === e ? void 0 : e.slides) || []) t.captionEl && (t.captionEl.remove(), 
                t.captionEl = void 0, S(t.el, de), null === (i = t.el) || void 0 === i || i.removeAttribute("aria-labelledby"));
                if (t || (t = this.getSlide()), !t || o && !this.isCurrentSlide(t)) return;
                const r = t.el;
                let l = this.optionFor(t, "caption", "");
                if (!l) return void (o && this.caption && this.animate(this.caption, "f-fadeOut", (() => {
                    this.caption && (this.caption.innerHTML = "");
                })));
                let c = null;
                if (a) {
                    if (c = t.captionEl || null, r && !c) {
                        const e = n + `_${this.id}_${t.index}`;
                        c = document.createElement("div"), P(c, n), c.setAttribute("id", e), t.captionEl = r.appendChild(c), 
                        P(r, de), r.setAttribute("aria-labelledby", e);
                    }
                } else {
                    if (c = this.caption, c || (c = s.querySelector("." + n)), !c) {
                        c = document.createElement("div"), c.dataset.fancyboxCaption = "", P(c, n);
                        (this.footer || s).prepend(c);
                    }
                    P(s, de), this.caption = c;
                }
                c && (c.innerHTML = "", ve(l) || "number" == typeof l ? c.innerHTML = l + "" : l instanceof HTMLElement && c.appendChild(l));
            }
            checkFocus(t) {
                this.focus(t);
            }
            focus(t) {
                var e;
                if (this.ignoreFocusChange) return;
                const i = document.activeElement || null, n = (null == t ? void 0 : t.target) || null, s = this.container, o = null === (e = this.carousel) || void 0 === e ? void 0 : e.viewport;
                if (!s || !o) return;
                if (!t && i && s.contains(i)) return;
                const a = this.getSlide(), r = a && a.state === lt.Ready ? a.el : null;
                if (!r || r.contains(i) || s === i) return;
                t && t.cancelable && t.preventDefault(), this.ignoreFocusChange = !0;
                const l = Array.from(s.querySelectorAll(nt));
                let c = [], h = null;
                for (let t of l) {
                    const e = !t.offsetParent || !!t.closest('[aria-hidden="true"]'), i = r && r.contains(t), n = !o.contains(t);
                    if (t === s || (i || n) && !e) {
                        c.push(t);
                        const e = t.dataset.origTabindex;
                        void 0 !== e && e && (t.tabIndex = parseFloat(e)), t.removeAttribute("data-orig-tabindex"), 
                        !t.hasAttribute("autoFocus") && h || (h = t);
                    } else {
                        const e = void 0 === t.dataset.origTabindex ? t.getAttribute("tabindex") || "" : t.dataset.origTabindex;
                        e && (t.dataset.origTabindex = e), t.tabIndex = -1;
                    }
                }
                let d = null;
                t ? (!n || c.indexOf(n) < 0) && (d = h || s, c.length && (i === xe ? d = c[0] : this.lastFocus !== s && i !== we || (d = c[c.length - 1]))) : d = a && "image" === a.type ? s : h || s, 
                d && st(d), this.lastFocus = document.activeElement, this.ignoreFocusChange = !1;
            }
            next() {
                const t = this.carousel;
                t && t.pages.length > 1 && t.slideNext();
            }
            prev() {
                const t = this.carousel;
                t && t.pages.length > 1 && t.slidePrev();
            }
            jumpTo(...t) {
                this.carousel && this.carousel.slideTo(...t);
            }
            isTopmost() {
                var t;
                return (null === (t = Oe.getInstance()) || void 0 === t ? void 0 : t.id) == this.id;
            }
            animate(t = null, e = "", i) {
                if (!t || !e) return void (i && i());
                this.stop(t);
                const n = s => {
                    s.target === t && t.dataset.animationName && (t.removeEventListener("animationend", n), 
                    delete t.dataset.animationName, i && i(), S(t, e));
                };
                t.dataset.animationName = e, t.addEventListener("animationend", n), P(t, e);
            }
            stop(t) {
                t && t.dispatchEvent(new CustomEvent("animationend", {
                    bubbles: !1,
                    cancelable: !0,
                    currentTarget: t
                }));
            }
            setContent(t, e = "", i = !0) {
                if (this.isClosing()) return;
                const s = t.el;
                if (!s) return;
                let o = null;
                if (E(e) ? o = e : (o = n(e + ""), E(o) || (o = document.createElement("div"), o.innerHTML = e + "")), 
                [ "img", "picture", "iframe", "video", "audio" ].includes(o.nodeName.toLowerCase())) {
                    const t = document.createElement("div");
                    t.appendChild(o), o = t;
                }
                E(o) && t.filter && !t.error && (o = o.querySelector(t.filter)), o && E(o) ? (P(o, "fancybox__content"), 
                t.id && o.setAttribute("id", t.id), s.classList.add(`has-${t.error ? "error" : t.type || "unknown"}`), 
                s.prepend(o), "none" === o.style.display && (o.style.display = ""), "none" === getComputedStyle(o).getPropertyValue("display") && (o.style.display = t.display || this.option("defaultDisplay") || "flex"), 
                t.contentEl = o, i && this.revealContent(t), this.manageCloseBtn(t), this.manageCaption(t)) : this.setError(t, "{{ELEMENT_NOT_FOUND}}");
            }
            revealContent(t, e) {
                const i = t.el, n = t.contentEl;
                i && n && (this.emit("reveal", t), this.hideLoading(t), t.state = lt.Opening, (e = this.isOpeningSlide(t) ? void 0 === e ? this.optionFor(t, "showClass") : e : "f-fadeIn") ? this.animate(n, e, (() => {
                    this.done(t);
                })) : this.done(t));
            }
            done(t) {
                this.isClosing() || (t.state = lt.Ready, this.emit("done", t), P(t.el, "is-done"), 
                this.isCurrentSlide(t) && this.option("autoFocus") && queueMicrotask((() => {
                    var e;
                    null === (e = t.panzoom) || void 0 === e || e.updateControls(), this.option("autoFocus") && this.focus();
                })), this.isOpeningSlide(t) && (S(this.container, he), !this.isCompact && this.option("idle") && this.setIdle()));
            }
            isCurrentSlide(t) {
                const e = this.getSlide();
                return !(!t || !e) && e.index === t.index;
            }
            isOpeningSlide(t) {
                var e, i;
                return null === (null === (e = this.carousel) || void 0 === e ? void 0 : e.prevPage) && t && t.index === (null === (i = this.getSlide()) || void 0 === i ? void 0 : i.index);
            }
            showLoading(t) {
                t.state = lt.Loading;
                const e = t.el;
                if (!e) return;
                P(e, ce), this.emit("loading", t), t.spinnerEl || setTimeout((() => {
                    if (!this.isClosing() && !t.spinnerEl && t.state === lt.Loading) {
                        let i = n(x);
                        P(i, "fancybox-spinner"), t.spinnerEl = i, e.prepend(i), this.animate(i, "f-fadeIn");
                    }
                }), 250);
            }
            hideLoading(t) {
                const e = t.el;
                if (!e) return;
                const i = t.spinnerEl;
                this.isClosing() ? null == i || i.remove() : (S(e, ce), i && this.animate(i, "f-fadeOut", (() => {
                    i.remove();
                })), t.state === lt.Loading && (this.emit("loaded", t), t.state = lt.Ready));
            }
            setError(t, e) {
                if (this.isClosing()) return;
                const i = new Event("error", {
                    bubbles: !0,
                    cancelable: !0
                });
                if (this.emit("error", i, t), i.defaultPrevented) return;
                t.error = e, this.hideLoading(t), this.clearContent(t);
                const n = document.createElement("div");
                n.classList.add("fancybox-error"), n.innerHTML = this.localize(e || "<p>{{ERROR}}</p>"), 
                this.setContent(t, n);
            }
            clearContent(t) {
                if (void 0 === t.state) return;
                this.emit("clearContent", t), t.contentEl && (t.contentEl.remove(), t.contentEl = void 0);
                const e = t.el;
                e && (S(e, "has-error"), S(e, "has-unknown"), S(e, `has-${t.type || "unknown"}`)), 
                t.closeBtnEl && t.closeBtnEl.remove(), t.closeBtnEl = void 0, t.captionEl && t.captionEl.remove(), 
                t.captionEl = void 0, t.spinnerEl && t.spinnerEl.remove(), t.spinnerEl = void 0;
            }
            getSlide() {
                var t;
                const e = this.carousel;
                return (null === (t = null == e ? void 0 : e.pages[null == e ? void 0 : e.page]) || void 0 === t ? void 0 : t.slides[0]) || void 0;
            }
            close(t, e) {
                if (this.isClosing()) return;
                const i = new Event("shouldClose", {
                    bubbles: !0,
                    cancelable: !0
                });
                if (this.emit("shouldClose", i, t), i.defaultPrevented) return;
                t && t.cancelable && (t.preventDefault(), t.stopPropagation());
                const n = () => {
                    this.proceedClose(t, e);
                };
                this.startedFs && ye && ye.isFullscreen() ? Promise.resolve(ye.exit()).then((() => n())) : n();
            }
            clearIdle() {
                this.idleTimer && clearTimeout(this.idleTimer), this.idleTimer = null;
            }
            setIdle(t = !1) {
                const e = () => {
                    this.clearIdle(), this.idle = !0, P(this.container, "is-idle"), this.emit("setIdle");
                };
                if (this.clearIdle(), !this.isClosing()) if (t) e(); else {
                    const t = this.option("idle");
                    t && (this.idleTimer = setTimeout(e, t));
                }
            }
            endIdle() {
                this.clearIdle(), this.idle && !this.isClosing() && (this.idle = !1, S(this.container, "is-idle"), 
                this.emit("endIdle"));
            }
            resetIdle() {
                this.endIdle(), this.setIdle();
            }
            toggleIdle() {
                this.idle ? this.endIdle() : this.setIdle(!0);
            }
            toggleFullscreen() {
                ye && (ye.isFullscreen() ? ye.exit() : ye.request().then((() => {
                    this.startedFs = !0;
                })));
            }
            isClosing() {
                return [ rt.Closing, rt.CustomClosing, rt.Destroy ].includes(this.state);
            }
            proceedClose(t, e) {
                var i, n;
                this.state = rt.Closing, this.clearIdle(), this.detachEvents();
                const s = this.container, o = this.carousel, a = this.getSlide(), r = a && this.option("placeFocusBack") ? a.triggerEl || this.option("triggerEl") : null;
                if (r && (tt(r) ? st(r) : r.focus()), s && (S(s, he), P(s, "is-closing"), s.setAttribute(oe, "true"), 
                this.option("animated") && P(s, re), s.style.pointerEvents = "none"), o) {
                    o.clearTransitions(), null === (i = o.panzoom) || void 0 === i || i.destroy(), null === (n = o.plugins.Navigation) || void 0 === n || n.detach();
                    for (const t of o.slides) {
                        t.state = lt.Closing, this.hideLoading(t);
                        const e = t.contentEl;
                        e && this.stop(e);
                        const i = null == t ? void 0 : t.panzoom;
                        i && (i.stop(), i.detachEvents(), i.detachObserver()), this.isCurrentSlide(t) || o.emit("removeSlide", t);
                    }
                }
                Pe = window.scrollX, Ce = window.scrollY, window.addEventListener("scroll", this.onScroll), 
                this.emit("close", t), this.state !== rt.CustomClosing ? (void 0 === e && a && (e = this.optionFor(a, "hideClass")), 
                e && a ? (this.animate(a.contentEl, e, (() => {
                    o && o.emit("removeSlide", a);
                })), setTimeout((() => {
                    this.destroy();
                }), 500)) : this.destroy()) : setTimeout((() => {
                    this.destroy();
                }), 500);
            }
            destroy() {
                var t;
                if (this.state === rt.Destroy) return;
                window.removeEventListener("scroll", this.onScroll), this.state = rt.Destroy, null === (t = this.carousel) || void 0 === t || t.destroy();
                const e = this.container;
                e && e.remove(), Te.delete(this.id);
                const i = Oe.getInstance();
                i ? i.focus() : (we && (we.remove(), we = null), xe && (xe.remove(), xe = null), 
                S(document.documentElement, ee), (() => {
                    if (!et) return;
                    const t = document, e = t.body;
                    e.classList.remove(ie), e.style.setProperty(se, ""), t.documentElement.style.setProperty(ne, "");
                })(), this.emit("destroy"));
            }
            static bind(t, e, i) {
                if (!et) return;
                let n, s = "", o = {};
                if (void 0 === t ? n = document.body : ve(t) ? (n = document.body, s = t, "object" == typeof e && (o = e || {})) : (n = t, 
                ve(e) && (s = e), "object" == typeof i && (o = i || {})), !n || !E(n)) return;
                s = s || "[data-fancybox]";
                const a = Oe.openers.get(n) || new Map;
                a.set(s, o), Oe.openers.set(n, a), 1 === a.size && n.addEventListener("click", Oe.fromEvent);
            }
            static unbind(t, e) {
                let i, n = "";
                if (ve(t) ? (i = document.body, n = t) : (i = t, ve(e) && (n = e)), !i) return;
                const s = Oe.openers.get(i);
                s && n && s.delete(n), n && s || (Oe.openers.delete(i), i.removeEventListener("click", Oe.fromEvent));
            }
            static destroy() {
                let t;
                for (;t = Oe.getInstance(); ) t.destroy();
                for (const t of Oe.openers.keys()) t.removeEventListener("click", Oe.fromEvent);
                Oe.openers = new Map;
            }
            static fromEvent(t) {
                if (t.defaultPrevented) return;
                if (t.button && 0 !== t.button) return;
                if (t.ctrlKey || t.metaKey || t.shiftKey) return;
                let e = t.composedPath()[0];
                const i = e.closest("[data-fancybox-trigger]");
                if (i) {
                    const t = i.dataset.fancyboxTrigger || "", n = document.querySelectorAll(`[data-fancybox="${t}"]`), s = parseInt(i.dataset.fancyboxIndex || "", 10) || 0;
                    e = n[s] || e;
                }
                if (!(e && e instanceof Element)) return;
                let n, s, o, a;
                if ([ ...Oe.openers ].reverse().find((([t, i]) => !(!t.contains(e) || ![ ...i ].reverse().find((([i, r]) => {
                    let l = e.closest(i);
                    return !!l && (n = t, s = i, o = l, a = r, !0);
                }))))), !n || !s || !o) return;
                a = a || {}, t.preventDefault(), e = o;
                let r = [], l = u({}, at, a);
                l.event = t, l.triggerEl = e, l.delegate = i;
                const c = l.groupAll, h = l.groupAttr, d = h && e ? e.getAttribute(`${h}`) : "";
                if ((!e || d || c) && (r = [].slice.call(n.querySelectorAll(s))), e && !c && (r = d ? r.filter((t => t.getAttribute(`${h}`) === d)) : [ e ]), 
                !r.length) return;
                const p = Oe.getInstance();
                return p && p.options.triggerEl && r.indexOf(p.options.triggerEl) > -1 ? void 0 : (e && (l.startIndex = r.indexOf(e)), 
                Oe.fromNodes(r, l));
            }
            static fromSelector(t, e, i) {
                let n = null, s = "", o = {};
                if (ve(t) ? (n = document.body, s = t, "object" == typeof e && (o = e || {})) : t instanceof HTMLElement && ve(e) && (n = t, 
                s = e, "object" == typeof i && (o = i || {})), !n || !s) return !1;
                const a = Oe.openers.get(n);
                return !!a && (o = u({}, a.get(s) || {}, o), !!o && Oe.fromNodes(Array.from(n.querySelectorAll(s)), o));
            }
            static fromNodes(t, e) {
                e = u({}, at, e || {});
                const i = [];
                for (const n of t) {
                    const t = n.dataset || {}, s = t[me] || n.getAttribute(ge) || n.getAttribute("currentSrc") || n.getAttribute(me) || void 0;
                    let o;
                    const a = e.delegate;
                    let r;
                    a && i.length === e.startIndex && (o = a instanceof HTMLImageElement ? a : a.querySelector("img:not([aria-hidden])")), 
                    o || (o = n instanceof HTMLImageElement ? n : n.querySelector("img:not([aria-hidden])")), 
                    o && (r = o.currentSrc || o[me] || void 0, !r && o.dataset && (r = o.dataset.lazySrc || o.dataset[me] || void 0));
                    const l = {
                        src: s,
                        triggerEl: n,
                        thumbEl: o,
                        thumbElSrc: r,
                        thumbSrc: r
                    };
                    for (const e in t) {
                        let i = t[e] + "";
                        i = "false" !== i && ("true" === i || i), l[e] = i;
                    }
                    i.push(l);
                }
                return new Oe(i, e);
            }
            static getInstance(t) {
                if (t) return Te.get(t);
                return Array.from(Te.values()).reverse().find((t => !t.isClosing() && t)) || null;
            }
            static getSlide() {
                var t;
                return (null === (t = Oe.getInstance()) || void 0 === t ? void 0 : t.getSlide()) || null;
            }
            static show(t = [], e = {}) {
                return new Oe(t, e);
            }
            static next() {
                const t = Oe.getInstance();
                t && t.next();
            }
            static prev() {
                const t = Oe.getInstance();
                t && t.prev();
            }
            static close(t = !0, ...e) {
                if (t) for (const t of Te.values()) t.close(...e); else {
                    const t = Oe.getInstance();
                    t && t.close(...e);
                }
            }
        }
        Object.defineProperty(Oe, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "5.0.36"
        }), Object.defineProperty(Oe, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: at
        }), Object.defineProperty(Oe, "Plugins", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: te
        }), Object.defineProperty(Oe, "openers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: new Map
        });
        var air_datepicker = __webpack_require__(792);
        var air_datepicker_default = __webpack_require__.n(air_datepicker);
        const index_es = air_datepicker_default();
        Oe.bind("[data-fancybox]", {});
        window.addEventListener("DOMContentLoaded", (() => {
            var idItemListLk;
            document.addEventListener("click", documentActions);
            let flag = true;
            let flagCart = true;
            let flagAllPopup = true;
            let flagred = true;
            function documentActions(e) {
                const targetElement = e.target;
                function closePopup(id) {
                    history.pushState("", document.title, window.location.pathname);
                    document.documentElement.classList.remove("popup-show");
                    document.documentElement.classList.remove("lock");
                    document.body.removeAttribute("style");
                    targetElement.closest(`${id}`).classList.remove("popup_show");
                    targetElement.closest(`${id}`).setAttribute("aria-hidden", "false");
                }
                console.log(targetElement);
                if (targetElement.closest(".menu__item") && targetElement.closest("header") && !targetElement.closest(".menu__item").classList.contains("_menu__item-active")) {
                    const menuItemMobile = targetElement.closest(".menu__list").querySelectorAll(".menu__item");
                    menuItemMobile.forEach((element => {
                        element.classList.remove("_menu__item-active");
                    }));
                    const sublistMobile = targetElement.closest(".menu__list").querySelectorAll(".menu__sublist");
                    sublistMobile.forEach((element => {
                        element.classList.remove("_sub-menu-open");
                    }));
                    targetElement.closest(".menu__item").classList.add("_menu__item-active");
                    targetElement.closest(".menu__item").querySelector(".menu__sublist") ? targetElement.closest(".menu__item").querySelector(".menu__sublist").classList.add("_sub-menu-open") : null;
                } else if (targetElement.closest(".menu__item") && targetElement.closest("header") && targetElement.closest(".menu__item").classList.contains("_menu__item-active") && !targetElement.closest(".sublist-menu__link")) {
                    console.log(3);
                    targetElement.closest(".menu__item").classList.remove("_menu__item-active");
                    targetElement.closest(".menu__item").querySelector(".menu__sublist").classList.remove("_sub-menu-open");
                }
                if (!targetElement.closest(".menсu__icon") && !targetElement.closest(".menu__body") && flag == true) flag = false; else if (!targetElement.closest(".menсu__icon") && !targetElement.closest(".menu__body") && flag == false) {
                    flag = true;
                    document.querySelector(".menu-open") ? document.documentElement.classList.remove("lock") : null;
                    document.querySelector(".menu-open") ? document.documentElement.classList.remove("menu-open") : null;
                }
                if (targetElement.closest(".city-choice__button")) {
                    const city = targetElement.closest(".top-header__city").querySelector(".city-choice");
                    city.hidden = true;
                    return;
                }
                if (targetElement.closest(".top-header__city") && document.querySelector(".guest") && document.querySelector(".city-choice").hidden) {
                    const city = targetElement.closest(".top-header__city").querySelector(".city-choice");
                    city.hidden = false;
                    return;
                }
                if (targetElement.closest(".popup__img-pasword")) targetElement.closest(".popup__img-pasword").classList.toggle("_pass-view");
                if (targetElement.closest(".popup-img-toggle")) {
                    const type = targetElement.closest(".popup__input-wrapper").querySelector("input").getAttribute("type") === "password" ? "text" : "password";
                    targetElement.closest(".popup__input-wrapper").querySelector("input").setAttribute("type", type);
                }
                if (!targetElement.closest('input[type^="number"]') && !document.querySelectorAll('[type="number"]').length == 0) {
                    const inputType = document.querySelectorAll('[type="number"]');
                    inputType.forEach((element => {
                        if (element.value !== "" && !element.activeElement) element.closest(".popup__form-item").classList.add("_label"); else if (element.closest(".popup__form-item").classList.contains("_label")) element.closest(".popup__form-item").classList.remove("_label");
                    }));
                }
                if (targetElement.closest(".search-button")) document.documentElement.classList.toggle("_show");
                if (!targetElement.closest(".header-center__form")) document.documentElement.classList.remove("_show");
                if (window.innerWidth < 1001 && targetElement.closest(".options__input") && targetElement.closest(".catalog")) {
                    let inpOpt = targetElement.value;
                    let valOpt = targetElement.closest(".filters__item").querySelector(".filter__val");
                    valOpt.innerHTML = inpOpt;
                }
                if (window.innerWidth < 1001 && targetElement.closest(".checkbox__input") && targetElement.closest(".catalog")) {
                    let valCheck = targetElement.closest(".filters__item").querySelector(".filter__val");
                    if (flag) {
                        flag = false;
                        valCheck.innerHTML = " ";
                    }
                    valCheck.innerHTML += targetElement.value + ", ";
                }
                if (targetElement.closest(".filter__title") && targetElement.closest(".filters__item").querySelector(".checkbox")) {
                    let list = targetElement.closest(".filters__item").querySelector(".filter__list");
                    if (!list.closest(".filter__showmore").classList.contains("_showmore-active")) list.style.height = "180px";
                }
                if (targetElement.closest("[data-parent]")) {
                    const subMenuId = targetElement.dataset.parent ? targetElement.dataset.parent : null;
                    const subMenu = document.querySelector(`[data-submenu="${subMenuId}"]`);
                    if (subMenu) {
                        document.documentElement.classList.add("sub-menu-open");
                        subMenu.classList.add("_sub-menu-open");
                    }
                }
                if (targetElement.closest(".submenu-filter__top") || targetElement.closest("#submit-filter")) {
                    document.documentElement.classList.remove("sub-menu-open");
                    targetElement.closest("[data-submenu]").classList.remove("_sub-menu-open");
                }
                if (targetElement.closest("[data-but]")) {
                    const buttonTilteSearch = document.querySelectorAll(".main-search__title");
                    buttonTilteSearch.forEach((element => {
                        element.classList.remove("_active-search-title");
                    }));
                    targetElement.classList.add("_active-search-title");
                    const parId = targetElement.closest("summary").dataset.but ? targetElement.closest("summary").dataset.but : null;
                    const par = document.querySelector(`[data-par="${parId}"]`);
                    if (par) {
                        const spo = document.querySelectorAll(".main-search__body");
                        spo.forEach((element => {
                            element.classList.remove("_open-result-search");
                        }));
                        par.classList.add("_open-result-search");
                    }
                }
                if (window.innerWidth < 768 && targetElement.closest(".options__input")) {
                    let numberSubmenu = targetElement.closest(".filtmodal__submenu").dataset.submenu;
                    const buttonEl = targetElement.closest(".filtmodal").querySelector(`[data-parent="${numberSubmenu}"]`).closest(".filtmodal__item");
                    const checked = targetElement.closest(".filtmodal").querySelector(`[data-parent="${numberSubmenu}"]`).closest(".filtmodal__item").querySelector(".filtmodal__checked");
                    buttonEl.classList.add("_backcolor");
                    checked.innerHTML = targetElement.value;
                }
                if (targetElement.closest(".product__favorite")) targetElement.closest(".product__favorite").classList.toggle("_active-favorite");
                if (window.innerWidth < 768 && targetElement.closest(".checkbox__input")) {
                    let numberSubmenu = targetElement.closest(".filtmodal__submenu").dataset.submenu;
                    const buttonEl = targetElement.closest(".filtmodal").querySelector(`[data-parent="${numberSubmenu}"]`).closest(".filtmodal__item");
                    const checked = targetElement.closest(".filtmodal").querySelector(`[data-parent="${numberSubmenu}"]`).closest(".filtmodal__item").querySelector(".filtmodal__checked");
                    buttonEl.classList.add("_backcolor");
                    if (flag) {
                        flag = false;
                        checked.innerHTML = " ";
                    }
                    checked.innerHTML += targetElement.value + ", ";
                }
                if (targetElement.closest("#reset-filternoUi")) {
                    let numberSubmenu = targetElement.closest(".filtmodal__submenu").dataset.submenu;
                    const buttonEl = targetElement.closest(".filtmodal").querySelector(`[data-parent="${numberSubmenu}"]`).closest(".filtmodal__item");
                    buttonEl.classList.remove("_backcolor");
                }
                if (targetElement.closest(".filter__reset-check")) {
                    let valCheck = targetElement.closest(".filters__filter").querySelector(".filter__val");
                    targetElement.closest(".filters__filter").querySelector(".header-center__input") ? targetElement.closest(".filters__filter").querySelector(".header-center__input").value = "" : null;
                    const checkboxCheck = targetElement.closest(".filters__filter").querySelectorAll(".checkbox__input");
                    checkboxCheck.forEach((element => {
                        element.checked = false;
                    }));
                    valCheck.innerHTML = " ";
                }
                if (targetElement.closest("#reset-filter")) {
                    targetElement.closest("#reset-filter").closest("._sub-menu-open").querySelector("input").value = "";
                    const checkboxCheckMobile = targetElement.closest(".filtmodal__submenu").querySelectorAll(".checkbox__input");
                    checkboxCheckMobile.forEach((element => {
                        element.checked = false;
                    }));
                    let numberSubmenu = targetElement.closest(".filtmodal__submenu").dataset.submenu;
                    const checked = targetElement.closest(".filtmodal").querySelector(`[data-parent="${numberSubmenu}"]`).closest(".filtmodal__item").querySelector(".filtmodal__checked");
                    checked.innerHTML = targetElement.value;
                }
                if (targetElement.closest("#reset-filterall")) {
                    const checkeds = targetElement.closest(".filtmodal__wrapper ").querySelectorAll(".filtmodal__checked");
                    const filtmodalItem = targetElement.closest(".filtmodal__wrapper").querySelectorAll(".filtmodal__item");
                    checkeds.forEach((element => {
                        element.innerHTML = " ";
                    }));
                    filtmodalItem.forEach((element => {
                        element.classList.remove("_backcolor");
                    }));
                    const subCheks = targetElement.closest(".filtmodal").querySelectorAll(".checkbox__input");
                    subCheks.forEach((element => {
                        element.checked = false;
                    }));
                }
                if (window.innerWidth < 1001.98 && targetElement.closest(".filter__help")) document.documentElement.classList.add("_tippy-open");
                if (window.innerWidth < 1001.98 && !targetElement.closest(".filter__help")) document.documentElement.classList.remove("_tippy-open");
                if (window.innerWidth < 1001.98 && targetElement.closest(".calendar-help")) document.documentElement.classList.add("_tippy-open");
                if (window.innerWidth < 1001.98 && !targetElement.closest(".calendar-help")) document.documentElement.classList.remove("_tippy-open");
                if (window.innerWidth < 1001.98 && targetElement.closest(".header-center__button.search-button")) document.querySelector(".header").classList.add("_mobile-searh-top-open");
                if (window.innerWidth < 1001.98 && targetElement.closest(".search-mob__img-close")) document.querySelector(".header").classList.remove("_mobile-searh-top-open");
                if (document.querySelector(".where") && targetElement.closest(".search-order")) if (targetElement.closest(".calculation__form").querySelector("input").value.length != 0) document.documentElement.classList.add("_show-order");
                if (document.querySelector(".calculator") && targetElement.closest(".form-calc__link")) if (targetElement.closest(".calculation__form").querySelector(".form-calc__input_city").value.length != 0 && targetElement.closest(".calculation__form").querySelector(".form-calc__input_cost").value.length != 0) document.documentElement.classList.add("_show-order");
                if (targetElement.closest(".question-block__button") || targetElement.closest(".questiion-block__span-quantity")) {
                    const questionAnswers = targetElement.closest(".question-block__answers").querySelectorAll(".question-block__button");
                    questionAnswers.forEach((element => {
                        element.classList.remove("_question-answer");
                    }));
                    targetElement.closest(".question-block__answers").classList.add("_question-active");
                    targetElement.classList.add("_question-answer");
                    if (targetElement.closest(".questiion-block__span-quantity")) targetElement.closest(".question-block__button").classList.add("_question-answer");
                }
                if (targetElement.closest(".panel-comment__item") && !targetElement.closest(".panel-comment__item").classList.contains("_filter-item-open")) {
                    const panelCommentItems = document.querySelectorAll(".panel-comment__item");
                    panelCommentItems.forEach((element => {
                        if (element.classList.contains("_filter-item-open")) element.classList.remove("_filter-item-open");
                    }));
                    targetElement.closest(".panel-comment__item").classList.add("_filter-item-open");
                    document.querySelector(".panel-comment") ? targetElement.closest(".panel-comment").style.borderBottomLeftRadius = "0px" : null;
                    document.querySelector(".panel-comment") ? targetElement.closest(".panel-comment").style.borderBottomRightRadius = "0px" : null;
                } else if (targetElement.closest(".panel-comment__item") && targetElement.closest(".panel-comment__item").classList.contains("_filter-item-open")) targetElement.closest(".panel-comment__item").classList.remove("_filter-item-open");
                if (!targetElement.closest(".panel-comment__item") && !targetElement.closest(".panel-comment__list")) {
                    document.querySelector(".panel-comment") ? document.querySelector(".panel-comment").style.borderBottomLeftRadius = "16px" : null;
                    document.querySelector(".panel-comment") ? document.querySelector(".panel-comment").style.borderBottomRightRadius = "16px" : null;
                    const panelCommentItems = document.querySelectorAll(".panel-comment__item");
                    panelCommentItems.forEach((element => {
                        element.classList.remove("_filter-item-open");
                    }));
                }
                if (targetElement.closest("textarea")) if (targetElement.closest(".popup__form-item") && !targetElement.closest(".address__group_textarea")) {
                    const taComments = targetElement.closest(".popup__form-item").querySelector("textarea");
                    const counter = targetElement.closest(".popup__form-item").querySelector(".comment__number-symbols");
                    taComments ? taComments.addEventListener("input", onInput) : null;
                    function onInput(evt) {
                        const length = evt.target.value.length;
                        counter.textContent = length;
                    }
                }
                if (targetElement.closest("#number-order")) targetElement.closest(".popup__form-item").querySelector(".popup__submenu").classList.toggle("_popup-submenu-open");
                if (targetElement.closest(".popup__submenu-item") && document.querySelector("#number-order")) {
                    const inputOrder = document.querySelector("#number-order");
                    inputOrder.value = targetElement.closest(".popup__submenu-item").innerText;
                    inputOrder.closest(".popup__form-item").classList.add("_label");
                }
                if (!targetElement.closest("#number-order") && document.querySelector("#number-order")) {
                    const inputOrder = document.querySelector("#number-order");
                    if (inputOrder.closest(".popup__form-item").querySelector(".popup__submenu").classList.contains("_popup-submenu-open")) inputOrder.closest(".popup__form-item").querySelector(".popup__submenu").classList.remove("_popup-submenu-open");
                }
                if (targetElement.closest("#city-data")) targetElement.closest(".popup__form-item").querySelector(".popup__submenu").classList.toggle("_popup-submenu-open");
                if (targetElement.closest(".popup__submenu-item") && document.querySelector("#city-data")) {
                    const inputOrder = document.querySelector("#city-data");
                    inputOrder.value = targetElement.closest(".popup__submenu-item").innerText;
                }
                if (!targetElement.closest("#city-data") && document.querySelector("#city-data")) {
                    const inputOrder = document.querySelector("#city-data");
                    if (inputOrder.closest(".popup__form-item").querySelector(".popup__submenu").classList.contains("_popup-submenu-open")) inputOrder.closest(".popup__form-item").querySelector(".popup__submenu").classList.remove("_popup-submenu-open");
                }
                if (targetElement.closest("#city-data-change")) targetElement.closest(".popup__form-item").querySelector(".popup__submenu").classList.toggle("_popup-submenu-open");
                if (targetElement.closest(".popup__submenu-item") && document.querySelector("#city-data-change")) {
                    const inputOrder = document.querySelector("#city-data-change");
                    inputOrder.value = targetElement.closest(".popup__submenu-item").innerText;
                }
                if (!targetElement.closest("#city-data-change") && document.querySelector("#city-data-change")) {
                    const inputOrder = document.querySelector("#city-data-change");
                    if (inputOrder.closest(".popup__form-item").querySelector(".popup__submenu").classList.contains("_popup-submenu-open")) inputOrder.closest(".popup__form-item").querySelector(".popup__submenu").classList.remove("_popup-submenu-open");
                }
                if (targetElement.closest(".product__seil")) targetElement.closest(".tabs__product").classList.add("_arrange-button");
                if (targetElement.closest("#with-photo")) {
                    const hidden = targetElement.closest(".reviews__body").querySelectorAll(".feedback");
                    hidden.forEach((element => {
                        if (!element.querySelector(".feedback__photo")) element.classList.toggle("_hidden-feedback");
                    }));
                }
                if (targetElement.closest(".popup__img-close")) targetElement.closest(".popup__photo-img").remove();
                if (targetElement.closest(".carts-product__add")) targetElement.closest(".string__item").classList.add("_string-active");
                if (targetElement.closest(".list-popup__button-top") && targetElement.closest("#add-list")) targetElement.closest(".list-popup__top").classList.add("_actions-open");
                if (targetElement.closest(".cancellation")) targetElement.closest(".list-popup__top").classList.remove("_actions-open");
                if (targetElement.closest(".save-item")) {
                    let inputAdd = targetElement.closest(".list-popup").querySelector("#add-list-item");
                    let popupList = targetElement.closest(".list-popup").querySelector(".list-popup__body");
                    var liAdditemStar = document.createElement("li");
                    popupList.appendChild(liAdditemStar);
                    liAdditemStar.classList.add("list-popup__item");
                    liAdditemStar.innerHTML = `\n\t\t\t\t<div class="checkbox">\n\t\t\t\t\t<input id="add_${targetElement.closest(".list-popup").querySelector(".list-popup__body").getElementsByTagName("li").length}" data-error="Ошибка" class="checkbox__input"\n\t\t\t\t\t\ttype="checkbox" value="Chanel" name="form[]">\n\t\t\t\t\t<label for="add_${targetElement.closest(".list-popup").querySelector(".list-popup__body").getElementsByTagName("li").length}" class="checkbox__label">\n\t\t\t\t\t\t<span class="checkbox__body "></span>\n\t\t\t\t\t\t<span class="checkbox__text">${inputAdd.value}</span>\n\t\t\t\t\t</label>\n\t\t\t\t</div>\n\t\t\t\t`;
                    inputAdd.value = "";
                }
                if (targetElement.closest(".tabs-graph")) {
                    const subMenuId = targetElement.dataset.parent ? targetElement.dataset.parent : null;
                    const subMenu = document.querySelector(`[data-submenu="${subMenuId}"]`);
                    const graphs = targetElement.closest(".tabs__navigation").querySelectorAll(".tabs-graph");
                    graphs.forEach((element => {
                        element.classList.remove("_tab-active");
                    }));
                    targetElement.classList.add("_tab-active");
                    const asd = targetElement.closest(".graph-popup__tabs").querySelectorAll(".tabs__body");
                    asd.forEach((element => {
                        element.classList.remove("_sub-menu-open");
                    }));
                    subMenu.classList.add("_sub-menu-open");
                }
                if (targetElement.closest(".carts-product__add") || targetElement.closest(".product__seil_seil") || targetElement.closest(".actions-otliv__button_cart") || targetElement.closest(".produce .quantity__button--plus") || targetElement.closest(".seil-to-make")) {
                    const empty = document.querySelector(".actions-header__empty");
                    const cartHeader = document.querySelector(".cart");
                    const cartQuantity = document.querySelector(".actions-header__quantity");
                    cartQuantity.classList.add("_quantity-visible");
                    cartHeader.classList.add("_cart-active");
                    setTimeout((function() {
                        cartHeader.classList.remove("_cart-active");
                    }), 2e3);
                    empty.hidden = true;
                }
                if (targetElement.closest(".checkbox-cart-check-all") && flagCart == true) {
                    const cartCheck = targetElement.closest(".main-cart").querySelectorAll(".checkbox__input");
                    flagCart = false;
                    cartCheck.forEach((element => {
                        element.checked = true;
                    }));
                } else if (targetElement.closest(".checkbox-cart-check-all") && flagCart == false) {
                    flagCart = true;
                    const cartCheck = targetElement.closest(".main-cart").querySelectorAll(".checkbox__input");
                    cartCheck.forEach((element => {
                        element.checked = false;
                    }));
                }
                if (targetElement.closest(".actions-cart__button")) {
                    const cartItems = targetElement.closest(".main-cart").querySelectorAll(".list-cart__item");
                    cartItems.forEach((element => {
                        element.remove();
                    }));
                }
                if (targetElement.closest(".remove-cart-item") || targetElement.closest(".list-cart__item-close")) targetElement.closest(".list-cart__item").remove();
                if (targetElement.closest(".gifts .quantity__button--plus")) {
                    const buttonMinus = targetElement.closest(".gift__quantity").querySelector(".quantity__button--minus");
                    buttonMinus.style.visibility = "visible";
                }
                if (targetElement.closest(".out__button")) {
                    const outProducts = targetElement.closest(".out").querySelectorAll(".list-cart__item");
                    outProducts.forEach((element => {
                        element.remove();
                    }));
                }
                const gift = targetElement.closest(".gift__button") ? targetElement.closest(".gift__button") : null;
                if (gift && !gift.classList.contains("button-actions")) {
                    targetElement.closest(".gift__item").classList.add("_shadow-gift");
                    gift.textContent = "ВЫБРАНО";
                    gift.classList.add("button-actions");
                    gift.classList.remove("button-light");
                } else if (gift && gift.classList.contains("button-actions")) {
                    targetElement.closest(".gift__item").classList.remove("_shadow-gift");
                    gift.classList.remove("button-actions");
                    gift.classList.add("button-light");
                    gift.textContent = "ВЫБРАТЬ";
                    gift.closest(".gift__item").querySelector(".gift__input").value = 0;
                }
                if (targetElement.closest(".aside-cart__button")) targetElement.closest(".aside-cart__buttons").classList.add("_button-change");
                if (targetElement.closest(".cancel-bonus")) targetElement.closest(".list-aside__item").nextElementSibling.style.display = "flex";
                if (targetElement.closest(".promo-ok")) {
                    const inputCode = targetElement.closest("form").querySelector(".origin-input").value;
                    const etalonInput = targetElement.closest("form").querySelector(".test-input").value;
                    if (inputCode == etalonInput) {
                        targetElement.closest("form").classList.remove("_error-code");
                        targetElement.closest("form").classList.add("_done-code");
                    } else {
                        targetElement.closest("form").classList.remove("_done-code");
                        targetElement.closest("form").classList.add("_error-code");
                    }
                }
                if (targetElement.closest(".out__text") && !targetElement.previousElementSibling.querySelector("input").checked == true) targetElement.previousElementSibling.querySelector("input").checked = true; else if (targetElement.closest(".out__text") && targetElement.previousElementSibling.querySelector("input").checked == true) targetElement.previousElementSibling.querySelector("input").checked = false;
                if (targetElement.closest(".bottom-calc__item") && document.querySelector(".method")) {
                    const metods = targetElement.closest(".method").querySelectorAll(".bottom-calc__item");
                    metods.forEach((element => {
                        element.classList.remove("_method-active");
                    }));
                    targetElement.closest(".bottom-calc__item").classList.add("_method-active");
                }
                if (targetElement.closest(".edit") && flagred == true) {
                    flagred = false;
                    targetElement.closest(".edit").classList.add("_change-pancel");
                    targetElement.closest(".list-popup__button-text") ? targetElement.closest(".list-popup__button-text").textContent = "сохранить изменения" : null;
                    targetElement.closest(".list-popup__button-text") ? targetElement.closest(".list-popup__button-text").style.color = "#23A104" : null;
                    const inputAddress = targetElement.closest("form").querySelectorAll("input");
                    inputAddress.forEach((element => {
                        element.removeAttribute("disabled");
                    }));
                    targetElement.closest("form").querySelector(".address__group_optional").style.display = "flex";
                } else if (targetElement.closest(".edit") && flagred == false) {
                    flagred = true;
                    targetElement.closest(".edit").classList.remove("_change-pancel");
                    targetElement.closest(".list-popup__button-text") ? targetElement.closest(".list-popup__button-text").textContent = "Редактировать данные" : null;
                    targetElement.closest(".list-popup__button-text") ? targetElement.closest(".list-popup__button-text").style.color = "#1D76C9" : null;
                    const inputAddress = targetElement.closest("form").querySelectorAll("input");
                    inputAddress.forEach((element => {
                        element.setAttribute("disabled", "");
                    }));
                    targetElement.closest("form").querySelector(".address__group_optional").style.display = "none";
                    const labelEmptyInput = targetElement.closest(".list-popup__button-text") ? targetElement.closest(".list-popup__button-text").closest(".address__form").querySelectorAll(".label-up-cart") : null;
                    labelEmptyInput.forEach((element => {
                        element.classList.remove("_label-down");
                    }));
                }
                if (targetElement.closest("#address-cart")) targetElement.closest(".popup__form-item").querySelector(".popup__submenu").classList.toggle("_popup-submenu-open");
                const addressCart = document.getElementById("address-cart");
                if (targetElement.closest(".submenu-item__address")) addressCart.value = targetElement.closest(".submenu-item__address").innerText;
                if (!targetElement.closest("#address-cart") && document.getElementById("address-cart")) if (addressCart.closest(".popup__form-item").querySelector(".popup__submenu").classList.contains("_popup-submenu-open")) addressCart.closest(".popup__form-item").querySelector(".popup__submenu").classList.remove("_popup-submenu-open");
                if (targetElement.closest("#search-index")) {
                    const inputIndex = targetElement.closest("form").querySelector("input");
                    if (!inputIndex.value == "") targetElement.closest(".popup__body").querySelector(".post-result").style.display = "block";
                }
                if (targetElement.closest(".time-delivery__item")) {
                    const timeList = targetElement.closest(".time-delivery__list").querySelectorAll(".time-delivery__item");
                    timeList.forEach((element => {
                        element.classList.remove("_tab-active");
                        targetElement.classList.add("_tab-active");
                    }));
                    let timeDelivery = targetElement.innerText;
                    document.querySelector("._method-active .delivery__time").innerText = timeDelivery;
                }
                if (targetElement.closest(".date-select__title")) {
                    let dateDelivery = targetElement.closest(".date-select__title").querySelector(".date-select__number").innerText;
                    document.querySelector("._method-active .delivery__day").innerText = dateDelivery;
                }
                if (targetElement.closest(".pip__item") && !targetElement.closest(".pip__item").classList.contains("_choose-punkt")) {
                    const pips = targetElement.closest(".pip__list").querySelectorAll(".pip__item");
                    pips.forEach((element => {
                        element.classList.remove("_choose-punkt");
                    }));
                    targetElement.closest(".pip__item").classList.add("_choose-punkt");
                } else if (targetElement.closest(".pip__item") && targetElement.closest(".pip__item").classList.contains("_choose-punkt")) targetElement.closest(".pip__item").classList.remove("_choose-punkt");
                if (targetElement.closest("#add_all") && flagAllPopup == true) {
                    flagAllPopup = false;
                    const listPopup = targetElement.closest(".list-popup__body").querySelectorAll("input");
                    listPopup.forEach((element => {
                        element.checked = true;
                    }));
                } else if (targetElement.closest("#add_all") && flagAllPopup == false) {
                    flagAllPopup = true;
                    const listPopup = targetElement.closest(".list-popup__body").querySelectorAll("input");
                    listPopup.forEach((element => {
                        element.checked = false;
                    }));
                }
                if (targetElement.closest(".lk-address__button-delete")) targetElement.closest(".lk-address__item").remove();
                if (targetElement.closest(".popup__img-close")) document.querySelector(".popup__img-add").style.display = "block";
                if (targetElement.closest("#save-data-button") && document.querySelector(".basket")) {
                    const formData = targetElement.closest("body").querySelector("#add-address");
                    getValuesCart();
                    function getValuesCart() {
                        const numbers = [];
                        const inputs = formData.querySelectorAll("input");
                        const adresses = targetElement.closest("body").querySelector(".popup__form-item_address > ul");
                        for (const input of inputs) numbers.push(input.value);
                        const str = numbers.filter((element => element !== null && element !== void 0 && element !== "")).join(", ");
                        adresses.insertAdjacentHTML("beforeEnd", `<li class="submenu-item__address">${str}</li>`);
                        closePopup("#save-data");
                    }
                }
                if (targetElement.closest("#save-data-button") && document.querySelector(".lk")) {
                    const formData = targetElement.closest("body").querySelector("#add-address");
                    getValues();
                    function getValues() {
                        const numbers = [];
                        const inputs = formData.querySelectorAll("input");
                        const adresses = targetElement.closest("body").querySelector(".lk-address__group");
                        for (const input of inputs) numbers.push(input.value);
                        const str = numbers.filter((element => element !== null && element !== void 0 && element !== "")).join(", ");
                        adresses.insertAdjacentHTML("beforeEnd", `<div class="lk-address__item">\n\t\t\t\t\t<p class="lk-address__text">${str}</p>\n\t\t\t\t\t<div class="lk-address__actions">\n\t\t\t\t\t\t<button data-popup="#change-delivery-address" type="button" class="lk-address__button">\n\t\t\t\t\t\t\t<img src="img/lk/redactors.svg" alt="изменить">\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button type="button" class="lk-address__button lk-address__button-delete">\n\t\t\t\t\t\t\t<img src="img/lk/delete.svg" alt="удалить">\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>`);
                        closePopup("#save-data");
                    }
                }
                if (targetElement.closest("#no-save-data") && document.querySelector(".lk")) closePopup("#save-data");
                if (targetElement.closest("#day-birthday") && document.querySelector(".popup__photo-img")) {
                    document.documentElement.classList.add("_add-photo");
                    closePopup("#add-document");
                }
                if (targetElement.closest(".lk__item_button-save")) {
                    targetElement.closest(".lk").classList.add("_save-data-complite");
                    setTimeout((function() {
                        targetElement.closest(".lk").classList.remove("_save-data-complite");
                    }), 2e3);
                }
                if (targetElement.closest("#change-number")) {
                    let phoneLk = targetElement.closest("body").querySelector("#phone-lk");
                    let newPhone = targetElement.closest("#change-phone").querySelector("#change-number-phone");
                    if (newPhone.value !== "") {
                        closePopup("#change-phone");
                        phoneLk.value = newPhone.value;
                    }
                }
                if (targetElement.closest(".favorite__button_redaction")) {
                    new sortable_esm(example1, {
                        animation: 150,
                        ghostClass: "background-class",
                        filter: ".ignore-elements"
                    });
                    new sortable_esm(example2, {
                        animation: 150,
                        ghostClass: "background-class",
                        filter: ".ignore-elements"
                    });
                    if (document.getElementById("example3") && document.getElementById("example4")) {
                        new sortable_esm(example3, {
                            animation: 150,
                            ghostClass: "background-class",
                            filter: ".ignore-elements"
                        });
                        new sortable_esm(example4, {
                            animation: 150,
                            ghostClass: "background-class",
                            filter: ".ignore-elements"
                        });
                    }
                    targetElement.closest(".favorites__actions").classList.add("_change-button-favorites");
                    const buttonFavorite = document.querySelectorAll(".product__actions");
                    buttonFavorite.forEach((element => {
                        element.classList.add("_button-del");
                    }));
                    targetElement.closest("[data-tabs]").querySelector("[data-tabs-body]").classList.add("_redaction-yes");
                } else if (targetElement.closest(".favorite__button_save")) {
                    targetElement.closest(".favorites__actions").classList.remove("_change-button-favorites");
                    const buttonFavorite = document.querySelectorAll(".product__actions");
                    buttonFavorite.forEach((element => {
                        element.classList.remove("_button-del");
                    }));
                    targetElement.closest("[data-tabs]").querySelector("[data-tabs-body]").classList.remove("_redaction-yes");
                }
                if (document.querySelector(".favorites")) if (targetElement.closest(".list .product-del-favorites")) {
                    targetElement.closest(".product").remove();
                    const removeItem = targetElement.closest(".product").dataset.list;
                    const removeItemBlock = document.querySelector(`[data-block="${removeItem}"]`);
                    removeItemBlock.remove();
                } else if (targetElement.closest(".tile .product-del-favorites")) {
                    targetElement.closest(".product").remove();
                    const removeItem = targetElement.closest(".product").dataset.block;
                    const removeItemBlock = document.querySelector(`[data-list="${removeItem}"]`);
                    removeItemBlock.remove();
                }
                if (document.querySelector(".wait")) {
                    if (targetElement.closest("[data-listwait] .product-del-favorites")) {
                        targetElement.closest(".product").remove();
                        const removeItem = targetElement.closest(".product").dataset.listwait;
                        const removeItemBlock = document.querySelector(`[data-blockwait="${removeItem}"]`);
                        removeItemBlock.remove();
                    }
                    if (targetElement.closest("[data-listyes] .product-del-favorites")) {
                        targetElement.closest(".product").remove();
                        const removeItem = targetElement.closest(".product").dataset.listyes;
                        const removeItemBlock = document.querySelector(`[data-blockyes="${removeItem}"]`);
                        removeItemBlock.remove();
                    }
                    if (targetElement.closest("[data-blockwait] .product-del-favorites")) {
                        targetElement.closest(".product").remove();
                        const removeItem = targetElement.closest(".product").dataset.blockwait;
                        const removeItemBlock = document.querySelector(`[data-listwait="${removeItem}"]`);
                        removeItemBlock.remove();
                    }
                    if (targetElement.closest("[data-blockyes] .product-del-favorites")) {
                        targetElement.closest(".product").remove();
                        const removeItem = targetElement.closest(".product").dataset.blockyes;
                        const removeItemBlock = document.querySelector(`[data-listyes="${removeItem}"]`);
                        removeItemBlock.remove();
                    }
                }
                if (targetElement.closest("#add-lk-list .popup__button")) {
                    const listInput = targetElement.closest("form").querySelector("#create-list-lk");
                    if (listInput.value !== "") {
                        const lkList = document.querySelector(".lk-list__wrapper");
                        lkList.insertAdjacentHTML("afterbegin", `\n\t\t\t\t<div data-lk-list-item="${Date.now()}" class="lk-address__item">\n\t\t\t\t\t<a href="lk-list-item.html" class="lk-address__text">${listInput.value}</a>\n\t\t\t\t\t<div class="lk-address__actions">\n\t\t\t\t\t\t<button data-popup="#lk-list-name" type="button" class="lk-address__button lk-list__button-change">\n\t\t\t\t\t\t\t<img src="img/lk/redactors.svg" alt="изменить">\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button data-popup="#lk-list-item-del" type="button" class="lk-address__button lk-list__button-delete">\n\t\t\t\t\t\t\t<img src="img/lk/delete.svg" alt="удалить">\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t`);
                        closePopup("#add-lk-list");
                    }
                }
                if (targetElement.closest('[data-popup="#lk-list-name"]')) {
                    const listNameItem = targetElement.closest(".lk-address__item").querySelector(".lk-address__text");
                    const listNameItemPopup = document.querySelector("#lk-list-name").querySelector("input");
                    listNameItemPopup.value = listNameItem.innerText;
                }
                if (targetElement.closest(".lk-list__button-change")) idItemListLk = targetElement.closest("[data-lk-list-item]") ? targetElement.closest("[data-lk-list-item]").dataset.lkListItem : null;
                if (targetElement.closest("#change-name-item")) {
                    const inputName = document.querySelector(`div[data-lk-list-item = "${idItemListLk}"]`).querySelector(".lk-address__text");
                    console.log(inputName);
                    const listNameItemPopup = targetElement.closest("form").querySelector("input");
                    if (listNameItemPopup.value !== "") {
                        inputName.textContent = listNameItemPopup.value;
                        closePopup("#lk-list-name");
                    }
                }
                if (targetElement.closest(".lk-list__button-delete")) idItemListLk = targetElement.closest("[data-lk-list-item]") ? targetElement.closest("[data-lk-list-item]").dataset.lkListItem : null;
                if (targetElement.closest("#lk-list-item-del .button-light")) closePopup("#lk-list-item-del"); else if (targetElement.closest("#lk-list-item-del .popup__button")) {
                    document.querySelector(`div[data-lk-list-item = "${idItemListLk}"]`).remove();
                    closePopup("#lk-list-item-del");
                }
                if (targetElement.closest(".lk-sertificate__copy")) {
                    targetElement.closest(".lk__item").classList.add("_lk-window-open");
                    setTimeout((function() {
                        targetElement.closest(".lk__item").classList.remove("_lk-window-open");
                    }), 2e3);
                }
            }
        }));
        document.addEventListener("DOMContentLoaded", (() => {
            const secondTabs = document.querySelector("#secondTabs");
            if (window.innerWidth < 767.5 && secondTabs) {
                const tabs01 = document.querySelector("#tabs01");
                const tabs02 = document.querySelector("#tabs02");
                tabs01 ? tabs01.classList.remove("_tab-active") : null;
                secondTabs ? secondTabs.hidden = false : null;
                tabs02 ? tabs02.classList.add("_tab-active") : null;
            }
            const breadcrumbs = document.querySelector(".breadcrumbs__list");
            if (breadcrumbs) {
                console.log(breadcrumbs.clientWidth);
                console.log(window.innerWidth);
                if (30 + breadcrumbs.clientWidth > window.innerWidth) {
                    breadcrumbs.classList.add("_align-right");
                    breadcrumbs.parentElement.classList.add("_breadcrumbs-swipe");
                }
            }
            const searchMob = document.querySelector(".search-mob");
            const headerDropMobile = searchMob.querySelector(".dropmenu");
            headerDropMobile.style.top = `${searchMob.clientHeight}` + "px";
            window.addEventListener("load", (function() {
                if (window.innerWidth < 768 && document.querySelector(".otlvant-review__spoller-title")) {
                    const reviewsTitle = document.querySelector(".otlvant-review__spoller-title");
                    reviewsTitle.addEventListener("click", writeFull);
                } else writeFullSet();
                function writeFull() {
                    setTimeout(writeFullSet, 100);
                }
                function writeFullSet() {
                    const feedBackWrapper = document.querySelectorAll(".feedback__text-wrapper");
                    feedBackWrapper.forEach((element => {
                        const feedBackText = element.querySelector(".feedback__text");
                        if (element.clientHeight + 5 < feedBackText.clientHeight) element.closest(".feedback__content").querySelector(".feedback__write").classList.add("_open-write");
                    }));
                }
            }));
            const taComments = document.querySelector(".comment__textarea");
            const counter = document.querySelector(".comment__number-symbols");
            taComments ? taComments.addEventListener("input", onInput) : null;
            function onInput(evt) {
                const length = evt.target.value.length;
                counter.textContent = length;
            }
            const partReview1 = document.querySelector(".part-review1");
            const partReview1Tab = document.querySelector(".part-review1-tab");
            const partReview2 = document.querySelector(".part-review2");
            const partReview2Tab = document.querySelector(".part-review2-tab");
            const partReview3 = document.querySelector(".part-review3");
            const partReview3Tab = document.querySelector(".part-review3-tab");
            const partReview4 = document.querySelector(".part-review4");
            const partReview4Tab = document.querySelector(".part-review4-tab");
            partReview1Tab ? partReview1Tab.innerHTML = partReview1.innerHTML : null;
            partReview2Tab ? partReview2Tab.innerHTML = partReview2.innerHTML : null;
            partReview3Tab ? partReview3Tab.innerHTML = partReview3.innerHTML : null;
            partReview4Tab ? partReview4Tab.innerHTML = partReview4.innerHTML : null;
            const productReview = document.querySelector(".description-product__content");
            const writeFull = document.querySelector(".feedback__write");
            if (productReview && productReview.clientHeight <= 300) writeFull.style.display = "none";
            const pozSearch = document.querySelector(".string__item_search");
            const hint = document.querySelector(".string__hint");
            if (pozSearch && hint) {
                hint.style.top = pozSearch.offsetTop + pozSearch.clientHeight / 2 + "px";
                setTimeout((() => {
                    hint.remove();
                }), 3e3);
            }
            const pozContainer = document.querySelector(".string");
            if (pozContainer) {
                const pozitions = pozContainer.querySelectorAll(".string__item");
                let pozitionsHeight = 0;
                pozitions.forEach((element => {
                    pozitionsHeight += element.clientHeight + 10;
                }));
                if (pozitionsHeight - 10 > pozContainer.clientHeight) pozContainer.style.paddingRight = "5px";
            }
            const basket = document.querySelector(".basket__link");
            if (basket) {
                basket.addEventListener("mousemove", EmptyMove);
                function EmptyMove() {
                    basket.querySelector(".actions-header__empty").classList.add("_no-hidden");
                }
                basket.addEventListener("mouseleave", EmptyLeave);
                function EmptyLeave() {
                    basket.querySelector(".actions-header__empty").classList.remove("_no-hidden");
                }
            }
            const man = document.querySelector(".man");
            if (man) {
                man.querySelector(".cart-list__gender").textContent = "Мужская парфюмерия";
                const genderWoman = document.querySelectorAll(".produce__button_red");
                const genderMan = document.querySelectorAll(".produce__button_blue");
                genderWoman.forEach((element => {
                    element.classList.remove("_button-active");
                }));
                genderMan.forEach((element => {
                    element.classList.add("_button-active");
                }));
            }
            const inputGift = document.querySelectorAll(".gift__input");
            inputGift.forEach((element => {
                if (element.value == "0") {
                    let buttonMinus = element.closest(".quantity__input").previousElementSibling;
                    buttonMinus.style.visibility = "hidden";
                }
            }));
            if (document.querySelector(".guest")) {
                const adressWrapper = document.querySelector(".address__wrapper");
                if (adressWrapper) {
                    const inputAdress = adressWrapper.querySelectorAll(".popup__input");
                    inputAdress.forEach((element => {
                        element.removeAttribute("disabled");
                        element.value = "";
                    }));
                }
            }
            const labelInPopup = document.querySelectorAll(".popup__label");
            labelInPopup.forEach((element => {
                if (element.closest(".popup")) element.classList.add("_label-in-popup");
            }));
            const phoneNumber = document.querySelector(".phone-popup");
            const phoneNumberCode = document.querySelector(".phone-popup-code");
            phoneNumber.addEventListener("input", (() => {
                phoneNumberCode.value = phoneNumber.value;
            }));
            const inputsNL = document.querySelectorAll(".popup__entry-vhod");
            const inputsList = Array.prototype.slice.call(inputsNL);
            inputsList.forEach(((input, index) => {
                input.addEventListener("keyup", (function(ev) {
                    if (ev.which === 69) return input.value = "";
                    let value = input.value;
                    let len = value.length;
                    if (ev.which === 8 && inputsList[index - 1]) return inputsList[index - 1].focus();
                    if (len === 1) {
                        input.value = value.substr(0, 1);
                        if (inputsList[index + 1]) inputsList[index + 1].focus();
                    } else if (inputsList[index + 1] && ev.which != 8) {
                        input.value = value.substr(0, 1);
                        inputsList[index + 1].focus();
                        inputsList[index + 1].value = value.substr(1, 1);
                    } else if (len > 1 && !inputsList[index + 1]) input.value = value.substr(0, 1);
                }));
            }));
            const inputTypeEmail = document.querySelectorAll('[type="email"]');
            inputTypeEmail.forEach((element => {
                element.addEventListener("input", (function() {
                    if (element.value !== "") element.closest(".popup__form-item").classList.add("_label"); else if (element.closest(".popup__form-item").classList.contains("_label")) element.closest(".popup__form-item").classList.remove("_label");
                }));
            }));
            const inputTypeNumber = document.querySelectorAll('[type="number"]');
            inputTypeNumber.forEach((element => {
                element.addEventListener("input", (function() {
                    if (element.value !== "") element.closest(".popup__form-item").classList.add("_label"); else if (element.closest(".popup__form-item").classList.contains("_label")) element.closest(".popup__form-item").classList.remove("_label");
                }));
            }));
            const TextareaNotRequired = document.querySelectorAll("textarea:not([required])");
            TextareaNotRequired.forEach((element => {
                element.addEventListener("input", (function() {
                    if (element.value !== "" && !element.activeElement) element.closest(".popup__form-item") ? element.closest(".popup__form-item").classList.add("_label") : null; else if (element.closest(".popup__form-item") && element.closest(".popup__form-item").classList.contains("_label")) element.closest(".popup__form-item").classList.remove("_label");
                }));
            }));
            const inputNotRequired = document.querySelectorAll("input:not([required])");
            inputNotRequired.forEach((element => {
                element.addEventListener("input", (function() {
                    if (element.value !== "" && !element.activeElement) element.closest(".popup__form-item") ? element.closest(".popup__form-item").classList.add("_label") : null; else if (element.closest(".popup__form-item") && element.closest(".popup__form-item").classList.contains("_label")) element.closest(".popup__form-item").classList.remove("_label");
                }));
            }));
            const inputLabelUp = document.querySelectorAll(".label-up-cart > input");
            inputLabelUp.forEach((element => {
                element.addEventListener("input", (function() {
                    if (element.value == "") element.closest(".label-up-cart").classList.add("_label-down"); else if (element.value !== "") element.closest(".label-up-cart").classList.remove("_label-down");
                }));
            }));
        }));
        new index_es("#lk-birthday", {
            classes: "castom",
            autoClose: true
        });
        const catalog = document.querySelector(".catalog");
        if (catalog) {
            const details = catalog.querySelectorAll("details");
            const spollersWrapper = catalog.querySelector("aside [data-spollers]");
            const summury = catalog.querySelectorAll(".filter__title-wrapper");
            if (window.innerWidth < 1001.5) {
                details.forEach((element => {
                    element.removeAttribute("data-open");
                }));
                spollersWrapper.setAttribute("data-one-spoller", "");
                summury.forEach((element => {
                    element.setAttribute("data-spoller-close", "");
                    element.classList.remove("_spoller-active");
                }));
            }
        }
        const payment = document.querySelector(".payment");
        if (payment) {
            const details = payment.querySelectorAll("details");
            if (window.innerWidth < 768.02) details.forEach((element => {
                element.removeAttribute("data-open");
            }));
        }
        const store = document.querySelector(".store");
        if (store) {
            const details = store.querySelectorAll("details");
            if (window.innerWidth < 768.02) {
                details.forEach((element => {
                    element.removeAttribute("data-open");
                }));
                store.querySelector(".store-not-open").setAttribute("data-open", "");
            }
        }
        var canvasjs_min = __webpack_require__(896);
        window.onload = function() {
            if (document.querySelector(".graph-content")) {
                var chart01 = new canvasjs_min.Chart("chartContainer01", {
                    animationEnabled: true,
                    animationDuration: 1e3,
                    axisX: {
                        labelFontSize: 14,
                        labelFormatter: function(e) {
                            return canvasjs_min.formatDate(e.value, "DD.MM.YYYY");
                        },
                        gridThickness: 2,
                        gridColor: "#c4c4c480",
                        lineColor: "#c4c4c480",
                        tickLength: 10,
                        tickColor: "#c4c4c480",
                        tickThickness: 2
                    },
                    axisY: {
                        valueFormatString: "####",
                        labelFontSize: 14,
                        minimum: 2100,
                        maximum: 3e3,
                        gridThickness: 2,
                        gridColor: "#c4c4c480",
                        lineColor: "#c4c4c480",
                        tickLength: 10,
                        tickColor: "#c4c4c480",
                        tickThickness: 2
                    },
                    toolTip: {
                        cornerRadius: 8,
                        fontColor: "#000",
                        fontSize: 16,
                        borderColor: "#BF5C7A",
                        backgroundColor: "#fdfafb"
                    },
                    data: [ {
                        type: "spline",
                        lineColor: "#BF5C7A",
                        markerSize: 14,
                        markerColor: "#BF5C7A",
                        dataPoints: [ {
                            x: new Date(2010, 0, 3),
                            y: 2300
                        }, {
                            x: new Date(2010, 0, 5),
                            y: 2400
                        }, {
                            x: new Date(2010, 0, 7),
                            y: 2400
                        }, {
                            x: new Date(2010, 0, 9),
                            y: 2450
                        }, {
                            x: new Date(2010, 0, 11),
                            y: 2550
                        }, {
                            x: new Date(2010, 0, 13),
                            y: 2500
                        }, {
                            x: new Date(2010, 0, 15),
                            y: 2600
                        }, {
                            x: new Date(2010, 0, 17),
                            y: 2530
                        } ]
                    } ]
                });
                chart01.render();
                var chart02 = new canvasjs_min.Chart("chartContainer02", {
                    animationEnabled: true,
                    animationDuration: 1e3,
                    axisX: {
                        labelFontSize: 14,
                        labelFormatter: function(e) {
                            return canvasjs_min.formatDate(e.value, "DD.MM.YYYY");
                        },
                        gridThickness: 2,
                        gridColor: "#c4c4c480",
                        lineColor: "#c4c4c480",
                        tickLength: 10,
                        tickColor: "#c4c4c480",
                        tickThickness: 2
                    },
                    axisY: {
                        valueFormatString: "####",
                        labelFontSize: 14,
                        minimum: 2100,
                        maximum: 3e3,
                        gridThickness: 2,
                        gridColor: "#c4c4c480",
                        lineColor: "#c4c4c480",
                        tickLength: 10,
                        tickColor: "#c4c4c480",
                        tickThickness: 2
                    },
                    toolTip: {
                        cornerRadius: 8,
                        fontColor: "#000",
                        fontSize: 16,
                        borderColor: "#BF5C7A",
                        backgroundColor: "#fdfafb"
                    },
                    data: [ {
                        type: "spline",
                        lineColor: "#BF5C7A",
                        markerSize: 14,
                        markerColor: "#BF5C7A",
                        dataPoints: [ {
                            x: new Date(2010, 0, 3),
                            y: 2400
                        }, {
                            x: new Date(2010, 0, 5),
                            y: 2400
                        }, {
                            x: new Date(2010, 0, 7),
                            y: 2400
                        }, {
                            x: new Date(2010, 0, 9),
                            y: 2450
                        }, {
                            x: new Date(2010, 0, 11),
                            y: 2550
                        }, {
                            x: new Date(2010, 0, 13),
                            y: 2500
                        }, {
                            x: new Date(2010, 0, 15),
                            y: 2600
                        }, {
                            x: new Date(2010, 0, 17),
                            y: 2530
                        } ]
                    } ]
                });
                chart02.render();
                var chart03 = new canvasjs_min.Chart("chartContainer03", {
                    animationEnabled: true,
                    animationDuration: 1e3,
                    axisX: {
                        labelFontSize: 14,
                        labelFormatter: function(e) {
                            return canvasjs_min.formatDate(e.value, "DD.MM.YYYY");
                        },
                        gridThickness: 2,
                        gridColor: "#c4c4c480",
                        lineColor: "#c4c4c480",
                        tickLength: 10,
                        tickColor: "#c4c4c480",
                        tickThickness: 2
                    },
                    axisY: {
                        valueFormatString: "####",
                        labelFontSize: 14,
                        minimum: 2100,
                        maximum: 3e3,
                        gridThickness: 2,
                        gridColor: "#c4c4c480",
                        lineColor: "#c4c4c480",
                        tickLength: 10,
                        tickColor: "#c4c4c480",
                        tickThickness: 2
                    },
                    toolTip: {
                        cornerRadius: 8,
                        fontColor: "#000",
                        fontSize: 16,
                        borderColor: "#BF5C7A",
                        backgroundColor: "#fdfafb"
                    },
                    data: [ {
                        type: "spline",
                        lineColor: "#BF5C7A",
                        markerSize: 14,
                        markerColor: "#BF5C7A",
                        dataPoints: [ {
                            x: new Date(2010, 0, 3),
                            y: 2500
                        }, {
                            x: new Date(2010, 0, 5),
                            y: 2400
                        }, {
                            x: new Date(2010, 0, 7),
                            y: 2400
                        }, {
                            x: new Date(2010, 0, 9),
                            y: 2450
                        }, {
                            x: new Date(2010, 0, 11),
                            y: 2550
                        }, {
                            x: new Date(2010, 0, 13),
                            y: 2500
                        }, {
                            x: new Date(2010, 0, 15),
                            y: 2600
                        }, {
                            x: new Date(2010, 0, 17),
                            y: 2530
                        } ]
                    } ]
                });
                chart03.render();
            }
            if (document.querySelector(".discount-info")) {
                var chart04 = new canvasjs_min.Chart("lk-discount-graph", {
                    animationEnabled: true,
                    animationDuration: 300,
                    toolTip: {
                        cornerRadius: 8,
                        fontColor: "#000",
                        fontSize: 16,
                        borderColor: "#BF5C7A",
                        backgroundColor: "#fdfafb"
                    },
                    data: [ {
                        type: "doughnut",
                        dataPoints: [ {
                            y: 80,
                            color: "#931236"
                        }, {
                            y: 20,
                            color: "#FF6892"
                        } ],
                        lineColor: "#BF5C7A",
                        markerSize: 14,
                        markerColor: "#BF5C7A"
                    } ]
                });
                chart04.render();
            }
        };
        window["FLS"] = false;
        isWebp();
        menuInit();
        spollers();
        tabs();
        showMore();
        formQuantity();
        pageNavigation();
    })();
})();